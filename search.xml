<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>[两万字教程]MYSQL必知必会一站式完全教程</title>
      <link href="/2023/07/15/liang-wan-zi-jiao-cheng-mysql-bi-zhi-bi-hui/"/>
      <url>/2023/07/15/liang-wan-zi-jiao-cheng-mysql-bi-zhi-bi-hui/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>此文是针对《MYSQL必知必会》一书学习的笔记与总结，注意要点的提示，<u>文末会放上总的思维导图</u>，该文除了对整书的脉络与知识点整理外，还有一些个人的总结见解，比如基本概念-mysql语句的法则与执行顺序，是通过阅读借鉴与实践再经过个人总结，后续且会不断更新本文，为写出更好的mysql语句 ^_^</p><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="什么是数据库？"><a href="#什么是数据库？" class="headerlink" title="什么是数据库？"></a>什么是数据库？</h2><p>一个以某种有组织的方式存储的数据集合，数据库（database） 保存有组织的数据的容器</p><p>数据库由表组成，行/列数据，数据类型；主键（primary key）一一列（或一组列），其值能够唯一区分表中每个行</p><h2 id="数据库术语"><a href="#数据库术语" class="headerlink" title="数据库术语"></a>数据库术语</h2><ul><li>数据库（database） - 保存有组织的数据的容器（通常是一个文件或一组文件）。</li><li>数据表（table） - 某种特定类型数据的结构化清单。</li><li>模式（schema） - 关于数据库和表的布局及特性的信息。模式定义了数据在表中如何存储，包含存储什么样的数据，数据如何分解，各部分信息如何命名等信息。数据库和表都有模式。</li><li>列（column） - 表中的一个字段。所有表都是由一个或多个列组成的。</li><li>行（row） - 表中的一个记录。</li><li>主键（primary key） - 一列（或一组列），其值能够唯一标识表中每一行</li></ul><h2 id="什么是SQL？"><a href="#什么是SQL？" class="headerlink" title="什么是SQL？"></a>什么是SQL？</h2><p>SQL是结构化查询语言（Structured Query  Language）的缩写。SQL是一种专门用来与数据库通信的语言</p><blockquote><p>语法结构：</p><p>1分号结尾、2不区分大小写、3字符要加单引号、4字段或参数间用逗号分割</p><ul><li><p>SQL 支持三种注释 </p><p> ## 注释1<br>– 注释2<br>/<em> 注释3 </em>/ </p></li><li><p>子句 - 是语句和查询的组成成分。（在某些情况下，这些都是可选的。）</p></li><li><p>表达式 - 可以产生任何标量值，或由列和行的数据库表</p></li><li><p>谓词 - 给需要评估的 SQL 三值逻辑（3VL）（true/false/unknown）或布尔真值指定条件，并限制语句和查询的效果，或改变程序流程。</p></li><li><p>查询 - 基于特定条件检索数据。这是 SQL 的一个重要组成部分。</p></li><li><p>语句 - 可以持久地影响纲要和数据，也可以控制数据库事务、程序流程、连接、会话或诊断。</p></li></ul></blockquote><h2 id="SQL分类"><a href="#SQL分类" class="headerlink" title="SQL分类"></a>SQL分类</h2><h3 id="数据定义语言（DDL）"><a href="#数据定义语言（DDL）" class="headerlink" title="数据定义语言（DDL）"></a>数据定义语言（DDL）</h3><p>数据定义语言（Data Definition Language，DDL）是 SQL 语言集中负责数据结构定义与数据库对象定义的语言。</p><p>DDL 的主要功能是定义数据库对象。</p><p>DDL 的核心指令是 CREATE、ALTER、DROP。</p><h3 id="数据操纵语言（DML）"><a href="#数据操纵语言（DML）" class="headerlink" title="数据操纵语言（DML）"></a>数据操纵语言（DML）</h3><p>数据操纵语言（Data Manipulation Language, DML）是用于数据库操作，对数据库其中的对象和数据运行访问工作的编程语句。</p><p>DML 的主要功能是 访问数据，因此其语法都是以读写数据库为主。</p><p>DML 的核心指令是 INSERT、UPDATE、DELETE、SELECT。这四个指令合称 CRUD(Create, Read, Update, Delete)，即增删改查。</p><h3 id="事务控制语言（TCL）"><a href="#事务控制语言（TCL）" class="headerlink" title="事务控制语言（TCL）"></a>事务控制语言（TCL）</h3><p>事务控制语言 (Transaction Control Language, TCL) 用于管理数据库中的事务。这些用于管理由 DML 语句所做的更改。它还允许将语句分组为逻辑事务。</p><p>TCL 的核心指令是 COMMIT、ROLLBACK。</p><h3 id="数据控制语言（DCL）"><a href="#数据控制语言（DCL）" class="headerlink" title="数据控制语言（DCL）"></a>数据控制语言（DCL）</h3><p>数据控制语言 (Data Control Language, DCL) 是一种可对数据访问权进行控制的指令，它可以控制特定用户账户对数据表、查看表、预存程序、用户自定义函数等数据库对象的控制权。</p><p>DCL 的核心指令是 GRANT、REVOKE。</p><p>DCL 以控制用户的访问权限为主，因此其指令做法并不复杂，可利用 DCL 控制的权限有：CONNECT、SELECT、INSERT、UPDATE、DELETE、EXECUTE、USAGE、REFERENCES。</p><p>根据不同的 DBMS 以及不同的安全性实体，其支持的权限控制也有所不同。</p><h2 id="什么是MYSQL？"><a href="#什么是MYSQL？" class="headerlink" title="什么是MYSQL？"></a>什么是MYSQL？</h2><p>MySQL是一种开源的关系型数据库管理系统（RDBMS），它是最流行和广泛使用的数据库之一。MySQL由瑞典公司MySQL AB开发，并在2008年被甲骨文公司收购。它支持多用户、多线程和多个存储引擎，可以在各种操作系统上运行。</p><p>MySQL具有以下特点：</p><ol><li><p>可靠性：MySQL以其稳定性和可靠性而闻名。它经过广泛测试和验证，被许多大型组织和网站用于处理大量数据。</p></li><li><p>性能：MySQL被设计为高性能数据库。它采用了各种优化技术，如索引、查询缓存和内存管理，以提供快速的数据访问和处理能力。</p></li><li><p>可扩展性：MySQL支持水平和垂直扩展。水平扩展通过分布式架构和数据分片来增加系统的容量和吞吐量。垂直扩展通过增加硬件资源（如CPU、内存）来提高单个服务器的性能。</p></li><li><p>简单易用：MySQL提供了简单而直观的命令和语法，使得数据库的管理和查询变得容易。它还提供了丰富的图形界面工具和API，方便开发人员进行数据库操作。</p></li><li><p>兼容性：MySQL遵循SQL标准，并提供了广泛的功能和特性，包括事务支持、触发器、存储过程和视图等。它还支持多种编程语言和开发框架。</p></li></ol><h2 id="MYSQL工具"><a href="#MYSQL工具" class="headerlink" title="MYSQL工具"></a>MYSQL工具</h2><ol><li>MySQL命令实用工具： 通过mysql的基础命令操作使用数据库</li><li>phpMyAdmin： phpMyAdmin是一个基于Web的MySQL数据库管理工具，它提供了一个易于使用的界面来管理数据库。通过phpMyAdmin，你可以执行SQL查询、导入和导出数据、创建和修改表结构、用户管理等。它支持多语言和跨平台，并且具有良好的扩展性，可以通过插件来增加额外的功能。phpMyAdmin是一个开源工具，广泛应用于各种Web开发项目中。</li><li>Navicat for MySQL：Navicat for MySQL是一款强大的数据库管理和开发工具，适用于MySQL和MariaDB。它提供了直观的用户界面，使得用户可以轻松地进行数据库设计、数据导入导出、SQL查询和脚本编写等操作。Navicat for MySQL支持多个平台，并且具有高级的数据可视化和报表生成功能。此外，它还提供了团队协作和版本控制的特性，方便多人共同开发和管理数据库。</li></ol><h2 id="使用MYSQL"><a href="#使用MYSQL" class="headerlink" title="使用MYSQL"></a>使用MYSQL</h2><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p>主机名（计算机名）——如果连接到本地MySQL服务器，为localhost； </p><p>端口（如果使用默认端口3306之外的端口）；</p><p> 一个合法的用户名； </p><p>用户口令（如果需要）；</p><h3 id="选择与了解"><a href="#选择与了解" class="headerlink" title="选择与了解"></a>选择与了解</h3><pre><code>show database;    #查看数据库use database；    #使用数据库show tables;    #查看表show status;    #查看广泛的服务器状态信息show grants;    #显示授予用户的安全权限show error;    show warnings;    #显示服务器错误或警告消息help show；    #查看show的使用帮助</code></pre><blockquote><p>什么是自动增量？ 某些表列需要唯一值。例如，订单编号\雇员ID或（如上面例子中所示的顾客ID。在每个行添加到表 中时，MySQL可以自动地为每个行分配下一个可用编号，不用在添加一行时手动分配唯一值（这样做必须记住最后一次使 用的值）这个功能就是所谓的自动增量。如果需要它，则必须在用CREATE语句创建表时把它作为表定义的组成部分。</p></blockquote><h2 id="MYSQL语句的法则！！"><a href="#MYSQL语句的法则！！" class="headerlink" title="MYSQL语句的法则！！"></a>MYSQL语句的法则！！</h2><h3 id="书写顺序与执行顺序！！"><a href="#书写顺序与执行顺序！！" class="headerlink" title="书写顺序与执行顺序！！"></a>书写顺序与执行顺序！！</h3><pre><code>(8) SELECT (9)DISTINCT&lt;Select_list&gt;(1) FROM &lt;left_table&gt; (3) &lt;join_type&gt;JOIN&lt;right_table&gt;(2) ON&lt;join_condition&gt;(4) WHERE&lt;where_condition&gt;(5) GROUP BY&lt;group_by_list&gt;(6) WITH {CUBE|ROLLUP}(7) HAVING&lt;having_condtion&gt;(10) ORDER BY&lt;order_by_list&gt;(11) LIMIT&lt;limit_number&gt;</code></pre><p>书写顺序为此排列，执行顺序为（1）~（11）</p><p>SELECT子句是必选的，其它子句如WHERE子句、GROUP BY子句等是可选的。一个select语句中，子句的顺序是固定的。必须严格按照上述的顺序书写 </p><h3 id="法则："><a href="#法则：" class="headerlink" title="法则："></a>法则：</h3><p>SELECT col,col,col 找什么？ FROM table 从哪找？ WHERE col 条件 条件是啥？</p><p>这个法则教你怎么一步步写一个查询SQL，可以当做一种写SQL的思维</p><p>简言之，写任何一个查询语句，都分解成3步：</p><p>第一步：思考FROM后面的（也即是表）</p><p>第二步：思考WHERE条件（查手册就可以）</p><p>第三步：完善SELECT后面的（也就是老板要显示的数据）</p><h3 id="条件：数字-where"><a href="#条件：数字-where" class="headerlink" title="条件：数字(where)"></a>条件：数字(where)</h3><pre><code>当查找条件col是数字</code></pre><p><code>select * from table where col = 1</code>;</p><table><thead><tr><th>Operator</th><th>Condition</th><th>SQL Example</th><th>解释</th></tr></thead><tbody><tr><td>=, !=, &lt; ,&lt;=, &gt;, &gt;=</td><td>Standard numerical operators</td><td>col != 4</td><td>等于 大于 小于</td></tr><tr><td>BETWEEN … AND …</td><td>Number is within range of two values (inclusive)</td><td>col BETWEEN 1.5 AND 10.5</td><td>在 X 和 X之间</td></tr><tr><td>NOT BETWEEN … AND …</td><td>Number is not within range of two values (inclusive)</td><td>co NOT BETWEEN 1 AND10</td><td>不在 X 和 X之间</td></tr><tr><td>IN (…)</td><td>Number exists in a list</td><td>col IN (2, 4, 6)</td><td>在 X 集合</td></tr><tr><td>NOT IN (…)</td><td>Number does not exist in a list</td><td>col NOT IN (1, 3, 5)</td><td>不在 X 集合</td></tr></tbody></table><h3 id="条件：文本-where"><a href="#条件：文本-where" class="headerlink" title="条件：文本(where)"></a>条件：文本(where)</h3><pre><code>当查找条件col是文本</code></pre><p><code>select * from table where col like &#39;%jin&#39;</code>;</p><table><thead><tr><th>Operator</th><th>Condition</th><th>SQL Example</th><th>解释</th></tr></thead><tbody><tr><td>=</td><td>Case sensitive exact string comparison (notice the single equals)</td><td>col = “abc”</td><td>等于</td></tr><tr><td>!= or &lt;&gt;</td><td>Case sensitive exact string inequality comparison</td><td>col != “abcd”</td><td>不等于</td></tr><tr><td>LIKE</td><td>Case insensitive exact string comparison</td><td>col LIKE “ABC”</td><td>等于</td></tr><tr><td>NOT LIKE</td><td>Case insensitive exact string inequality comparison</td><td>col NOT LIKE “ABCD”</td><td>不等于</td></tr><tr><td>%</td><td>Used anywhere in a string to match a sequence of zero or more characters (only with LIKE or NOT LIKE)</td><td>col LIKE “%AT%” (matches “AT”, “ATTIC”, “CAT” or even “BATS”)</td><td>模糊匹配</td></tr><tr><td>_</td><td>Used anywhere in a string to match a single character (only with LIKE or NOT LIKE)</td><td>col LIKE “AN_” (matches “AND”, but not “AN”)</td><td>模糊匹配单字符</td></tr><tr><td>IN (…)</td><td>String exists in a list</td><td>col IN (“A”, “B”, “C”)</td><td>在集合</td></tr><tr><td>NOT IN (…)</td><td>String does not exist in a list</td><td>co NOT IN (“D”, “E”, “F”)</td><td>不在集合</td></tr></tbody></table><h3 id="排序-rows"><a href="#排序-rows" class="headerlink" title="排序(rows)"></a>排序(rows)</h3><pre><code>需要对结果rows排序和筛选部分rowsselect * from table where col &gt; 1 order by col asc limit 2 offset 2</code></pre><table><thead><tr><th>Operator</th><th>Condition</th><th>SQL Example</th><th>解释</th></tr></thead><tbody><tr><td>ORDER BY</td><td>.</td><td>ORDER BY col ASC/DESC</td><td>按col排序</td></tr><tr><td>ASC</td><td>.</td><td>ORDER BY col ASC/DESC</td><td>升序</td></tr><tr><td>DESC</td><td>.</td><td>ORDER BY col ASC/DESC</td><td>降序</td></tr><tr><td>LIMIT OFFSET</td><td>.</td><td>LIMIT num_limit OFFSET num_offset</td><td>从offset取limit</td></tr><tr><td>ORDER BY</td><td>.</td><td>ORDER BY col1 ASC,col2 DESC</td><td>多列排序</td></tr></tbody></table><h3 id="join-连表-table"><a href="#join-连表-table" class="headerlink" title="join:连表(table)"></a>join:连表(table)</h3><pre><code>当查找的数据在多张关联table里select * from table1 left join table2 on table1.id = table2.id where col &gt; 1</code></pre><table><thead><tr><th>Operator</th><th>Condition</th><th>SQL Example</th><th>解释</th></tr></thead><tbody><tr><td>JOIN .. ON ..</td><td>.</td><td>t1 JOIN t2 ON t1.id = t2.id</td><td>按ID连成1个表</td></tr><tr><td>INNER JOIN</td><td>.</td><td>t1 INNER JOIN t2 ON t1.id = t2.id</td><td>只保留id相等的row</td></tr><tr><td>LEFT JOIN</td><td>.</td><td>t1 LEFT JOIN t2 ON t1.id = t2.id</td><td>保留t1的所有row</td></tr><tr><td>RIGHT JOIN</td><td>.</td><td>t1 RIGHT JOIN t2 ON t1.id = t2.id</td><td>保留t2的所有row</td></tr><tr><td>IS/IS NOT NULL</td><td>.</td><td>col IS/IS NOT NULL</td><td>col是不是为null</td></tr></tbody></table><h3 id="算式-select-where"><a href="#算式-select-where" class="headerlink" title="算式(select / where)"></a>算式(select / where)</h3><pre><code>当需要对select的col 或 where条件的col 经过一定计算后才能使用select *,col*2 from table where col/2 &gt; 1</code></pre><table><thead><tr><th>Operator</th><th>Condition</th><th>SQL Example</th><th>解释</th></tr></thead><tbody><tr><td>+ - * / %</td><td>.</td><td>col1 + col2</td><td>col加减乘除</td></tr><tr><td>substr</td><td>.</td><td>substr(col,0,4)</td><td>字符串截取</td></tr><tr><td>AS</td><td>.</td><td>col * 2 AS col_new</td><td>col取别名</td></tr><tr><td>…</td><td></td><td></td><td>还有很多</td></tr></tbody></table><h3 id="统计（select）"><a href="#统计（select）" class="headerlink" title="统计（select）"></a>统计（select）</h3><pre><code>对查找的rows需要按col分组统计的情况select count(*),avg(col),col from table where col &gt; 1 group by col</code></pre><table><thead><tr><th>Operator</th><th>Condition</th><th>SQL Example</th><th>解释</th></tr></thead><tbody><tr><td>COUNT(*), COUNT(column)</td><td>A common function used to counts the number of rows in the group if no column name is specified. Otherwise, count the number of rows in the group with non-NULL values in the specified column.</td><td>count(col)</td><td>计数</td></tr><tr><td>MIN(column)</td><td>Finds the smallest numerical value in the specified column for all rows in the group.</td><td>min(col)</td><td>最小</td></tr><tr><td>MAX(column)</td><td>Finds the largest numerical value in the specified column for all rows in the group.</td><td>max(col)</td><td>最大</td></tr><tr><td>AVG(column)</td><td>Finds the average numerical value in the specified column for all rows in the group.</td><td>avg(col)</td><td>平均</td></tr><tr><td>SUM(column)</td><td>Finds the sum of all numerical values in the specified column for the rows in the group.</td><td>sum(col)</td><td>求和</td></tr><tr><td>GROUP BY</td><td>.</td><td>group by col,col2</td><td>分组</td></tr><tr><td>HAVING</td><td>.</td><td>HAVING col&gt;100</td><td>分组后条件</td></tr></tbody></table><h3 id="子表-table"><a href="#子表-table" class="headerlink" title="子表 (table)"></a>子表 (table)</h3><pre><code>一次select的结果rows作为下一次select的临时table才能得到最终结果select * from (select * from table where col &gt; 1) as tmp where col &lt; 1</code></pre><table><thead><tr><th>Operator</th><th>Condition</th><th>SQL Example</th><th>解释</th></tr></thead><tbody><tr><td>（select -）as tmp</td><td></td><td>（select -）as tmp</td><td>select结果做子表</td></tr><tr><td>in（select -）</td><td></td><td>in（select -）</td><td>select结果做条件</td></tr><tr><td>avg（select -）</td><td></td><td>avg（select -）</td><td>select结果做条件</td></tr></tbody></table><h1 id="增"><a href="#增" class="headerlink" title="增"></a>增</h1><h2 id="创建和操纵表"><a href="#创建和操纵表" class="headerlink" title="创建和操纵表"></a>创建和操纵表</h2><h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><h4 id="创建表-1"><a href="#创建表-1" class="headerlink" title="创建表"></a>创建表</h4><p>你可以使用 CREATE TABLE 语句。这个语句定义了表的结构，包括列名、数据类型和约束等信息 </p><pre><code>CREATE TABLE 表名 (    列名1 数据类型1 约束,    列名2 数据类型2 约束,    列名3 数据类型3 约束,    ...);</code></pre><h4 id="使用null值"><a href="#使用null值" class="headerlink" title="使用null值"></a>使用null值</h4><blockquote><p>理解NULL 不要把NULL值与空串相混淆。NULL值是没有值，它不是空串。如果指定’’（两个单引号，其间没有字符），这在NOT NULL列中是允许的。空串是一个有效的值，它不是无值。NULL值用关键字NULL而不是空串指定</p></blockquote><h4 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h4><blockquote><p>主键和NULL值 第1章介绍过，主键为其值唯一标识表中每个行的列。主键中只能使用不允许NULL值的列。允许NULL值的列不能作为唯一标识。</p></blockquote><h4 id="AUTO-INCREMENT"><a href="#AUTO-INCREMENT" class="headerlink" title="AUTO_INCREMENT"></a>AUTO_INCREMENT</h4><blockquote><p> 一个列属性，用于自动分配唯一的递增值给该列， 常用于为表的主键列分配唯一标识符 </p></blockquote><p>1.定义 AUTO_INCREMENT：可以在创建表时或者修改表结构时，为某个列指定 AUTO_INCREMENT 属性。一般情况下，这个列通常作为表的主键列。 </p><pre><code>CREATE TABLE 表名 (    列1 数据类型 AUTO_INCREMENT,    ...    PRIMARY KEY (列1));</code></pre><ol start="2"><li><p>获取 AUTO_INCREMENT 值：插入数据后，你可以使用 <code>LAST_INSERT_ID()</code> 函数来获取最后插入的 AUTO_INCREMENT 值。</p><pre><code>INSERT INTO 表名 (列1, 列2) VALUES (&#39;value1&#39;, &#39;value2&#39;);SELECT LAST_INSERT_ID();</code></pre></li><li><p>自定义起始值和步长：使用 <code>AUTO_INCREMENT = value</code> 语句可以设置 AUTO_INCREMENT 列的起始值，并且可以使用 <code>AUTO_INCREMENT = value, INCREMENT BY value</code> 语句设置步长 </p><pre><code>ALTER TABLE 表名 AUTO_INCREMENT = 100;ALTER TABLE 表名 AUTO_INCREMENT = 100, INCREMENT BY 5;</code></pre></li></ol><h3 id="更新表之alter、drop"><a href="#更新表之alter、drop" class="headerlink" title="更新表之alter、drop"></a>更新表之alter、drop</h3><h4 id="修改表名"><a href="#修改表名" class="headerlink" title="修改表名"></a>修改表名</h4><pre><code>ALTER TABLE 旧表名 RENAME TO 新表名;</code></pre><h4 id="修改列字段名"><a href="#修改列字段名" class="headerlink" title="修改列字段名"></a>修改列字段名</h4><pre><code>ALTER TABLE 表名 CHANGE 旧列名 新列名 数据类型;</code></pre><h4 id="增加列字段"><a href="#增加列字段" class="headerlink" title="增加列字段"></a>增加列字段</h4><pre><code>ALTER TABLE 表名 ADD COLUMN 列名 数据类型;</code></pre><h4 id="删除列字段"><a href="#删除列字段" class="headerlink" title="删除列字段"></a>删除列字段</h4><pre><code>ALTER TABLE 表名 DROP COLUMN 列名;</code></pre><h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h3><pre><code>DROP TABLE 表名;</code></pre><h3 id="重命名表"><a href="#重命名表" class="headerlink" title="重命名表"></a>重命名表</h3><pre><code>ALTER TABLE 旧表名 RENAME TO 新表名;</code></pre><h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p>要在 MySQL 中插入数据，可以使用 INSERT INTO 语句。以下是插入数据的基本语法： </p><pre><code>INSERT INTO 表名 (列1, 列2, 列3, ...) VALUES (值1, 值2, 值3, ...);</code></pre><h4 id="插入多个行"><a href="#插入多个行" class="headerlink" title="插入多个行"></a>插入多个行</h4><p>  MySQL 中插入多个行数据，可以使用 INSERT INTO 语句，并以 VALUES 子句指定多个值集。每个值集表示一行数据，用括号包围并用逗号分隔。以下是插入多个行数据的基本语法： </p><pre><code>INSERT INTO 表名 (列1, 列2, 列3, ...)VALUES    (值1, 值2, 值3, ...),    (值4, 值5, 值6, ...),    (值7, 值8, 值9, ...);</code></pre><p>使用 INSERT INTO … SELECT 语句：可以通过 SELECT 查询语句获取多行数据，并将其插入到目标表中。例如：</p><pre><code>INSERT INTO mytable (column1, column2, column3)SELECT column1, column2, column3FROM othertableWHERE condition;</code></pre><h4 id="提高insert性能"><a href="#提高insert性能" class="headerlink" title="提高insert性能"></a>提高insert性能</h4><p>MySQL用单条INSERT语句处理多个插入比使用多条INSERT 语句快</p><p>使用这些方法，可以减少与数据库之间的通信次数，从而提高插入操作的性能。此外，考虑到性能，还可以考虑以下因素：</p><ul><li>批量提交（Batch Commit）：将多条 INSERT 语句或多个值集合并在一个事务中，然后一次性提交。这样可以减少事务处理的开销，提高插入性能。</li><li>索引管理：在大批量插入数据之前，暂时禁用索引、触发器等约束，插入完成后再重新启用。这避免了每次插入都触发索引维护，提高了插入性能。</li></ul><h1 id="删"><a href="#删" class="headerlink" title="删"></a>删</h1><h2 id="更新和删除数据"><a href="#更新和删除数据" class="headerlink" title="更新和删除数据"></a>更新和删除数据</h2><h3 id="更新数据之update"><a href="#更新数据之update" class="headerlink" title="更新数据之update"></a>更新数据之update</h3><pre><code>UPDATE 表名SET 列1 = 值1, 列2 = 值2, ...WHERE 条件;</code></pre><h3 id="删除数据之drop、delete、truncate"><a href="#删除数据之drop、delete、truncate" class="headerlink" title="删除数据之drop、delete、truncate"></a>删除数据之drop、delete、truncate</h3><p> 在 MySQL 中，可以使用 DROP 语句来删除数据库、表或索引。请注意，<strong>DROP 操作是不可逆的</strong>，并且会永久删除目标对象及其关联的数据。  执行 DROP 语句之前请务必备份重要的数据，以防止数据丢失。 </p><h4 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h4><pre><code>DROP DATABASE 数据库名;</code></pre><h4 id="删除表-1"><a href="#删除表-1" class="headerlink" title="删除表"></a>删除表</h4><pre><code>DROP TABLE 表名;</code></pre><h4 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h4><pre><code>ALTER TABLE 表名DROP INDEX 索引名;</code></pre><h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><p>DELETE 语句删除表中的数据。DELETE 语句用于从表中删除满足指定条件的行。以下是 DELETE 命令的基本语法 </p><pre><code>DELETE FROM 表名WHERE 条件;</code></pre><blockquote><p> 需要注意的是，如果不提供 WHERE 子句，则 DELETE 语句将删除表中的所有行。因此，请确保在删除之前仔细检查并设置正确的条件，以防止意外删除数据。 </p></blockquote><p> 如果只是想清空表中的数据而不是删除表本身，可以使用 TRUNCATE TABLE 命令。TRUNCATE TABLE 语句将删除表中的所有数据，但保留表的结构。 </p><pre><code>TRUNCATE TABLE 表名;</code></pre><h3 id="更新和删除数据的指导原则"><a href="#更新和删除数据的指导原则" class="headerlink" title="更新和删除数据的指导原则"></a>更新和删除数据的指导原则</h3><p>下面是许多SQL程序员使用UPDATE或DELETE时所遵循的习惯。 </p><p>1除非确实打算更新和删除每一行，否则绝对不要使用不带WHERE子句的UPDATE或DELETE语句。 </p><p>2保证每个表都有主键（如果忘记这个内容，请参阅第15章），尽可能像WHERE子句那样使用它（可以指定各主键、多个值或值的范围）。 </p><p>3在对UPDATE或DELETE语句使用WHERE子句前，应该先用SELECT进行测试，保证它过滤的是正确的记录，以防编写的WHERE子句不正确。 </p><p>4 使用强制实施引用完整性的数据库，这样MySQL将不允许删除具有与其他表相关联的数据的行。</p><h1 id="查"><a href="#查" class="headerlink" title="查"></a>查</h1><h2 id="检索数据之select"><a href="#检索数据之select" class="headerlink" title="检索数据之select"></a>检索数据之select</h2><h3 id="SELECT-命令的基本语法："><a href="#SELECT-命令的基本语法：" class="headerlink" title="SELECT 命令的基本语法："></a>SELECT 命令的基本语法：</h3><p>在 MySQL 中，可以使用 SELECT 语句来检索数据。SELECT 语句用于从表中选择满足指定条件的数据行，并将其返回给用户</p><pre><code>SELECT 列1, 列2, ...FROM 表名WHERE 条件;</code></pre><h3 id="检索不同的行之distinct"><a href="#检索不同的行之distinct" class="headerlink" title="检索不同的行之distinct"></a>检索不同的行之distinct</h3><p> SELECT DISTINCT 用于从表中选择唯一的、不重复的行数据 </p><pre><code>SELECT DISTINCT 列1, 列2, ...FROM 表名WHERE 条件;</code></pre><h3 id="限制结果之limit"><a href="#限制结果之limit" class="headerlink" title="限制结果之limit"></a>限制结果之limit</h3><p> 要限制 SELECT 语句返回的结果行数，可以使用 LIMIT 子句。LIMIT 子句用于从检索到的数据中选择指定数量的行。以下是 LIMIT 子句的基本语法： </p><pre><code>SELECT 列1, 列2, ...FROM 表名WHERE 条件LIMIT 数量;</code></pre><blockquote><p> LIMIT 子句的完整语法是 LIMIT m, n，其中 m 表示起始行的偏移量，n 表示要返回的行数。通过指定起始行和行数，可以实现分页查询或者一次只返回一部分结果；limit m,n:表示从第m+1条开始，取n条数据</p><p> LIMIT 子句可以有两个参数，第一个参数表示要返回的起始行的偏移量，第二个参数表示要返回的行数。例如，LIMIT 5, 10 表示从第6行开始返回 10 行数据。 </p><p> 起始行的偏移量是从 0 开始计数的，而不是从 1 开始。因此，LIMIT 0, 10 将返回前 10 行数据。 </p></blockquote><h3 id="使用完全限定的表名"><a href="#使用完全限定的表名" class="headerlink" title="使用完全限定的表名"></a>使用完全限定的表名</h3><p> 使用完全限定的表名，可以在查询中指定表的完整名称，包括数据库名称和表名称。这在多个数据库或模式中存在同名表时非常有用。以下是在查询中使用完全限定表名的示例： </p><pre><code>SELECT 列1, 列2, ...FROM 数据库名.模式名.表名WHERE 条件LIMIT m, n;</code></pre><h2 id="排序检索数据之order-by"><a href="#排序检索数据之order-by" class="headerlink" title="排序检索数据之order by"></a>排序检索数据之order by</h2><h3 id="排序数据"><a href="#排序数据" class="headerlink" title="排序数据"></a>排序数据</h3><p> 对数据进行排序，可以使用 SQL 中的 <code>ORDER BY</code> 子句。<code>ORDER BY</code> 子句允许您根据一个或多个列对查询结果进行排序。以下是在 SQL 查询中使用 <code>ORDER BY</code> 子句的基本语法： </p><pre><code>SELECT 列1, 列2, ...FROM 表名ORDER BY 列名 [ASC|DESC];</code></pre><h3 id="按多个列排序"><a href="#按多个列排序" class="headerlink" title="按多个列排序"></a>按多个列排序</h3><p>要对多个列进行排序，您可以在 <code>ORDER BY</code> 子句中指定多个列名，并按照优先级从左到右进行排序。例如： </p><pre><code>SELECT 列1, 列2FROM 表名ORDER BY 列1 ASC, 列2 DESC;</code></pre><h3 id="指定排序方向"><a href="#指定排序方向" class="headerlink" title="指定排序方向"></a>指定排序方向</h3><p>数据排序不限于升序排序（从A到Z）。这只是默认的排序顺序，还可以使用ORDER BY子句以降序（从Z到A）顺序排序。为了进行降序排序，必须指定DESC关键字。</p><pre><code>SELECT 列1, 列2FROM 表名ORDER BY 列名 ASC; -- 按列名升序排序SELECT 列1, 列2FROM 表名ORDER BY 列名 DESC; -- 按列名降序排序</code></pre><blockquote><p><strong>区分大小写和排序顺序</strong> 在对文本性的数据进行排序时，A与 a相同吗？a位于B之前还是位于Z之后？这些问题不是理论问题，其答案取决于数据库如何设置。在字典（dictionary）排序顺序中，A被视为与a相同，这是MySQL （和大多数数据库管理系统）的默认行为。但是，许多数据库管理员能够在需要时改变这种行为（如果你的数据库包含大量外语字符，可能必须这样做）。 这里，关键的问题是，如果确实需要改变这种排序顺序，用简单的ORDER BY子句做不到。你必须请求数据库管理员的帮助。</p></blockquote><h2 id="过滤数据"><a href="#过滤数据" class="headerlink" title="过滤数据"></a>过滤数据</h2><h3 id="过滤数据之where"><a href="#过滤数据之where" class="headerlink" title="过滤数据之where"></a>过滤数据之where</h3><p> 在 SQL 查询中使用 <code>WHERE</code> 子句的基本语法： </p><pre><code>SELECT 列1, 列2, ...FROM 表名WHERE 条件;</code></pre><p> 可以根据需要使用比较运算符（如 <code>=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>&lt;&gt;</code> 等）和逻辑运算符（如 <code>AND</code>, <code>OR</code>, <code>NOT</code>）来构建更复杂的条件。 还有between from  null等</p><h3 id="数据过滤"><a href="#数据过滤" class="headerlink" title="数据过滤"></a>数据过滤</h3><h4 id="组合WHERE子句"><a href="#组合WHERE子句" class="headerlink" title="组合WHERE子句"></a>组合WHERE子句</h4><p> 使用逻辑运算符（例如 <code>AND</code>、<code>OR</code> 和 <code>NOT</code>）组合多个条件，以创建更复杂的 <code>WHERE</code> 子句。这些逻辑运算符允许您在查询中同时测试多个条件，并根据需要进行组合。 </p><ol><li><p>使用 <code>AND</code> 运算符组合条件：</p><pre><code>SELECT 列1, 列2, ...FROM 表名WHERE 条件1 AND 条件2;</code></pre></li><li><p>使用 <code>OR</code> 运算符组合条件 ：</p><pre><code>SELECT 列1, 列2, ...FROM 表名WHERE 条件1 OR 条件2;</code></pre></li><li><p>使用 <code>NOT</code> 运算符否定条件 ：</p><pre><code>SELECT 列1, 列2, ...FROM 表名WHERE NOT 条件;</code></pre></li><li><p>还可以使用括号 <code>( )</code> 来明确指定运算顺序并进一步组合条件。例如： </p><pre><code>SELECT 列1, 列2, ...FROM 表名WHERE (条件1 OR 条件2) AND 条件3;</code></pre></li></ol><h4 id="IN操作符"><a href="#IN操作符" class="headerlink" title="IN操作符"></a>IN操作符</h4><p><code>IN</code> 操作符用于指定一个条件，以便从多个可能的值中选择匹配的行。<code>IN</code> 操作符用于简化多个 <code>OR</code> 条件的写法。</p><p>以下是 <code>IN</code> 操作符的基本语法：</p><pre><code>SELECT 列1, 列2, ...FROM 表名WHERE 列名 IN (值1, 值2, ...);</code></pre><p> 还可以使用子查询作为 <code>IN</code> 操作符的值列表。例如： </p><pre><code>SELECT 列1, 列2, 列3FROM 表名WHERE 列1 IN (SELECT 列              FROM 表              WHERE 条件);</code></pre><h4 id="NOT操作符"><a href="#NOT操作符" class="headerlink" title="NOT操作符"></a>NOT操作符</h4><p><code>NOT</code> 操作符用于否定一个条件，即取条件的反义。它允许您排除不满足指定条件的行。</p><p>以下是 <code>NOT</code> 操作符的基本语法：</p><pre><code>SELECT 列1, 列2, ...FROM 表名WHERE NOT 条件;</code></pre><p> 还可以在 <code>NOT</code> 操作符后面使用其他逻辑运算符（如 <code>AND</code> 和 <code>OR</code>）来进一步组合条件。例如： </p><pre><code>SELECT 列1, 列2, ...FROM 表名WHERE NOT (条件1 AND 条件2);</code></pre><h3 id="通配符过滤"><a href="#通配符过滤" class="headerlink" title="通配符过滤"></a>通配符过滤</h3><h4 id="LIKE操作符"><a href="#LIKE操作符" class="headerlink" title="LIKE操作符"></a>LIKE操作符</h4><p><code>LIKE</code> 操作符用于比较字符串列与模式之间的匹配。它通常与通配符一起使用来进行模糊匹配。</p><p>以下是 <code>LIKE</code> 操作符的基本语法：</p><pre><code>SELECT 列1, 列2, ...FROM 表名WHERE 列名 LIKE 模式;</code></pre><blockquote><p><code>LIKE</code> 操作符支持两种通配符：</p><ul><li><code>%</code>：表示匹配任意字符序列（包括空字符序列）。</li><li><code>_</code>：表示匹配任意单个字符。</li></ul></blockquote><h4 id="使用通配符的技巧"><a href="#使用通配符的技巧" class="headerlink" title="使用通配符的技巧"></a>使用通配符的技巧</h4><p>正如所见，MySQL的通配符很有用。但这种功能是有代价的：通配符搜索的处理一般要比前面讨论的其他搜索所花时间更长。这里给出一些使用通配符要记住的技巧。 </p><p>1不要过度使用通配符。如果其他操作符能达到相同的目的，应该使用其他操作符。 </p><p>2 在确实需要使用通配符时，除非绝对有必要，否则不要把它们用在搜索模式的开始处。把通配符置于搜索模式的开始处，搜索起来是最慢的。 </p><p>3仔细注意通配符的位置。如果放错地方，可能不会返回想要的数据。</p><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><h4 id="什么是正则表达式"><a href="#什么是正则表达式" class="headerlink" title="什么是正则表达式"></a>什么是正则表达式</h4><p> 正则表达式（Regular Expression），简称为正则或Regex，是一种用于描述字符串模式的工具。它是一种强大而灵活的文本处理工具，常用于文本匹配、搜索和替换。 </p><p> 正则表达式的使用广泛，几乎所有编程语言都支持正则表达式的操作。它在文本处理、数据验证、数据清理等领域都有很多应用。 </p><p> 以下是一些正则表达式的常见特性和用途： </p><blockquote><ol><li>字符匹配：可以使用普通字符来匹配与之相等的字符。例如，正则表达式 <code>abc</code> 可以匹配字符串中连续的 “abc”。</li><li>字符类（Character classes）：可以使用字符类来匹配一组字符中的任意一个。例如，<code>[abc]</code> 可以匹配字符 “a”、”b” 或 “c”。</li><li>量词（Quantifiers）：可以使用量词来指定前面的字符或字符类重复出现的次数。例如，<code>a{3}</code> 可以匹配连续的三个 “a”。</li><li>转义字符（Escape characters）：可以使用反斜杠 <code>\</code> 来转义特殊字符，使其具有普通字符的含义。例如，<code>\.</code> 可以匹配实际的句点字符 “.”。</li><li>边界匹配（Anchors）：可以使用边界匹配符号来指定字符串的开头和结尾。例如，<code>^abc</code> 匹配以 “abc” 开头的字符串。</li><li>分组和捕获（Grouping and capturing）：可以使用括号来分组正则表达式，并将分组作为单个单元进行处理和捕获结果。</li><li>替换操作：可以使用正则表达式来搜索和替换字符串中与模式匹配的部分。</li></ol></blockquote><p>注意！！！！！！ 正则表达式的语法和特性会因具体的编程语言和工具而有所差异，因此在实际使用时，请参考相关的文档或教程以了解具体的用法和语法规则 </p><h4 id="基本字符匹配regexp"><a href="#基本字符匹配regexp" class="headerlink" title="基本字符匹配regexp"></a>基本字符匹配regexp</h4><p> REGEXP 运算符：REGEXP 运算符用于在 WHERE 子句中进行正则表达式匹配。</p><pre><code>SELECT * FROM table_name WHERE column_name REGEXP &#39;pattern&#39;; -- 使用正则表达式匹配</code></pre><p> LOCATE 函数：LOCATE 函数用于查找一个子字符串在目标字符串中的位置。 </p><pre><code>SELECT LOCATE(&#39;sub_string&#39;, &#39;string_value&#39;); -- 查找 &#39;sub_string&#39; 在 &#39;string_value&#39; 中的位置</code></pre><p>LIKE 运算符使用通配符进行模式匹配，而不是正则表达式。它支持通配符 <code>%</code> 和 <code>_</code>。</p><ul><li><p><code>%</code> 通配符：表示匹配任意字符（包括空字符）的序列，可以出现零次或多次。</p></li><li><p><code>_</code> 通配符：表示匹配任意单个字符。</p></li><li><pre><code>SELECT * FROM table_name WHERE column_name LIKE &#39;abc%&#39;; -- 匹配以 &quot;abc&quot; 开头的字符串SELECT * FROM table_name WHERE column_name LIKE &#39;%xyz&#39;; -- 匹配以 &quot;xyz&quot; 结尾的字符串SELECT * FROM table_name WHERE column_name LIKE &#39;%def%&#39;; -- 匹配包含 &quot;def&quot; 的字符串SELECT * FROM table_name WHERE column_name LIKE &#39;a_c&#39;; -- 匹配第一个字符为 &quot;a&quot;，第三个字符为 &quot;c&quot; 的字符串</code></pre></li></ul><p>使用 LIKE 运算符进行模式匹配时，不需要使用特殊的转义字符。</p><blockquote><p>LIKE与REGEXP 在LIKE和REGEXP之间有一个重要的差别</p><p> LIKE 只支持简单的通配符模式匹配，而 REGEXP 支持更复杂的正则表达式模式匹配。 </p><p>，LIKE匹配整个列。如果被匹配的文本在列值 中出现，LIKE将不会找到它，相应的行也不被返回（除非使用 通配符）。而REGEXP在列值内进行匹配，如果被匹配的文本在 列值中出现，REGEXP将会找到它，相应的行将被返回。这是一个非常重要的差别</p></blockquote><h4 id="进行OR匹配"><a href="#进行OR匹配" class="headerlink" title="进行OR匹配"></a>进行OR匹配</h4><p>为搜索两个串之一（或者为这个串，或者为另一个串），使用|，如下所示：</p><pre><code>SELECT * FROM table_name WHERE column_name REGEXP &#39;pattern1|pattern2&#39;;</code></pre><p>使用|从功能上类似于在SELECT语句中使用OR语句，多个OR条件可并入单个正则表达式。</p><blockquote><p>两个以上的OR条件 可以给出两个以上的OR条件。例如，’1000 | 2000 | 3000’将匹配1000或2000或3000。</p></blockquote><h4 id="匹配几个字符之一"><a href="#匹配几个字符之一" class="headerlink" title="匹配几个字符之一"></a>匹配几个字符之一</h4><p>要在正则表达式中匹配几个字符之一，可以使用字符类（Character Class）来实现。字符类用方括号 <code>[]</code> 包围需要匹配的字符，表示匹配其中任意一个字符。</p><p>以下是基本的用法示例：</p><pre><code>SELECT * FROM table_name WHERE column_name REGEXP &#39;[abc]&#39;;</code></pre><p> 还可以通过使用连字符 <code>-</code> 来指定一个字符范围。例如： </p><pre><code>SELECT * FROM table_name WHERE column_name REGEXP &#39;[0-9]&#39;;</code></pre><h4 id="匹配范围"><a href="#匹配范围" class="headerlink" title="匹配范围"></a>匹配范围</h4><p> 要匹配一个字符的范围，你可以在正则表达式中使用连字符 <code>-</code> 来表示范围 以下是一些示例：</p><ul><li><code>[a-z]</code>：匹配任何小写字母。</li><li><code>[A-Z]</code>：匹配任何大写字母。</li><li><code>[0-9]</code>：匹配任何数字字符。</li><li><code>[a-zA-Z]</code>：匹配任何字母（大写或小写）。</li><li><code>[a-zA-Z0-9]</code>：匹配任何字母或数字字符。</li></ul><p>你也可以结合多个范围来创建更复杂的匹配规则。例如，如果你想要匹配一个介于 1 到 5 之间的数字，你可以使用 <code>[1-5]</code>。</p><p>以下是一个示例查询，在名为 <code>table_name</code> 的表中查找列 <code>column_name</code> 包含的值是否匹配指定的范围：</p><pre><code>SELECT * FROM table_name WHERE column_name REGEXP &#39;[1-5]&#39;;</code></pre><h4 id="匹配特殊字符"><a href="#匹配特殊字符" class="headerlink" title="匹配特殊字符"></a>匹配特殊字符</h4><p>要在正则表达式中匹配特殊字符，你需要使用反斜杠 <code>\</code> 进行转义。因为一些字符在正则表达式中有特殊的含义，所以需要用反斜杠来转义它们，以表示字面意义。</p><p>以下是一些常见的特殊字符及其转义形式：</p><ul><li><code>.</code>：匹配除换行符外的任意字符，要匹配实际的点号，可以使用 <code>\.</code>。</li><li><code>*</code>：匹配前面的字符零次或多次，要匹配实际的星号，可以使用 <code>\*</code>。</li><li><code>+</code>：匹配前面的字符一次或多次，要匹配实际的加号，可以使用 <code>\+</code>。</li><li><code>?</code>：匹配前面的字符零次或一次，要匹配实际的问号，可以使用 <code>\?</code>。</li><li><code>[</code> 和 <code>]</code>：用于定义字符类，要匹配实际的方括号，可以使用 <code>\[</code> 和 <code>\]</code>。</li><li><code>{</code> 和 <code>}</code>：用于指定重复次数，要匹配实际的花括号，可以使用 <code>\{</code> 和 <code>\}</code>。</li><li><code>(</code> 和 <code>)</code>：用于分组，要匹配实际的圆括号，可以使用 <code>\(</code> 和 <code>\)</code>。</li></ul><p>例如，如果你想要匹配一个字符串中的点号和星号，可以使用以下正则表达式：</p><pre><code>SELECT * FROM table_name WHERE column_name REGEXP &#39;[.*]&#39;;</code></pre><blockquote><p> 注意，在不同的上下文中，特殊字符的转义方式可能会有所不同，所以要根据具体情况使用适当的转义形式。 </p></blockquote><h4 id="匹配字符类"><a href="#匹配字符类" class="headerlink" title="匹配字符类"></a>匹配字符类</h4><p>在正则表达式中，字符类（Character Class）用于匹配一组特定的字符。你可以使用方括号 <code>[]</code> 来定义一个字符类，并在其中列出你想要匹配的字符。</p><p>以下是一些字符类的示例：</p><ul><li><code>[abc]</code>：匹配字符 ‘a’、’b’ 或 ‘c’ 中的任意一个。</li><li><code>[aeiou]</code>：匹配任何一个元音字母（’a’、’e’、’i’、’o’、’u’）。</li><li><code>[0-9]</code>：匹配任何一个数字字符。</li><li><code>[A-Za-z]</code>：匹配任何一个字母（大写或小写）。</li></ul><p>你还可以在字符类中结合使用连字符 <code>-</code> 来指定一个字符范围。例如，<code>[a-z]</code> 表示匹配任何一个小写字母。</p><p>以下是一个示例查询，在名为 <code>table_name</code> 的表中查找列 <code>column_name</code> 包含的值是否匹配指定的字符类：</p><pre><code>SELECT * FROM table_name WHERE column_name REGEXP &#39;[aeiou]&#39;;</code></pre><h4 id="匹配多个实例"><a href="#匹配多个实例" class="headerlink" title="匹配多个实例"></a>匹配多个实例</h4><p>如果你想要匹配多个实例（即重复出现）的特定模式，你可以使用量词（Quantifier）来指定重复的次数。</p><p>以下是一些常用的量词：</p><ul><li><code>*</code>：匹配前面的模式零次或多次。</li><li><code>+</code>：匹配前面的模式一次或多次。</li><li><code>?</code>：匹配前面的模式零次或一次。</li><li><code>{n}</code>：精确匹配前面的模式出现 n 次。</li><li><code>{n,}</code>：匹配前面的模式至少出现 n 次。</li><li><code>{n,m}</code>：匹配前面的模式出现 n 到 m 次。</li></ul><p>例如，如果你想要匹配一个字符串中的连续数字（至少一位数字），可以使用以下正则表达式：</p><pre><code>SELECT * FROM table_name WHERE column_name REGEXP &#39;[0-9]+&#39;;</code></pre><h4 id="定位符"><a href="#定位符" class="headerlink" title="定位符"></a>定位符</h4><p>在正则表达式中，定位符（Anchors）用于指定模式的位置，而不是字符本身。它们帮助我们匹配字符串的特定位置。</p><p>以下是一些常用的定位符：</p><ul><li><code>^</code>：匹配字符串的开头。例如，<code>^abc</code> 可以匹配以 “abc” 开头的字符串。</li><li><code>$</code>：匹配字符串的结尾。例如，<code>xyz$</code> 可以匹配以 “xyz” 结尾的字符串。</li><li><code>\b</code>：匹配单词的边界。例如，<code>\bword\b</code> 可以匹配独立的单词 “word”，而不会匹配包含它的单词。</li><li><code>\B</code>：匹配非单词的边界。例如，<code>\Bing\B</code> 可以匹配字符串中不是单独单词的 “ing”。</li></ul><p>以下是一个示例查询，在名为 <code>table_name</code> 的表中查找列 <code>column_name</code> 中以 “abc” 结尾的值：</p><pre><code>SELECT * FROM table_name WHERE column_name REGEXP &#39;abc$&#39;;</code></pre><h2 id="汇总数据"><a href="#汇总数据" class="headerlink" title="汇总数据"></a>汇总数据</h2><h3 id="聚集函数"><a href="#聚集函数" class="headerlink" title="聚集函数"></a>聚集函数</h3><p>聚集函数（Aggregate Functions）是用于对数据库表中的数据进行聚合计算的函数。它们将多个行的值汇总为单个结果，并返回计算后的结果。</p><p>以下是一些常见的聚集函数：</p><ul><li><code>COUNT()</code>：用于计算指定列中的行数，可以使用 <code>COUNT(*)</code> 计算所有行的数目。</li><li><code>SUM()</code>：用于计算指定列中数值类型的总和。</li><li><code>AVG()</code>：用于计算指定列中数值类型的平均值。</li><li><code>MIN()</code>：用于找到指定列中的最小值。</li><li><code>MAX()</code>：用于找到指定列中的最大值。</li></ul><p>这些聚集函数可以与 SQL 查询语句中的 <code>SELECT</code> 和 <code>GROUP BY</code> 子句一起使用，以便根据特定条件对数据进行聚合计算。</p><p>以下是一个示例查询，使用 <code>SUM()</code> 函数计算名为 <code>sales</code> 的表中的销售总额：</p><pre><code>SELECT SUM(amount) as total_sales FROM sales;</code></pre><h3 id="聚集不同值"><a href="#聚集不同值" class="headerlink" title="聚集不同值"></a>聚集不同值</h3><p>想对数据库表中的某一列进行聚集并计算其不同值的数量，你可以使用 <code>COUNT(DISTINCT)</code> 函数。<code>COUNT(DISTINCT)</code> 函数用于计算指定列中不重复值的数量。</p><p>以下是一个示例查询，使用 <code>COUNT(DISTINCT)</code> 函数计算名为 <code>products</code> 的表中不同产品的数量：</p><pre><code>SELECT COUNT(DISTINCT product_name) as distinct_products FROM products;</code></pre><h3 id="组合聚集函数"><a href="#组合聚集函数" class="headerlink" title="组合聚集函数"></a>组合聚集函数</h3><p>组合多个聚合函数来按照不同的方式对数据进行计算和汇总。这样可以得到更详细和灵活的结果。</p><p>以下是一些示例组合聚合函数的情况：</p><ol><li><p>计算销售表中不同产品的总销售额和平均销售额：</p><pre><code>SELECT product_name, SUM(amount) as total_sales, AVG(amount) as average_salesFROM salesGROUP BY product_name;</code></pre><p> 上述查询将根据产品名称分组，计算每个产品的总销售额和平均销售额。 </p></li><li><p>找到订单表中销售额最高和最低的产品：</p><pre><code>SELECT MAX(amount) as max_sales, MIN(amount) as min_salesFROM orders;</code></pre><p> 上述查询将计算订单表中的最高销售额和最低销售额。 </p></li><li><p>计算某一时间范围内销售表中不同产品的总销售额：</p><pre><code>SELECT product_name, SUM(amount) as total_salesFROM salesWHERE sale_date BETWEEN &#39;2023-01-01&#39; AND &#39;2023-12-31&#39;GROUP BY product_name;</code></pre><p> 上述查询将根据指定的时间范围内的销售数据，计算每个产品的总销售额。 </p></li></ol><blockquote><p><strong>取别名</strong> 在指定别名以包含某个聚集函数的结果时，不应该使 用表中实际的列名。虽然这样做并非不合法，但使用唯一的名字会使你的SQL更易于理解和使用（以及将来容易排除故障）。</p></blockquote><h2 id="分组数据"><a href="#分组数据" class="headerlink" title="分组数据"></a>分组数据</h2><h3 id="数据分组之group-by"><a href="#数据分组之group-by" class="headerlink" title="数据分组之group by"></a>数据分组之group by</h3><p>数据分组是在 SQL 查询中使用 <code>GROUP BY</code> 子句对数据进行分组的过程。通过数据分组，你可以根据一个或多个列的值将数据划分为不同的组，并对每个组应用聚合函数来计算汇总结果。</p><p>以下是一个基本的数据分组示例：</p><pre><code>SELECT column1, column2, aggregate_function(column3)FROM tableGROUP BY column1, column2;</code></pre><h3 id="过滤分组之having"><a href="#过滤分组之having" class="headerlink" title="过滤分组之having"></a>过滤分组之having</h3><blockquote><p>HAVING支持所有WHERE操作符</p></blockquote><p><code>HAVING</code> 子句用于在对数据进行分组后，对分组结果进行过滤。<code>HAVING</code> 子句中的条件是应用于聚合函数的结果。</p><p>以下是一些关于 <code>HAVING</code> 子句的使用示例：</p><ol><li><p>筛选出销售额总和大于 1000 的产品组：</p><pre><code>SELECT product_name, SUM(amount) as total_salesFROM salesGROUP BY product_nameHAVING total_sales &gt; 1000;</code></pre><p> 上述查询根据产品名称对销售数据进行分组，并计算每个组的销售额总和。<code>HAVING</code> 子句筛选出销售额总和大于 1000 的产品组。 </p></li><li><p>筛选出订单数量超过平均订单数的销售代表组：</p><pre><code>SELECT sales_rep, COUNT(order_id) as orders_countFROM ordersGROUP BY sales_repHAVING COUNT(order_id) &gt; (SELECT AVG(orders_count) FROM (SELECT COUNT(order_id) as orders_count FROM orders GROUP BY sales_rep) as subquery);</code></pre><p>上述查询根据销售代表对订单进行分组，并计算每个组的订单数量。<code>HAVING</code> 子句使用子查询来比较订单数量是否超过平均订单数。 </p></li></ol><blockquote><p> 请注意，<code>HAVING</code> 子句必须在 <code>GROUP BY</code> 子句之后使用，用于对分组后的结果进行过滤。如果需要对原始数据进行过滤，请使用 <code>WHERE</code> 子句。 </p></blockquote><h3 id="分组和排序"><a href="#分组和排序" class="headerlink" title="分组和排序"></a>分组和排序</h3><p>​                                                                    ORDER BY与GROUP BY的差别</p><table><thead><tr><th>ORDER BY</th><th>GROUP BY</th></tr></thead><tbody><tr><td>排序产生的输出</td><td>分组行。但输出可能不是分组的顺序</td></tr><tr><td>任意列都可以使用（甚至非选择的列也可以使用）</td><td>只可能使用选择列或表达式列，而且必须使用每个选择列表达式</td></tr><tr><td>不一定需要</td><td>如果与聚集函数一起使用列（或表达式），则必须使用</td></tr></tbody></table><h2 id="复杂查询"><a href="#复杂查询" class="headerlink" title="复杂查询"></a>复杂查询</h2><h3 id="使用子查询"><a href="#使用子查询" class="headerlink" title="使用子查询"></a>使用子查询</h3><h4 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h4><p>子查询是指在 SQL 查询中嵌套使用的内部查询。子查询在外部查询的条件、选择列表或其他子句中使用，允许我们从嵌套的查询中检索数据并将其用作外部查询的一部分 </p><p> 子查询可以用于以下几个方面： </p><ol><li><p>在 <code>WHERE</code> 子句中使用子查询进行过滤：</p><pre><code>SELECT column1, column2, ...FROM tableWHERE column1 IN (SELECT column1 FROM another_table WHERE condition);</code></pre><p> 上述查询中，子查询 <code>(SELECT column1 FROM another_table WHERE condition)</code> 用于选择满足特定条件的值，然后外部查询根据这些值对数据进行筛选 </p></li><li><p>在 <code>SELECT</code> 子句中使用子查询获取计算结果：</p><pre><code>SELECT column1, (SELECT COUNT(*) FROM another_table) AS total_rowsFROM table;</code></pre><p> 上述查询中，子查询 <code>(SELECT COUNT(*) FROM another_table)</code> 用于获取 <code>another_table</code> 中的行数，并将其作为别名为 <code>total_rows</code> 的计算结果返回到外部查询中。 </p></li><li><p>在 <code>FROM</code> 子句中使用子查询作为临时表：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> column1<span class="token punctuation">,</span> column2<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">FROM</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> column1<span class="token punctuation">,</span> column2 <span class="token keyword">FROM</span> table1 <span class="token keyword">UNION</span> <span class="token keyword">SELECT</span> column1<span class="token punctuation">,</span> column2 <span class="token keyword">FROM</span> table2<span class="token punctuation">)</span> <span class="token keyword">AS</span> temp_table<span class="token punctuation">;</span></code></pre><p> 上述查询中，子查询 <code>(SELECT column1, column2 FROM table1 UNION SELECT column1, column2 FROM table2)</code> 将两个表的数据组合起来，并将其作为临时表 <code>temp_table</code> 在外部查询中使用。 </p></li></ol><h4 id="利用子查询进行过滤"><a href="#利用子查询进行过滤" class="headerlink" title="利用子查询进行过滤"></a>利用子查询进行过滤</h4><p>利用子查询进行过滤是一种常见的使用场景，可以根据内部查询的结果来筛选外部查询的数据。下面是一些示例：</p><ol><li>使用子查询筛选符合条件的数据：</li></ol><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> column1<span class="token punctuation">,</span> column2<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">FROM</span> <span class="token keyword">table</span><span class="token keyword">WHERE</span> column1 <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> column1 <span class="token keyword">FROM</span> another_table <span class="token keyword">WHERE</span> condition<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>上述查询中，子查询 <code>(SELECT column1 FROM another_table WHERE condition)</code> 返回满足特定条件的值，并将这些值用于外部查询中的 <code>WHERE</code> 子句，以筛选表 <code>table</code> 的数据。</p><ol start="2"><li>使用子查询排除符合条件的数据：</li></ol><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> column1<span class="token punctuation">,</span> column2<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">FROM</span> <span class="token keyword">table</span><span class="token keyword">WHERE</span> column1 <span class="token operator">NOT</span> <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> column1 <span class="token keyword">FROM</span> another_table <span class="token keyword">WHERE</span> condition<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>上述查询中，子查询 <code>(SELECT column1 FROM another_table WHERE condition)</code> 返回满足特定条件的值，并将这些值用于外部查询中的 <code>WHERE</code> 子句的 <code>NOT IN</code> 条件，以排除表 <code>table</code> 中包含这些值的数据。</p><ol start="3"><li>使用子查询进行范围过滤：</li></ol><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> column1<span class="token punctuation">,</span> column2<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">FROM</span> <span class="token keyword">table</span><span class="token keyword">WHERE</span> column1 <span class="token operator">></span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token function">AVG</span><span class="token punctuation">(</span>column1<span class="token punctuation">)</span> <span class="token keyword">FROM</span> another_table<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>上述查询中，子查询 <code>(SELECT AVG(column1) FROM another_table)</code> 返回列 <code>column1</code> 的平均值，并将其用于外部查询中的 <code>WHERE</code> 子句，以筛选出表 <code>table</code> 中大于平均值的数据。</p><h4 id="使用子查询作为计算字段"><a href="#使用子查询作为计算字段" class="headerlink" title="使用子查询作为计算字段"></a>使用子查询作为计算字段</h4><p>使用子查询作为计算字段是一种常见的用法，可以在查询结果中包含根据子查询计算得到的额外信息。下面是一个示例：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> column1<span class="token punctuation">,</span> column2<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">FROM</span> another_table<span class="token punctuation">)</span> <span class="token keyword">AS</span> total_rows<span class="token keyword">FROM</span> <span class="token keyword">table</span><span class="token punctuation">;</span></code></pre><p>上述查询中，子查询 <code>(SELECT COUNT(*) FROM another_table)</code> 用于获取表 <code>another_table</code> 中的行数，并将其作为计算字段 <code>total_rows</code> 包含在查询结果中。这样，查询结果就会返回每一行数据的 <code>column1</code>、<code>column2</code> 字段值，以及额外的计算字段 <code>total_rows</code>。</p><blockquote><p>子查询作为计算字段必须只返回单个值。如果子查询返回了多个值，将会引发错误。</p></blockquote><h3 id="组合查询"><a href="#组合查询" class="headerlink" title="组合查询"></a>组合查询</h3><h4 id="组合查询-1"><a href="#组合查询-1" class="headerlink" title="组合查询"></a>组合查询</h4><p>多数SQL查询都只包含从一个或多个表中返回数据的单条SELECT语句。MySQL也允许执行多个查询（多条SELECT语句），并将结果作为单个查询结果集返回。这些组合查询通常称为并（union）或复合查询（compound query）。</p><h4 id="创建组合查询union"><a href="#创建组合查询union" class="headerlink" title="创建组合查询union"></a>创建组合查询union</h4><p>要创建组合查询，可以使用 UNION、INTERSECT 或 EXCEPT 运算符来合并多个查询的结果集。下面是一个示例：</p><ol><li>使用 UNION 运算符合并查询结果：</li></ol><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> column1<span class="token punctuation">,</span> column2 <span class="token keyword">FROM</span> table1<span class="token keyword">UNION</span><span class="token keyword">SELECT</span> column1<span class="token punctuation">,</span> column2 <span class="token keyword">FROM</span> table2<span class="token punctuation">;</span></code></pre><p>上述查询将从表 <code>table1</code> 和 <code>table2</code> 中选择 <code>column1</code> 和 <code>column2</code> 字段的结果，并将两个结果集合并在一起。如果有重复的行，将只返回一次。</p><ol start="2"><li>使用 INTERSECT 运算符获取查询结果的交集：</li></ol><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> column1<span class="token punctuation">,</span> column2 <span class="token keyword">FROM</span> table1<span class="token keyword">INTERSECT</span><span class="token keyword">SELECT</span> column1<span class="token punctuation">,</span> column2 <span class="token keyword">FROM</span> table2<span class="token punctuation">;</span></code></pre><p>上述查询将返回同时在表 <code>table1</code> 和 <code>table2</code> 中存在的行，且只包含 <code>column1</code> 和 <code>column2</code> 字段。</p><ol start="3"><li>使用 EXCEPT 运算符排除一个查询结果中存在的行：</li></ol><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> column1<span class="token punctuation">,</span> column2 <span class="token keyword">FROM</span> table1<span class="token keyword">EXCEPT</span><span class="token keyword">SELECT</span> column1<span class="token punctuation">,</span> column2 <span class="token keyword">FROM</span> table2<span class="token punctuation">;</span></code></pre><p>上述查询将从表 <code>table1</code> 中选择 <code>column1</code> 和 <code>column2</code> 字段的结果，排除在表 <code>table2</code> 中存在的行。</p><blockquote><p>注意，在使用这些运算符时，两个结果集的列数和列的数据类型必须相同。</p></blockquote><h4 id="UNION规则"><a href="#UNION规则" class="headerlink" title="UNION规则"></a>UNION规则</h4><p>当使用 UNION 运算符合并多个查询结果时，需要遵循以下规则：</p><ol><li><p>结果集的列数必须相同：所有查询语句中选择的列数必须一致。如果列数不匹配，则会导致错误。</p></li><li><p>列的数据类型必须兼容：相应位置上的列数据类型必须是兼容的，否则会导致错误。例如，数字列和字符串列不能直接相加，因此它们的数据类型不兼容。</p></li><li><p>结果集的列顺序必须一致：每个 SELECT 语句中选择的列的顺序必须相同，否则将导致结果集中的列顺序混乱。</p></li><li><p>去除重复行：UNION 运算符默认会去除结果集中的重复行。如果想保留重复行，可以使用 UNION ALL 运算符。</p></li></ol><p>示例：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> column1<span class="token punctuation">,</span> column2 <span class="token keyword">FROM</span> table1<span class="token keyword">UNION</span><span class="token keyword">SELECT</span> column1<span class="token punctuation">,</span> column2 <span class="token keyword">FROM</span> table2<span class="token punctuation">;</span></code></pre><p>上述查询将从表 <code>table1</code> 和 <code>table2</code> 中选择 <code>column1</code> 和 <code>column2</code> 字段的结果，合并为一个结果集，并去除重复行。</p><p>总之，使用 UNION 运算符时，要确保查询语句的列数、列的数据类型和列顺序都一致，以及根据需要决定是否去除重复行。</p><h4 id="包含或取消重复的行"><a href="#包含或取消重复的行" class="headerlink" title="包含或取消重复的行"></a>包含或取消重复的行</h4><p>要在组合查询中包含或取消重复的行，可以使用 UNION ALL 运算符或 DISTINCT 关键字。</p><ol><li>使用 UNION ALL 运算符：这个运算符会将所有查询的结果集合并在一起，并保留所有的行，包括重复的行。</li></ol><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> column1<span class="token punctuation">,</span> column2 <span class="token keyword">FROM</span> table1<span class="token keyword">UNION</span> <span class="token keyword">ALL</span><span class="token keyword">SELECT</span> column1<span class="token punctuation">,</span> column2 <span class="token keyword">FROM</span> table2<span class="token punctuation">;</span></code></pre><p>上述查询将从表 <code>table1</code> 和 <code>table2</code> 中选择 <code>column1</code> 和 <code>column2</code> 字段的结果，合并为一个结果集，并保留重复的行。</p><ol start="2"><li>使用 DISTINCT 关键字：这个关键字用于消除结果集中的重复行。</li></ol><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token keyword">DISTINCT</span> column1<span class="token punctuation">,</span> column2 <span class="token keyword">FROM</span> <span class="token keyword">table</span><span class="token punctuation">;</span></code></pre><p>上述查询将从表 <code>table</code> 中选择 <code>column1</code> 和 <code>column2</code> 字段的结果，并且只返回不重复的行。</p><blockquote><p>UNION ALL 可以更快地执行，因为它不涉及去重的操作。而使用 DISTINCT 会对结果进行去重处理，可能会导致一些性能开销。</p></blockquote><h4 id="对组合结果进行排序"><a href="#对组合结果进行排序" class="headerlink" title="对组合结果进行排序"></a>对组合结果进行排序</h4><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> column1<span class="token punctuation">,</span> column2 <span class="token keyword">FROM</span> table1<span class="token keyword">UNION</span><span class="token keyword">SELECT</span> column1<span class="token punctuation">,</span> column2 <span class="token keyword">FROM</span> table2<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> column1 <span class="token keyword">ASC</span><span class="token operator">/</span><span class="token keyword">DESC</span><span class="token punctuation">;</span></code></pre><h2 id="计算字段"><a href="#计算字段" class="headerlink" title="计算字段"></a>计算字段</h2><h3 id="创建字段"><a href="#创建字段" class="headerlink" title="创建字段"></a>创建字段</h3><h4 id="计算字段-1"><a href="#计算字段-1" class="headerlink" title="计算字段"></a>计算字段</h4><p>计算字段是在 SELECT 语句中使用表达式或函数来计算出的一个新字段。它不是数据库表中的实际列，而是在查询结果中动态生成的。以下是几个常见的计算字段示例：</p><ol><li>使用表达式计算字段：</li></ol><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> column1<span class="token punctuation">,</span> column2<span class="token punctuation">,</span> column3<span class="token punctuation">,</span> <span class="token punctuation">(</span>column1 <span class="token operator">+</span> column2<span class="token punctuation">)</span> <span class="token keyword">AS</span> sum <span class="token keyword">FROM</span> <span class="token keyword">table</span><span class="token punctuation">;</span></code></pre><p>上述查询中，<code>(column1 + column2)</code> 表达式计算出了一个名为 <code>sum</code> 的计算字段，表示 <code>column1</code> 和 <code>column2</code> 列的和。</p><ol start="2"><li>使用函数计算字段：</li></ol><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> column1<span class="token punctuation">,</span> column2<span class="token punctuation">,</span> column3<span class="token punctuation">,</span> UPPER<span class="token punctuation">(</span>column1<span class="token punctuation">)</span> <span class="token keyword">AS</span> uppercase <span class="token keyword">FROM</span> <span class="token keyword">table</span><span class="token punctuation">;</span></code></pre><p>上述查询中，<code>UPPER(column1)</code> 函数将 <code>column1</code> 列的值转换为大写，并创建了一个名为 <code>uppercase</code> 的计算字段。</p><ol start="3"><li>使用条件判断计算字段：</li></ol><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> column1<span class="token punctuation">,</span> column2<span class="token punctuation">,</span> column3<span class="token punctuation">,</span> <span class="token keyword">CASE</span> <span class="token keyword">WHEN</span> column1 <span class="token operator">></span> column2 <span class="token keyword">THEN</span> <span class="token string">'Greater'</span> <span class="token keyword">ELSE</span> <span class="token string">'Less or equal'</span> <span class="token keyword">END</span> <span class="token keyword">AS</span> comparison <span class="token keyword">FROM</span> <span class="token keyword">table</span><span class="token punctuation">;</span></code></pre><p>上述查询中，使用 CASE 表达式根据条件判断创建了一个名为 <code>comparison</code> 的计算字段，如果 <code>column1</code> 大于 <code>column2</code>，则为 ‘Greater’，否则为 ‘Less or equal’。</p><blockquote><p>使用计算字段时，你可以给该字段起一个别名（AS 别名），以便在结果中显示更友好的列名。</p></blockquote><h4 id="拼接字段"><a href="#拼接字段" class="headerlink" title="拼接字段"></a>拼接字段</h4><p>在查询中，可以使用 CONCAT 函数来拼接字段。 CONCAT 函数可以将多个字段或字符串连接在一起形成一个新的字符串。</p><p>以下是几个示例：</p><ol><li>拼接两个字段：</li></ol><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> column1<span class="token punctuation">,</span> column2<span class="token punctuation">,</span> CONCAT<span class="token punctuation">(</span>column1<span class="token punctuation">,</span> column2<span class="token punctuation">)</span> <span class="token keyword">AS</span> concatenated <span class="token keyword">FROM</span> <span class="token keyword">table</span><span class="token punctuation">;</span></code></pre><p>上述查询中，<code>CONCAT(column1, column2)</code> 将 <code>column1</code> 和 <code>column2</code> 的值拼接在一起，并创建一个名为 <code>concatenated</code> 的计算字段。</p><ol start="2"><li>拼接字段和字符串：</li></ol><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> column1<span class="token punctuation">,</span> column2<span class="token punctuation">,</span> CONCAT<span class="token punctuation">(</span>column1<span class="token punctuation">,</span> <span class="token string">' is the value of column1'</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> result <span class="token keyword">FROM</span> <span class="token keyword">table</span><span class="token punctuation">;</span></code></pre><p>上述查询中，<code>CONCAT(column1, &#39; is the value of column1&#39;)</code> 将 <code>column1</code> 的值和一个字符串拼接在一起，并创建一个名为 <code>result</code> 的计算字段。</p><ol start="3"><li>拼接多个字段和字符串：</li></ol><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> column1<span class="token punctuation">,</span> column2<span class="token punctuation">,</span> CONCAT<span class="token punctuation">(</span>column1<span class="token punctuation">,</span> <span class="token string">' - '</span><span class="token punctuation">,</span> column2<span class="token punctuation">,</span> <span class="token string">' - '</span><span class="token punctuation">,</span> column3<span class="token punctuation">)</span> <span class="token keyword">AS</span> combined <span class="token keyword">FROM</span> <span class="token keyword">table</span><span class="token punctuation">;</span></code></pre><p>上述查询中，<code>CONCAT(column1, &#39; - &#39;, column2, &#39; - &#39;, column3)</code> 将 <code>column1</code>、<code>column2</code> 和 <code>column3</code> 的值以及一些字符串连接在一起，并创建一个名为 <code>combined</code> 的计算字段。</p><h4 id="执行算术计算"><a href="#执行算术计算" class="headerlink" title="执行算术计算"></a>执行算术计算</h4><p>在 SQL 查询中，可以使用内置的数学函数来执行算术计算。下面是几个常用的数学函数示例：</p><ol><li>加法：</li></ol><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> column1<span class="token punctuation">,</span> column2<span class="token punctuation">,</span> <span class="token punctuation">(</span>column1 <span class="token operator">+</span> column2<span class="token punctuation">)</span> <span class="token keyword">AS</span> sum <span class="token keyword">FROM</span> <span class="token keyword">table</span><span class="token punctuation">;</span></code></pre><p>上述查询中，<code>(column1 + column2)</code> 执行了列 <code>column1</code> 和 <code>column2</code> 的加法操作，并创建了一个名为 <code>sum</code> 的计算字段。</p><ol start="2"><li>减法：</li></ol><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> column1<span class="token punctuation">,</span> column2<span class="token punctuation">,</span> <span class="token punctuation">(</span>column1 <span class="token operator">-</span> column2<span class="token punctuation">)</span> <span class="token keyword">AS</span> difference <span class="token keyword">FROM</span> <span class="token keyword">table</span><span class="token punctuation">;</span></code></pre><p>上述查询中，<code>(column1 - column2)</code> 执行了列 <code>column1</code> 减去 <code>column2</code> 的操作，并创建了一个名为 <code>difference</code> 的计算字段。</p><ol start="3"><li>乘法：</li></ol><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> column1<span class="token punctuation">,</span> column2<span class="token punctuation">,</span> <span class="token punctuation">(</span>column1 <span class="token operator">*</span> column2<span class="token punctuation">)</span> <span class="token keyword">AS</span> product <span class="token keyword">FROM</span> <span class="token keyword">table</span><span class="token punctuation">;</span></code></pre><p>上述查询中，<code>(column1 * column2)</code> 执行了列 <code>column1</code> 和 <code>column2</code> 的乘法操作，并创建了一个名为 <code>product</code> 的计算字段。</p><ol start="4"><li>除法：</li></ol><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> column1<span class="token punctuation">,</span> column2<span class="token punctuation">,</span> <span class="token punctuation">(</span>column1 <span class="token operator">/</span> column2<span class="token punctuation">)</span> <span class="token keyword">AS</span> quotient <span class="token keyword">FROM</span> <span class="token keyword">table</span><span class="token punctuation">;</span></code></pre><p>上述查询中，<code>(column1 / column2)</code> 执行了列 <code>column1</code> 除以 <code>column2</code> 的操作，并创建了一个名为 <code>quotient</code> 的计算字段。</p><h3 id="使用数据处理函数"><a href="#使用数据处理函数" class="headerlink" title="使用数据处理函数"></a>使用数据处理函数</h3><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>与其他大多数计算机语言一样，SQL支持利用函数来处理数据。函数一般是在数据上执行的，它给数据的转换和处理提供了方便。</p><h4 id="使用函数"><a href="#使用函数" class="headerlink" title="使用函数"></a>使用函数</h4><p>在 SQL 查询中，可以使用各种数据处理函数来处理数据。以下是几个常用的数据处理函数示例：</p><ol><li>字符串处理函数：</li></ol><ul><li>UPPER：将字符串转换为大写。</li><li>LOWER：将字符串转换为小写。</li><li>LENGTH：返回字符串的长度。</li><li>SUBSTRING：提取字符串的子串。</li></ul><p>例如：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> UPPER<span class="token punctuation">(</span><span class="token keyword">column</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> uppercase<span class="token punctuation">,</span> LOWER<span class="token punctuation">(</span><span class="token keyword">column</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> lowercase<span class="token punctuation">,</span> LENGTH<span class="token punctuation">(</span><span class="token keyword">column</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> length<span class="token punctuation">,</span> SUBSTRING<span class="token punctuation">(</span><span class="token keyword">column</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> substring <span class="token keyword">FROM</span> <span class="token keyword">table</span><span class="token punctuation">;</span></code></pre><ol start="2"><li>数值处理函数：</li></ol><ul><li>ROUND：将数值四舍五入到指定精度。</li><li>CEILING：将数值向上取整。</li><li>FLOOR：将数值向下取整。</li><li>ABS：返回数值的绝对值。</li></ul><p>例如：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token function">ROUND</span><span class="token punctuation">(</span><span class="token keyword">column</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> rounded<span class="token punctuation">,</span> CEILING<span class="token punctuation">(</span><span class="token keyword">column</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> ceiling<span class="token punctuation">,</span> FLOOR<span class="token punctuation">(</span><span class="token keyword">column</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> floor<span class="token punctuation">,</span> ABS<span class="token punctuation">(</span><span class="token keyword">column</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> absolute <span class="token keyword">FROM</span> <span class="token keyword">table</span><span class="token punctuation">;</span></code></pre><ol start="3"><li>日期和时间处理函数：</li></ol><ul><li>DATEPART：提取日期或时间部分（年、月、日、小时、分钟等）的值。</li><li>DATEADD：根据指定的日期或时间间隔添加或减去值。</li><li>DATEDIFF：计算两个日期之间的差异。</li></ul><p>例如：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> DATEPART<span class="token punctuation">(</span>year<span class="token punctuation">,</span> date_column<span class="token punctuation">)</span> <span class="token keyword">AS</span> year_part<span class="token punctuation">,</span> DATEADD<span class="token punctuation">(</span>month<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> date_column<span class="token punctuation">)</span> <span class="token keyword">AS</span> added_month<span class="token punctuation">,</span> DATEDIFF<span class="token punctuation">(</span>day<span class="token punctuation">,</span> date_column1<span class="token punctuation">,</span> date_column2<span class="token punctuation">)</span> <span class="token keyword">AS</span> day_difference <span class="token keyword">FROM</span> <span class="token keyword">table</span><span class="token punctuation">;</span></code></pre><h2 id="表联结"><a href="#表联结" class="headerlink" title="表联结"></a>表联结</h2><h3 id="联结"><a href="#联结" class="headerlink" title="联结"></a>联结</h3><p>SQL最强大的功能之一就是能在数据检索查询的执行中联结（join）表。联结是利用SQL的SELECT能执行的最重要的操作，很好地理解联结及其语法是学习SQL的一个极为重要的组成部分。</p><h4 id="关系表"><a href="#关系表" class="headerlink" title="关系表"></a>关系表</h4><p> 关系表（Relational Table）是关系型数据库中的基本组成部分之一，它由行和列组成，用于存储和组织数据。关系表是以二维表格形式呈现的，其中每一列表示一个属性（字段），每一行表示一个记录（元组）。 </p><p>关系表的设计通常遵循数据库设计的规范，包括主键（用于唯一标识每条记录）、外键（用于与其他表建立关联）等约束。 </p><h4 id="为什么要使用联结"><a href="#为什么要使用联结" class="headerlink" title="为什么要使用联结"></a>为什么要使用联结</h4><p>分解数据为多个表能更有效地存储，更方便地处理，且具有更大的可伸缩性。但这些好处是有代价的；</p><p>在关系型数据库中，使用联结（Join）是一种重要的操作，用于将多个关系表中的数据按照特定的关联条件进行合并。下面是一些使用联结的原因：</p><ol><li>数据关联：当数据分布在多个表中，并且这些表之间存在关联关系时，使用联结可以根据关联条件将相关数据连接在一起，从而获得更完整和详细的信息。</li><li>数据查询：通过联结，可以执行更复杂和灵活的查询操作。联结允许同时查询和获取多个关联表中的数据，从而得到更准确和全面的查询结果。</li><li>数据完整性：联结可以确保数据的完整性和一致性。通过将关联表的数据合并在一起，可以避免数据冗余和不一致问题，提高数据库的数据质量。</li><li>数据分析：联结可以帮助进行复杂的数据分析任务。通过将多个表中的数据合并，可以进行更深入和综合的数据分析，发现更多的关联和模式。</li><li>优化性能：在某些情况下，通过联结来优化查询性能。通过联结，可以减少需要多次查询的数据访问次数，从而提高查询效率。</li></ol><blockquote><p> 联结操作需要谨慎使用，尤其是对于包含大量数据的表或复杂的联结操作。合理设计数据库的关系、索引和查询语句是确保联结操作高效和准确的关键。 </p></blockquote><h3 id="创建联结"><a href="#创建联结" class="headerlink" title="创建联结"></a>创建联结</h3><p>在关系型数据库中，可以使用 SQL 语句来创建联结（JOIN），将多个表中的数据按照特定的关联条件进行合并。常见的联结类型包括内联结（INNER JOIN）、左联结（LEFT JOIN）、右联结（RIGHT JOIN）和全联结（FULL JOIN）。</p><p>以下是基本的联结语法示例：</p><ol><li>内联结（INNER JOIN）：</li></ol><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> column1<span class="token punctuation">,</span> column2<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">FROM</span> table1<span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> table2 <span class="token keyword">ON</span> table1<span class="token punctuation">.</span><span class="token keyword">column</span> <span class="token operator">=</span> table2<span class="token punctuation">.</span><span class="token keyword">column</span><span class="token punctuation">;</span></code></pre><ol start="2"><li>左联结（LEFT JOIN）：</li></ol><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> column1<span class="token punctuation">,</span> column2<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">FROM</span> table1<span class="token keyword">LEFT</span> <span class="token keyword">JOIN</span> table2 <span class="token keyword">ON</span> table1<span class="token punctuation">.</span><span class="token keyword">column</span> <span class="token operator">=</span> table2<span class="token punctuation">.</span><span class="token keyword">column</span><span class="token punctuation">;</span></code></pre><ol start="3"><li>右联结（RIGHT JOIN）：</li></ol><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> column1<span class="token punctuation">,</span> column2<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">FROM</span> table1<span class="token keyword">RIGHT</span> <span class="token keyword">JOIN</span> table2 <span class="token keyword">ON</span> table1<span class="token punctuation">.</span><span class="token keyword">column</span> <span class="token operator">=</span> table2<span class="token punctuation">.</span><span class="token keyword">column</span><span class="token punctuation">;</span></code></pre><ol start="4"><li>全联结（FULL JOIN）：</li></ol><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> column1<span class="token punctuation">,</span> column2<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">FROM</span> table1<span class="token keyword">FULL</span> <span class="token keyword">JOIN</span> table2 <span class="token keyword">ON</span> table1<span class="token punctuation">.</span><span class="token keyword">column</span> <span class="token operator">=</span> table2<span class="token punctuation">.</span><span class="token keyword">column</span><span class="token punctuation">;</span></code></pre><p>在上述示例中，table1 和 table2 是要进行联结的两个表，ON 子句指定了关联条件，用于指定两个表之间要匹配的列。SELECT 子句中列出了想要查询的字段。</p><h3 id="创建高级联结"><a href="#创建高级联结" class="headerlink" title="创建高级联结"></a>创建高级联结</h3><h4 id="使用表别名"><a href="#使用表别名" class="headerlink" title="使用表别名"></a>使用表别名</h4><p>当需要进行更复杂的联结操作时，可以结合表别名使用高级联结。</p><p>别名除了用于列名和计算字段外，SQL还允许给表名起别名。这样做有两个主要理由： </p><p>1缩短SQL语句； </p><p>2允许在单条SELECT语句中多次使用相同的表。</p><p>以下是一个示例，演示如何使用表别名进行内联结和左联结：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> t1<span class="token punctuation">.</span>column1<span class="token punctuation">,</span> t2<span class="token punctuation">.</span>column2<span class="token keyword">FROM</span> table1 <span class="token keyword">AS</span> t1<span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> table2 <span class="token keyword">AS</span> t2 <span class="token keyword">ON</span> t1<span class="token punctuation">.</span>id <span class="token operator">=</span> t2<span class="token punctuation">.</span>id<span class="token keyword">WHERE</span> t1<span class="token punctuation">.</span>column3 <span class="token operator">=</span> <span class="token string">'value'</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> t1<span class="token punctuation">.</span>column1<span class="token punctuation">,</span> t2<span class="token punctuation">.</span>column2<span class="token keyword">FROM</span> table1 <span class="token keyword">AS</span> t1<span class="token keyword">LEFT</span> <span class="token keyword">JOIN</span> table2 <span class="token keyword">AS</span> t2 <span class="token keyword">ON</span> t1<span class="token punctuation">.</span>id <span class="token operator">=</span> t2<span class="token punctuation">.</span>id<span class="token keyword">WHERE</span> t1<span class="token punctuation">.</span>column3 <span class="token operator">=</span> <span class="token string">'value'</span><span class="token punctuation">;</span></code></pre><p>在上述示例中，我们使用表别名 “t1” 和 “t2” 分别代替了表 table1 和 table2。通过表别名，我们可以在查询中引用相应的表，并指定它们之间的关联条件。</p><p>第一个示例展示了一个内联结，使用 INNER JOIN 关键字将表 t1 和 t2 进行联结，并在 ON 子句中指定了关联条件。这个查询只返回满足 t1.column3 = ‘value’ 条件的结果。</p><p>第二个示例展示了一个左联结，使用 LEFT JOIN 关键字将表 t1 和 t2 进行联结，并在 ON 子句中指定了关联条件。这个查询同样只返回满足 t1.column3 = ‘value’ 条件的结果，但保留了 t1 表中没有匹配的记录。</p><h4 id="使用不同类型的联结"><a href="#使用不同类型的联结" class="headerlink" title="使用不同类型的联结"></a>使用不同类型的联结</h4><p>当处理一张表内的数据关联时，可以使用自联结（self-join），而当需要联结两个具有相同结构的表时，可以使用自然联结（natural join）。此外，当需要获取包括不符合联结条件的行时，可以使用外部联结（outer join）。</p><p>下面是使用不同类型的联结的示例：</p><ol><li>自联结（Self-Join）：</li></ol><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> t1<span class="token punctuation">.</span>column1<span class="token punctuation">,</span> t2<span class="token punctuation">.</span>column2<span class="token keyword">FROM</span> <span class="token keyword">table</span> <span class="token keyword">AS</span> t1<span class="token keyword">JOIN</span> <span class="token keyword">table</span> <span class="token keyword">AS</span> t2 <span class="token keyword">ON</span> t1<span class="token punctuation">.</span>id <span class="token operator">=</span> t2<span class="token punctuation">.</span>related_id<span class="token punctuation">;</span></code></pre><p>在自联结中，我们使用相同的表别名 “t1” 和 “t2” 来引用同一张表，并指定它们之间的关联条件。这可以用于将表中的某一行与同一表中的其他行进行比较和关联。</p><ol start="2"><li>自然联结（Natural Join）：</li></ol><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span><span class="token keyword">FROM</span> table1<span class="token keyword">NATURAL</span> <span class="token keyword">JOIN</span> table2<span class="token punctuation">;</span></code></pre><p>自然联结会自动根据两个表中列名相同的列进行关联。该操作省略了使用 ON 子句指定关联条件的步骤。</p><ol start="3"><li>外部联结（Outer Join）：</li></ol><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> t1<span class="token punctuation">.</span>column1<span class="token punctuation">,</span> t2<span class="token punctuation">.</span>column2<span class="token keyword">FROM</span> table1 <span class="token keyword">AS</span> t1<span class="token keyword">LEFT</span> <span class="token keyword">JOIN</span> table2 <span class="token keyword">AS</span> t2 <span class="token keyword">ON</span> t1<span class="token punctuation">.</span>id <span class="token operator">=</span> t2<span class="token punctuation">.</span>id<span class="token punctuation">;</span></code></pre><p>外部联结可以分为左外部联结（LEFT OUTER JOIN）和右外部联结（RIGHT OUTER JOIN）。上述示例演示了左外部联结，返回左表（table1）中的所有行，以及与右表（table2）中符合关联条件的匹配行。如果没有匹配行，则右表中的列将用 NULL 值表示。</p><h4 id="使用带聚集函数的联结"><a href="#使用带聚集函数的联结" class="headerlink" title="使用带聚集函数的联结"></a>使用带聚集函数的联结</h4><p>可以在联结操作中使用聚合函数来对联结后的数据进行聚合计算。以下是使用带有聚合函数的联结的示例：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> t1<span class="token punctuation">.</span><span class="token keyword">column</span><span class="token punctuation">,</span> <span class="token function">COUNT</span><span class="token punctuation">(</span>t2<span class="token punctuation">.</span><span class="token keyword">column</span><span class="token punctuation">)</span><span class="token keyword">FROM</span> table1 <span class="token keyword">AS</span> t1<span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> table2 <span class="token keyword">AS</span> t2 <span class="token keyword">ON</span> t1<span class="token punctuation">.</span>id <span class="token operator">=</span> t2<span class="token punctuation">.</span>id<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> t1<span class="token punctuation">.</span><span class="token keyword">column</span><span class="token punctuation">;</span></code></pre><p>上述示例中，使用了内联结（INNER JOIN）将表1（table1）和表2（table2）进行联结，并使用关联条件 t1.id = t2.id 进行匹配。然后，通过聚合函数 COUNT(t2.column) 对联结后的数据进行计数。使用 GROUP BY 子句按照 t1.column 进行分组，以便为每个不同的 t1.column 值计算对应的 COUNT(t2.column) 值。</p><p>可以根据需要使用其他聚集函数，例如 SUM、AVG、MIN、MAX 等等来对联结后的数据进行聚合计算。</p><h4 id="使用联结和联结条件"><a href="#使用联结和联结条件" class="headerlink" title="使用联结和联结条件"></a>使用联结和联结条件</h4><p>1注意所使用的联结类型。一般我们使用内部联结，但使用外部联结也是有效的。 </p><p>2保证使用正确的联结条件，否则将返回不正确的数据。 </p><p>3应该总是提供联结条件，否则会得出笛卡儿积。 </p><p>4在一个联结中可以包含多个表，甚至对于每个联结可以采用不同 的联结类型。虽然这样做是合法的，一般也很有用，但应该在一起测试它们前，分别测试每个联结。这将使故障排除更为简单。</p><h2 id="使用视图"><a href="#使用视图" class="headerlink" title="使用视图"></a>使用视图</h2><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p>视图是虚拟的表。与包含数据的表不一样，视图只包含使用时动态检索数据的查询</p><h3 id="为什么使用视图"><a href="#为什么使用视图" class="headerlink" title="为什么使用视图"></a>为什么使用视图</h3><p>使用视图有以下几个常见的优点和用途：</p><ol><li>简化复杂的查询：视图可以将多个表关联和筛选操作封装在一个视图中，从而简化复杂查询的编写过程。用户只需使用视图进行查询，而不必关心底层表的结构和关系。</li><li>数据安全性和权限控制：通过视图，可以限制用户对底层表的直接访问，从而提高数据的安全性。你可以定义一个仅包含所需的列和行的视图，然后将该视图授予特定的用户或角色。这样，用户只能通过视图访问被授权的数据，而无法直接访问表。</li><li>数据抽象和逻辑分离：视图可以提供数据的抽象层，将数据库的物理结构与逻辑操作进行分离。这有助于简化应用程序开发过程，使得应用程序可以基于视图进行操作，而不必直接处理底层表的复杂性。</li><li>维护和变更管理：如果数据库的底层表结构发生变化，例如添加或删除列，但视图的定义保持不变，那么应用程序也不需要进行大量的更改。视图提供了一种独立于底层数据结构的方式来访问数据，从而减少了维护工作和代码的重构。</li><li>提供数据重用：通过创建视图，可以将常用的查询逻辑封装起来并重复使用。这样可以提高代码的可维护性和代码重用性，减少冗余代码的编写。</li></ol><h3 id="视图的规则和限制"><a href="#视图的规则和限制" class="headerlink" title="视图的规则和限制"></a>视图的规则和限制</h3><p>视图在使用时有一些规则和限制，下面是常见的一些规则和限制：</p><ol><li><p>视图必须基于一个或多个已存在的表或其他视图。视图无法直接基于其他视图。</p></li><li><p>视图只能查询数据，不能修改数据。这意味着你不能通过视图进行插入、更新或删除操作。如果想要修改数据，需要直接操作底层的表。</p></li><li><p>视图的列名可以是自定义的，不一定与底层表的列名相同。但是在查询时，仍然需要使用视图中定义的列名。</p></li><li><p>视图的定义可以包含筛选条件，用于限制结果集中的行。这可以通过在创建视图时使用 WHERE 子句来实现。</p></li><li><p>视图的定义可以包含连接操作，用于关联多个表。这可以通过在创建视图时使用 JOIN 子句来实现。</p></li><li><p>视图可以嵌套，即一个视图可以基于另一个视图进行定义。但是要注意，嵌套的视图可能会影响查询性能，因此需要谨慎使用。</p></li><li><p>视图可以具有授权和权限限制。只有具有足够权限的用户才能够查询和使用视图。</p></li><li><p>视图的性能可能会受到影响。复杂的视图查询可能会导致性能下降，特别是当涉及到大量数据和多个表时。在设计视图时应考虑性能方面的问题。</p></li></ol><h3 id="使用视图-1"><a href="#使用视图-1" class="headerlink" title="使用视图"></a>使用视图</h3><p>视图用CREATE VIEW语句来创建</p><pre><code>CREATE VIEW view_name ASSELECT column1, column2, ...FROM table_nameWHERE condition;</code></pre><p>使用SHOW CREATE VIEW viewname；来查看创建视图的语句</p><pre><code>SHOW CREATE VIEW view_name;</code></pre><p>用DROP删除视图，其语法为DROP VIEW viewname</p><pre><code>DROP VIEW view_name;</code></pre><p>更新视图时，可以先用DROP再用CREATE，也可以直接用CREATE OR  REPLACE VIEW。如果要更新的视图不存在，则第2条更新语句会创建一个视图；如果要更新的视图存在，则第2条更新语句会替换原有视图。</p><h4 id="利用视图简化复杂的联结"><a href="#利用视图简化复杂的联结" class="headerlink" title="利用视图简化复杂的联结"></a>利用视图简化复杂的联结</h4><p>使用视图可以简化复杂的联结操作。通过创建视图，将多个表的联结逻辑封装起来，并且在需要时直接使用视图进行查询，而无需编写繁琐的联结语句。</p><p>以下是一个示例，展示如何使用视图简化联结操作：</p><p>假设你有两个表：<code>orders</code> 和 <code>customers</code>，它们之间通过 <code>customer_id</code> 列进行关联。你想要查询订单信息以及对应的顾客信息。首先，你可以创建一个名为 <code>order_details</code> 的视图，该视图包含订单信息和对应的顾客信息。创建视图的语句如下：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">VIEW</span> order_details <span class="token keyword">AS</span><span class="token keyword">SELECT</span> o<span class="token punctuation">.</span>order_id<span class="token punctuation">,</span> o<span class="token punctuation">.</span>order_date<span class="token punctuation">,</span> <span class="token number">c</span><span class="token punctuation">.</span>customer_name<span class="token keyword">FROM</span> orders o<span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> customers <span class="token number">c</span> <span class="token keyword">ON</span> o<span class="token punctuation">.</span>customer_id <span class="token operator">=</span> <span class="token number">c</span><span class="token punctuation">.</span>customer_id<span class="token punctuation">;</span></code></pre><p>在上述语句中，我们通过联结 <code>orders</code> 表和 <code>customers</code> 表来获取订单信息和对应的顾客信息，并将结果保存为 <code>order_details</code> 视图。</p><p>一旦视图创建完成，你可以直接使用该视图进行查询，而无需编写联结语句。例如，你可以执行以下查询命令来获取订单信息以及对应的顾客信息：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> order_details<span class="token punctuation">;</span></code></pre><p>这样，你就可以轻松地获取到订单信息和对应的顾客信息，而无需手动编写联结语句。</p><p>通过使用视图，你可以将复杂的联结操作封装为一个可重复使用的对象，并提高查询的简洁性和可读性。</p><h4 id="用视图重新格式化检索出的数据"><a href="#用视图重新格式化检索出的数据" class="headerlink" title="用视图重新格式化检索出的数据"></a>用视图重新格式化检索出的数据</h4><p>使用视图可以重新格式化检索出的数据。在创建视图时，通过查询语句对数据进行适当的格式化操作，以满足需求。</p><p>以下是一个示例，展示如何使用视图重新格式化检索出的数据：</p><p>假设你有一个名为 <code>employees</code> 的表，其中包含员工的姓名和薪资信息。你想要将这些数据按照一定的格式进行检索，例如将姓名的首字母大写，并显示薪资的千位分隔符。</p><p>首先，你可以创建一个名为 <code>formatted_employees</code> 的视图，该视图重新格式化了员工表中的数据。创建视图的语句如下：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">VIEW</span> formatted_employees <span class="token keyword">AS</span><span class="token keyword">SELECT</span>   CONCAT<span class="token punctuation">(</span><span class="token function">UCASE</span><span class="token punctuation">(</span><span class="token keyword">LEFT</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> LOWER<span class="token punctuation">(</span>SUBSTRING<span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> formatted_name<span class="token punctuation">,</span>  <span class="token function">FORMAT</span><span class="token punctuation">(</span>salary<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> formatted_salary<span class="token keyword">FROM</span> employees<span class="token punctuation">;</span></code></pre><p>在上述语句中，我们使用了字符串函数 <code>CONCAT</code> 和 <code>UCASE</code> 来将姓名的首字母大写，并使用了字符串函数 <code>LOWER</code> 和 <code>SUBSTRING</code> 来保持其余部分小写。我们还使用了函数 <code>FORMAT</code> 来添加薪资的千位分隔符。</p><p>一旦视图创建完成，你可以直接使用该视图进行查询，以获取已经重新格式化的数据。例如，你可以执行以下查询命令来获取重新格式化后的员工数据：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> formatted_employees<span class="token punctuation">;</span></code></pre><p>这样，你就可以获得按照特定格式重新处理过的员工数据。通过使用视图，你可以在数据库中创建一个虚拟表，该表包含经过格式化的数据，以便于查询和使用。</p><h4 id="用视图过滤不想要的数据"><a href="#用视图过滤不想要的数据" class="headerlink" title="用视图过滤不想要的数据"></a>用视图过滤不想要的数据</h4><p>使用视图可以方便地过滤掉你不想要的数据，只返回符合指定条件的数据。你可以在创建视图时，通过添加筛选条件来过滤数据。</p><p>以下是一个示例，展示如何使用视图过滤不想要的数据：</p><p>假设你有一个名为 <code>products</code> 的表，其中包含产品的名称、价格和库存信息。你想要创建一个视图，只包含价格高于100的产品信息。</p><p>你可以使用以下语句创建一个名为 <code>high_priced_products</code> 的视图：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">VIEW</span> high_priced_products <span class="token keyword">AS</span><span class="token keyword">SELECT</span> <span class="token operator">*</span><span class="token keyword">FROM</span> products<span class="token keyword">WHERE</span> price <span class="token operator">></span> <span class="token number">100</span><span class="token punctuation">;</span></code></pre><p>在上述语句中，我们在查询语句中包含了一个筛选条件 <code>WHERE price &gt; 100</code>，它将仅返回价格高于100的产品信息。</p><p>创建完成后，你可以直接使用该视图进行查询，以获取满足条件的产品信息。例如，你可以执行以下查询命令来获取价格高于100的产品：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> high_priced_products<span class="token punctuation">;</span></code></pre><p>这样，你就可以获得符合条件的产品信息，而不包括价格低于或等于100的产品。通过使用视图进行数据过滤，你可以创建一个过滤后的虚拟表，使得查询结果更加精确和符合特定需求。</p><h4 id="使用视图与计算字段"><a href="#使用视图与计算字段" class="headerlink" title="使用视图与计算字段"></a>使用视图与计算字段</h4><p>使用视图和计算字段可以在数据库中创建一个虚拟表，其中包含经过计算的字段。视图可以简化复杂的计算操作，并使其更易于查询和使用。</p><p>以下是一个示例，展示如何在视图中使用计算字段：</p><p>假设你有一个名为 <code>sales</code> 的表，其中包含销售订单的信息，包括产品名称、单价和销售数量。你想要创建一个视图，包含订单的总价和利润率。</p><p>你可以使用以下语句创建一个名为 <code>sales_summary</code> 的视图：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">VIEW</span> sales_summary <span class="token keyword">AS</span><span class="token keyword">SELECT</span>   product_name<span class="token punctuation">,</span>  unit_price<span class="token punctuation">,</span>  quantity<span class="token punctuation">,</span>  unit_price <span class="token operator">*</span> quantity <span class="token keyword">AS</span> total_price<span class="token punctuation">,</span>  <span class="token punctuation">(</span>unit_price <span class="token operator">*</span> quantity <span class="token operator">-</span> cost_price <span class="token operator">*</span> quantity<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token punctuation">(</span>unit_price <span class="token operator">*</span> quantity<span class="token punctuation">)</span> <span class="token keyword">AS</span> profit_margin<span class="token keyword">FROM</span> sales<span class="token punctuation">;</span></code></pre><p>在上述语句中，我们在查询语句中定义了两个计算字段：<code>total_price</code> 和 <code>profit_margin</code>。<code>total_price</code> 计算了订单的总价，通过将单价与销售数量相乘；<code>profit_margin</code> 计算了订单的利润率，通过使用销售利润与总价的比率来计算。</p><p>创建完成后，你可以直接使用该视图进行查询，以获取包含计算字段的信息。例如，你可以执行以下查询命令来获取销售订单的摘要信息：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> sales_summary<span class="token punctuation">;</span></code></pre><p>这样，你就可以获得包含了订单总价和利润率的摘要信息。</p><p>通过使用视图和计算字段，你可以在数据库中创建一个方便查询的虚拟表，其中包含经过计算的字段，使得数据分析和报表生成更加便捷。</p><h4 id="更新视图"><a href="#更新视图" class="headerlink" title="更新视图"></a>更新视图</h4><p>视图的数据能否更新？答案视情况而定</p><p>通常，视图是可更新的（即，可以对它们使用INSERT、UPDATE和DELETE）。更新一个视图将更新其基表（可以回忆一下，视图本身没有数据）。如果你对视图增加或删除行，实际上是对其基表增加或删除行</p><p>并非所有视图都是可更新的。基本上可以说，如果MySQL不能正确地确定被更新的基数据，则不允许更新（包括插入和删除）。这实际上意味着，如果视图定义中有以下操作，则不能进行视图的更新：</p><p> 分组（使用GROUP BY和HAVING）； </p><p> 联结； </p><p> 子查询； </p><p> 并； </p><p> 聚集函数（Min()、Count()、Sum()等）</p><p> DISTINCT； </p><p> 导出（计算）列</p><blockquote><p>将视图用于检索 一般，应该将视图用于检索（SELECT语句） </p><p>而不用于更新（INSERT、UPDATE和DELETE）</p></blockquote><h1 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h1><h2 id="使用存储过程"><a href="#使用存储过程" class="headerlink" title="使用存储过程"></a>使用存储过程</h2><h3 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h3><p>存储过程是一组预定义的SQL语句集合，它们被存储在数据库中，并可以作为一个单元来执行。存储过程具有以下优点：</p><ol><li><p>代码封装：存储过程将一组相关的SQL语句封装在一个单元中，使得代码更易于维护和管理。</p></li><li><p>提高性能：存储过程在数据库中预编译，因此执行速度较快。此外，存储过程还可以减少与数据库服务器的通信次数，提高整体性能。</p></li><li><p>安全性：通过存储过程，可以限制用户直接访问表，而只允许通过存储过程来执行特定的操作。这样可以增强数据库的安全性。</p></li><li><p>代码重用：存储过程可以在不同的应用程序中重用，从而减少了代码的编写量，提高了开发效率。</p></li></ol><p>下面是一个简单的存储过程示例，展示如何创建和执行存储过程：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">PROCEDURE</span> GetProductCount<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">BEGIN</span>    <span class="token keyword">SELECT</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> total_products <span class="token keyword">FROM</span> products<span class="token punctuation">;</span><span class="token keyword">END</span><span class="token punctuation">;</span></code></pre><p>上述存储过程名为 <code>GetProductCount</code>，它使用<code>SELECT COUNT(*)</code>语句来获取表 <code>products</code> 的总行数，并将结果存储在一个名为 <code>total_products</code> 的列中。</p><p>要执行该存储过程，可以使用以下语句：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CALL</span> GetProductCount<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>执行存储过程后，将返回一个结果集，其中包含产品总数。</p><h3 id="为什么要使用存储过程"><a href="#为什么要使用存储过程" class="headerlink" title="为什么要使用存储过程"></a>为什么要使用存储过程</h3><p>使用存储过程有多种好处和用途，以下是一些常见的原因和情景：</p><ol><li><p>提高性能：存储过程在数据库中预编译，并且可以进行优化。这意味着存储过程的执行速度通常比简单的SQL查询更快。此外，存储过程可以减少与数据库服务器的通信次数，从而提高整体性能。</p></li><li><p>代码重用：存储过程可以在不同的应用程序中重复使用。通过将常用的业务逻辑封装在存储过程中，可以避免在每个应用程序中重复编写相同的代码，从而提高开发效率和代码的可维护性。</p></li><li><p>安全性控制：存储过程可以用于限制用户对数据库的直接访问，并只允许他们通过存储过程执行特定的操作。这样可以增强数据库的安全性，同时更好地控制数据的访问和修改权限。</p></li><li><p>简化复杂的业务逻辑：存储过程可以容纳包含多个SQL语句和逻辑的复杂业务操作。通过将这些操作封装在一个存储过程中，可以简化应用程序中的代码，并使其更易于理解和维护。</p></li><li><p>数据一致性和完整性：存储过程可以确保特定的业务规则和约束得到遵守。通过在存储过程中定义相应的数据验证、更新和插入规则，可以确保数据的一致性和完整性。</p></li><li><p>数据库层面的错误处理：存储过程允许在数据库层面上进行错误处理和异常处理。可以使用条件语句和异常处理机制来捕获和处理数据库操作中的错误，从而提供更加可靠和稳定的应用程序。</p></li></ol><h3 id="使用存储过程-1"><a href="#使用存储过程-1" class="headerlink" title="使用存储过程"></a>使用存储过程</h3><ol><li><h4 id="执行存储过程："><a href="#执行存储过程：" class="headerlink" title="执行存储过程："></a>执行存储过程：</h4></li></ol><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CALL</span> 存储过程名称<span class="token punctuation">;</span></code></pre><p>通过使用 <code>CALL</code> 关键字，可以执行指定名称的存储过程。</p><ol start="2"><li><h4 id="创建存储过程："><a href="#创建存储过程：" class="headerlink" title="创建存储过程："></a>创建存储过程：</h4></li></ol><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">PROCEDURE</span> 存储过程名称<span class="token punctuation">(</span>参数列表<span class="token punctuation">)</span><span class="token keyword">BEGIN</span>    存储过程体<span class="token keyword">END</span><span class="token punctuation">;</span></code></pre><p>使用 <code>CREATE PROCEDURE</code> 关键字和合适的语法，可以创建一个新的存储过程。参数列表和存储过程体都是可选的，根据需要进行定义。</p><ol start="3"><li><h4 id="删除存储过程："><a href="#删除存储过程：" class="headerlink" title="删除存储过程："></a>删除存储过程：</h4></li></ol><pre class=" language-sql"><code class="language-sql"><span class="token keyword">DROP</span> <span class="token keyword">PROCEDURE</span> <span class="token keyword">IF</span> <span class="token keyword">EXISTS</span> 存储过程名称<span class="token punctuation">;</span></code></pre><p>使用 <code>DROP PROCEDURE</code> 关键字可以删除指定名称的存储过程。<code>IF EXISTS</code> 部分用于检查存储过程是否存在，避免出现错误。</p><ol start="4"><li><h4 id="使用参数："><a href="#使用参数：" class="headerlink" title="使用参数："></a>使用参数：</h4><p>存储过程可以接收输入参数、输出参数或输入输出参数，用于动态地处理数据。在创建存储过程时，可以在参数列表中定义这些参数，并在存储过程体中使用它们。</p><p>以下是一个示例，展示如何在存储过程中使用参数：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">PROCEDURE</span> ProcessData<span class="token punctuation">(</span><span class="token operator">IN</span> input_param <span class="token keyword">INT</span><span class="token punctuation">,</span> <span class="token keyword">OUT</span> output_param <span class="token keyword">INT</span><span class="token punctuation">)</span><span class="token keyword">BEGIN</span>    <span class="token comment" spellcheck="true">-- 在存储过程中使用输入参数</span>    <span class="token keyword">SELECT</span> column1<span class="token punctuation">,</span> column2     <span class="token keyword">FROM</span> <span class="token keyword">table</span>    <span class="token keyword">WHERE</span> condition <span class="token operator">=</span> input_param<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">-- 在存储过程中使用输出参数</span>    <span class="token keyword">SET</span> output_param <span class="token operator">=</span> input_param <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token keyword">END</span><span class="token punctuation">;</span></code></pre><p>上述示例中的存储过程 <code>ProcessData</code> 接收一个输入参数 <code>input_param</code> 和一个输出参数 <code>output_param</code>。具体的实现逻辑包括：</p><ul><li>使用 <code>IN</code> 关键字声明输入参数 <code>input_param</code> 的类型。</li><li>在存储过程体中，可以使用输入参数 <code>input_param</code> 来进行条件查询，根据不同的条件动态处理数据。</li><li>使用 <code>OUT</code> 关键字声明输出参数 <code>output_param</code> 的类型。</li><li>在存储过程体中，可以对输出参数 <code>output_param</code> 进行赋值操作，以便将结果传递给调用者。</li></ul></li></ol><ol start="5"><li><h4 id="建立智能存储过程："><a href="#建立智能存储过程：" class="headerlink" title="建立智能存储过程："></a>建立智能存储过程：</h4><p>智能存储过程是指具有逻辑判断和条件处理能力的存储过程。您可以在存储过程的主体中添加条件、循环和控制语句来实现更复杂的业务逻辑。</p><p>下面是一个示例，展示如何在存储过程中使用条件语句和控制流程语句：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">PROCEDURE</span> IntelligentProcedure<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">BEGIN</span>    <span class="token keyword">DECLARE</span> total_sales <span class="token keyword">DECIMAL</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">DECLARE</span> bonus <span class="token keyword">DECIMAL</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">-- 计算总销售额</span>    <span class="token keyword">SELECT</span> <span class="token function">SUM</span><span class="token punctuation">(</span>sales_amount<span class="token punctuation">)</span> <span class="token keyword">INTO</span> total_sales <span class="token keyword">FROM</span> sales<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">-- 根据销售额计算奖金</span>    <span class="token keyword">IF</span> total_sales <span class="token operator">></span> <span class="token number">100000</span> <span class="token keyword">THEN</span>        <span class="token keyword">SET</span> bonus <span class="token operator">=</span> total_sales <span class="token operator">*</span> <span class="token number">0.1</span><span class="token punctuation">;</span>    ELSEIF total_sales <span class="token operator">></span> <span class="token number">50000</span> <span class="token keyword">THEN</span>        <span class="token keyword">SET</span> bonus <span class="token operator">=</span> total_sales <span class="token operator">*</span> <span class="token number">0.05</span><span class="token punctuation">;</span>    <span class="token keyword">ELSE</span>        <span class="token keyword">SET</span> bonus <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">END</span> <span class="token keyword">IF</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">-- 输出结果</span>    <span class="token keyword">SELECT</span> bonus <span class="token keyword">AS</span> <span class="token string">'Bonus Amount'</span><span class="token punctuation">;</span><span class="token keyword">END</span><span class="token punctuation">;</span></code></pre><p>上述示例中的存储过程 <code>IntelligentProcedure</code> 实现了一个简单的逻辑：根据总销售额的不同范围，计算出相应的奖金金额。具体的实现逻辑包括：</p><ul><li>定义两个变量 <code>total_sales</code> 和 <code>bonus</code> 来保存总销售额和奖金金额。</li><li>使用 <code>SELECT...INTO</code> 语句将总销售额查询结果赋值给 <code>total_sales</code> 变量。</li><li>使用条件语句 <code>IF...ELSEIF...ELSE</code> 根据不同的销售额范围计算奖金金额，并将结果赋值给 <code>bonus</code> 变量。</li><li>最后，使用 <code>SELECT</code> 语句输出奖金金额。</li></ul><p>通过这种方式，您可以根据实际需求，在存储过程中添加适当的条件、循环和控制流程语句，以实现更智能的业务逻辑。</p></li><li><h4 id="检查存储过程："><a href="#检查存储过程：" class="headerlink" title="检查存储过程："></a>检查存储过程：</h4></li></ol><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SHOW</span> <span class="token keyword">CREATE</span> <span class="token keyword">PROCEDURE</span> 存储过程名称<span class="token punctuation">;</span></code></pre><p>使用 <code>SHOW CREATE PROCEDURE</code> 命令可以查看指定存储过程的创建语句。这对于检查存储过程的定义和结构非常有用。</p><h2 id="使-用-游-标"><a href="#使-用-游-标" class="headerlink" title="使 用 游 标"></a>使 用 游 标</h2><p>游标（Cursor）是一种用于在存储过程或函数中遍历结果集的机制。通过使用游标，您可以逐行处理查询结果，并对每一行执行特定的操作。</p><p>以下是一个示例，展示如何在存储过程中使用游标：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">PROCEDURE</span> ProcessData<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">BEGIN</span>    <span class="token keyword">DECLARE</span> done <span class="token keyword">INT</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">FALSE</span><span class="token punctuation">;</span>    <span class="token keyword">DECLARE</span> column1 <span class="token keyword">INT</span><span class="token punctuation">;</span>    <span class="token keyword">DECLARE</span> column2 <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">-- 声明游标</span>    <span class="token keyword">DECLARE</span> cur <span class="token keyword">CURSOR</span> <span class="token keyword">FOR</span> <span class="token keyword">SELECT</span> column1<span class="token punctuation">,</span> column2 <span class="token keyword">FROM</span> <span class="token keyword">table</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">-- 定义异常处理程序</span>    <span class="token keyword">DECLARE</span> <span class="token keyword">CONTINUE</span> <span class="token keyword">HANDLER</span> <span class="token keyword">FOR</span> <span class="token operator">NOT</span> FOUND <span class="token keyword">SET</span> done <span class="token operator">=</span> <span class="token boolean">TRUE</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">-- 打开游标</span>    <span class="token keyword">OPEN</span> cur<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">-- 循环遍历结果集</span>    read_loop: LOOP        <span class="token comment" spellcheck="true">-- 读取下一行数据</span>        <span class="token keyword">FETCH</span> cur <span class="token keyword">INTO</span> column1<span class="token punctuation">,</span> column2<span class="token punctuation">;</span>        <span class="token keyword">IF</span> done <span class="token keyword">THEN</span>            LEAVE read_loop<span class="token punctuation">;</span>        <span class="token keyword">END</span> <span class="token keyword">IF</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">-- 在此处对每一行数据执行特定操作</span>        <span class="token comment" spellcheck="true">-- 示例：输出列值</span>        <span class="token keyword">SELECT</span> column1<span class="token punctuation">,</span> column2<span class="token punctuation">;</span>    <span class="token keyword">END</span> LOOP<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">-- 关闭游标</span>    <span class="token keyword">CLOSE</span> cur<span class="token punctuation">;</span><span class="token keyword">END</span><span class="token punctuation">;</span></code></pre><p>上述示例中的存储过程 <code>ProcessData</code> 使用游标来遍历查询结果集并对每一行数据执行特定的操作。具体的实现逻辑包括：</p><ul><li>声明变量 <code>done</code> 来表示游标是否已经遍历完所有行。</li><li>声明与查询结果集对应的变量，例如 <code>column1</code> 和 <code>column2</code>。</li><li>声明游标 <code>cur</code> 并将查询结果集赋值给游标。</li><li>定义异常处理程序，用于在遍历结果集时捕获异常（例如结果集为空）。</li><li>打开游标以准备遍历结果集。</li><li>使用循环语句 <code>LOOP</code> 和条件判断 <code>IF done THEN LEAVE read_loop; END IF;</code> 来循环遍历结果集，并在每次迭代中读取下一行数据。</li><li>在循环体中，您可以对每一行数据执行特定的操作，例如输出列值。</li><li>最后，关闭游标以释放资源。</li></ul><h2 id="使用触发器"><a href="#使用触发器" class="headerlink" title="使用触发器"></a>使用触发器</h2><p>触发器（Trigger）是数据库对象，可以在指定的数据库操作（例如插入、更新、删除）发生时自动执行一段代码。通过使用触发器，您可以在特定的数据变动事件上执行自定义逻辑，实现数据的约束、验证、派生等操作。</p><p>以下是一个示例，展示如何创建触发器：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TRIGGER</span> trigger_nameBEFORE <span class="token keyword">INSERT</span> <span class="token keyword">ON</span> table_name<span class="token keyword">FOR EACH ROW</span><span class="token keyword">BEGIN</span>    <span class="token comment" spellcheck="true">-- 在此处编写触发器的逻辑</span>    <span class="token comment" spellcheck="true">-- 示例：自动生成创建时间</span>    <span class="token keyword">SET</span> NEW<span class="token punctuation">.</span>create_time <span class="token operator">=</span> <span class="token function">NOW</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">END</span><span class="token punctuation">;</span></code></pre><p>上述示例中，我们创建了一个名为 <code>trigger_name</code> 的触发器，并指定它在表 <code>table_name</code> 上的插入操作之前执行。关键的配置包括：</p><ul><li>使用 <code>CREATE TRIGGER</code> 语句创建触发器，并为触发器指定一个名称。</li><li>使用 <code>BEFORE INSERT ON table_name</code> 指定触发器在表 <code>table_name</code> 上的插入操作之前执行。您可以根据需要选择不同的触发时机，如 <code>AFTER INSERT</code>、<code>BEFORE UPDATE</code>、<code>AFTER DELETE</code> 等。</li><li>使用 <code>FOR EACH ROW</code> 指定触发器对每一行数据都执行。</li><li>在 <code>BEGIN</code> 和 <code>END</code> 之间编写触发器的逻辑。在示例中，我们将新插入的行的 <code>create_time</code> 列设置为当前时间。</li></ul><h2 id="管理事务处理"><a href="#管理事务处理" class="headerlink" title="管理事务处理"></a>管理事务处理</h2><p>在数据库中，事务（Transaction）是一组数据库操作的逻辑单元，要么全部成功执行，要么全部回滚（撤销）。事务处理可以确保数据库在并发操作时维持数据的一致性和完整性。</p><p>以下是管理事务处理的示例：</p><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 启动事务</span><span class="token keyword">START</span> <span class="token keyword">TRANSACTION</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 在此处执行数据库操作</span><span class="token comment" spellcheck="true">-- 示例：插入数据</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> table_name <span class="token punctuation">(</span>column1<span class="token punctuation">,</span> column2<span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span>value1<span class="token punctuation">,</span> value2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 示例：更新数据</span><span class="token keyword">UPDATE</span> table_name <span class="token keyword">SET</span> column1 <span class="token operator">=</span> new_value <span class="token keyword">WHERE</span> condition<span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 示例：删除数据</span><span class="token keyword">DELETE</span> <span class="token keyword">FROM</span> table_name <span class="token keyword">WHERE</span> condition<span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 提交事务</span><span class="token keyword">COMMIT</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 或者回滚事务</span><span class="token keyword">ROLLBACK</span><span class="token punctuation">;</span></code></pre><p>上述示例中，我们使用 <code>START TRANSACTION</code> 开始一个事务，并在 <code>COMMIT</code> 处提交事务。如果需要回滚事务则可以使用 <code>ROLLBACK</code>。</p><p>在事务内，我们可以执行各种数据库操作，如插入、更新和删除等。这些操作将被视为一个逻辑单元，要么全部成功提交，要么全部回滚。</p><p>在实际应用中，为了确保事务的正确性和一致性，还应考虑以下几点：</p><ul><li>使用异常处理（例如使用存储过程或触发器）来捕获错误并决定是否回滚事务。</li><li>设置适当的隔离级别，以控制并发访问时数据的可见性和一致性。</li><li>避免长时间持有事务，以减少数据库锁的冲突和资源占用。</li></ul><h2 id="全球化和本地化"><a href="#全球化和本地化" class="headerlink" title="全球化和本地化"></a>全球化和本地化</h2><p>全球化（Globalization）和本地化（Localization）是软件开发领域中与跨国界应用程序的适配性和可用性相关的两个概念。字符集和校对顺序在全球化和本地化中起着重要的作用。</p><ol><li><p>字符集（Character Set）：</p><ul><li>字符集定义了一个字符到数字代码的映射规则。不同的字符集支持不同的字符范围，如 ASCII、Unicode 和 UTF-8。</li><li>全球化应用程序应该使用支持广泛的字符集，如UTF-8，以确保能够正确处理各种语言的字符和文本。</li></ul></li><li><p>校对顺序（Collation Order）：</p><ul><li>校对顺序定义了字符排序的规则和算法。它决定了在排序和比较字符串时字符的顺序和优先级。</li><li>不同的语言和地区使用不同的校对顺序来满足其特定的语言和文化需求。例如，英文通常使用字典排序，而中文通常使用拼音排序。</li><li>在本地化过程中，校对顺序需要根据特定的语言和地区进行配置，以确保正确的排序和比较。</li></ul></li></ol><p>在使用字符集和校对顺序时，需要注意以下几点：</p><ol><li><p>数据库配置：</p><ul><li>在数据库中，选择适当的字符集和校对顺序进行配置。不同的数据库管理系统（如MySQL、Oracle等）提供了相关配置选项。</li><li>确保数据库中使用的字符集和校对顺序与应用程序需要处理的语言和文本一致。</li></ul></li><li><p>应用程序开发：</p><ul><li>在应用程序开发中，使用与目标受众语言和文化相匹配的字符集和校对顺序进行编码和处理文本。</li><li>避免硬编码字符集和校对顺序，而是使用配置文件或在运行时动态设置。</li></ul></li><li><p>测试和验证：</p><ul><li>在全球化和本地化过程中，进行充分的测试和验证以确保字符集和校对顺序的正确性。</li><li>包括输入输出测试、排序和比较测试，以及特定语言和文化下的正确性验证。</li></ul></li></ol><h2 id="安-全-管-理"><a href="#安-全-管-理" class="headerlink" title="安 全 管 理"></a>安 全 管 理</h2><h3 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h3><ol><li>访问控制：<ul><li>MySQL使用权限模型来控制用户对数据库的访问。可以使用GRANT语句为用户分配权限。</li><li>GRANT语句用于授予用户特定的权限（如SELECT、INSERT、UPDATE、DELETE等）和访问级别（全局、数据库、表或列级别）。</li><li>使用REVOKE语句可以撤销已经授权的权限。</li></ul></li></ol><h3 id="管理用户"><a href="#管理用户" class="headerlink" title="管理用户"></a>管理用户</h3><ol><li><p>管理用户：</p><ul><li><p>创建用户：可以使用CREATE USER语句创建新用户。示例：</p><pre><code>CREATE USER &#39;username&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;password&#39;;</code></pre><p>可以指定用户名、主机名以及密码。</p></li><li><p>删除用户：使用DROP USER语句删除指定的用户。示例：</p><pre><code>DROP USER &#39;username&#39;@&#39;localhost&#39;;</code></pre></li></ul></li></ol><ul><li><p>设置访问权限：使用GRANT语句为用户分配特定权限。示例：</p><pre><code>GRANT SELECT, INSERT ON database.* TO &#39;username&#39;@&#39;localhost&#39;;</code></pre></li></ul><ul><li><p>更改口令：使用ALTER USER语句或SET PASSWORD语句更改用户的口令。示例：</p><pre><code>ALTER USER &#39;username&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;new_password&#39;;</code></pre></li></ul><h2 id="数据库维护"><a href="#数据库维护" class="headerlink" title="数据库维护"></a>数据库维护</h2><p>数据库维护是确保数据库系统正常运行和保障数据安全性的重要工作。下面是一些常见的数据库维护任务及相应的方法：</p><h3 id="备份数据："><a href="#备份数据：" class="headerlink" title="备份数据："></a>备份数据：</h3><ul><li><p>MySQL提供多种备份方法，包括物理备份和逻辑备份。常用的备份工具有<code>mysqldump</code>和<code>mysqlpump</code>。</p></li><li><p>使用<code>mysqldump</code>命令可以导出整个数据库或指定表的内容。例如，</p><pre><code>mysqldump -u &lt;username&gt; -p &lt;databasename&gt; &gt; backup.sql</code></pre><p>将整个数据库导出到backup.sql文件中。</p></li><li><p><code>mysqlpump</code>是MySQL 5.7及更新版本提供的备份工具，具有更高的性能和更多的选项。使用方法与<code>mysqldump</code>类似。</p></li></ul><h3 id="进行数据库维护："><a href="#进行数据库维护：" class="headerlink" title="进行数据库维护："></a>进行数据库维护：</h3><ul><li>定期优化数据库以提高性能，可以使用<code>OPTIMIZE TABLE</code>命令来优化表。</li><li>清理不必要的或过期的数据，可以使用<code>DELETE</code>语句或<code>TRUNCATE TABLE</code>命令。</li><li>检查并修复损坏的表，可以使用<code>CHECK TABLE</code>和<code>REPAIR TABLE</code>命令。</li></ul><h3 id="诊断启动问题："><a href="#诊断启动问题：" class="headerlink" title="诊断启动问题："></a>诊断启动问题：</h3><ul><li>如果数据库无法启动，首先可以检查错误日志文件，位于MySQL数据目录下的<code>error.log</code>文件，了解具体的错误信息。</li><li>可以使用<code>systemctl</code>命令（适用于使用systemd的系统）或<code>service</code>命令（适用于其他系统）来启动、停止、重启和查看MySQL服务的状态。例如，<code>systemctl start mysql</code>启动MySQL服务。</li></ul><h3 id="查看日志文件："><a href="#查看日志文件：" class="headerlink" title="查看日志文件："></a>查看日志文件：</h3><ul><li>MySQL记录了各种事件和错误信息，这些信息可以在错误日志文件中找到。错误日志的路径和文件名在MySQL配置文件中进行配置。</li><li>可以使用文本编辑器打开错误日志文件进行查看，或者使用<code>tail</code>命令实时查看最新的日志内容。例如，<code>tail -f /var/log/mysql/error.log</code>。</li></ul><h2 id="改-善-性-能"><a href="#改-善-性-能" class="headerlink" title="改 善 性 能"></a>改 善 性 能</h2><ol><li><p>优化查询：</p><ul><li>确保正确使用索引：合理设计表结构和索引，避免全表扫描。可以使用<code>EXPLAIN</code>语句来分析查询的执行计划，以确定是否有效使用了索引。</li><li>编写高效的查询语句：避免不必要的连接和子查询，优化复杂的SQL语句，提高查询的效率。</li><li>使用适当的数据类型：避免使用过大或不合适的数据类型，减少存储空间和I/O操作。</li></ul></li><li><p>调整配置：</p><ul><li>配置合适的缓冲区大小：如<code>innodb_buffer_pool_size</code>和<code>key_buffer_size</code>等，根据系统资源和负载情况进行调整，提高内存利用率。</li><li>优化连接池设置：增加或减少<code>max_connections</code>参数，根据实际需求合理配置连接数。</li><li>调整日志设置：合理配置日志的级别和写入方式，避免过多的日志写入对性能造成影响。</li></ul></li><li><p>硬件升级：</p><ul><li>提升硬件性能：增加CPU核心数、内存容量和磁盘I/O速度，以提高系统的处理能力和响应速度。</li><li>使用SSD存储：将磁盘替换为SSD可以显著提升I/O性能，加快读写速度。</li></ul></li><li><p>实施缓存策略：</p><ul><li>使用查询缓存：启用适当的查询缓存（如果可用），可减少数据库重复查询的开销。</li><li>使用应用层缓存：如Redis或Memcached等，将热门数据缓存在内存中，减少对数据库的访问。</li></ul></li><li><p>定期维护和监控：</p><ul><li>定期进行数据库优化和碎片整理：使用<code>OPTIMIZE TABLE</code>命令优化表，清理无效数据和索引碎片。</li><li>监控数据库性能：使用MySQL自带的性能监控工具或第三方监控工具，及时发现瓶颈并采取相应措施。</li></ul></li></ol><h1 id="MYSQL附录"><a href="#MYSQL附录" class="headerlink" title="MYSQL附录"></a>MYSQL附录</h1><h2 id="MYSQL必知必会导图"><a href="#MYSQL必知必会导图" class="headerlink" title="MYSQL必知必会导图"></a>MYSQL必知必会导图</h2><img src="https://cdn.jsdelivr.net/gh/Bevis23/blog-pic/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A.jpg" alt="mysql必知必会" style="zoom: 25%;"><h2 id="查看帮助文档"><a href="#查看帮助文档" class="headerlink" title="查看帮助文档"></a>查看帮助文档</h2><ul><li>在MySQL命令行客户端中，可以通过输入<code>help</code>或<code>\h</code>命令获取基本查询语法的帮助信息。</li><li>若要了解特定命令或函数的详细信息，可以使用<code>help</code>命令后面接上相应的命令或函数，例如：<code>help SELECT</code>。</li><li>还可以使用<code>man</code>命令（仅限于UNIX/Linux系统），如<code>man mysql</code>或<code>man mysqldump</code>来查看相关的手册页。</li></ul><h2 id="注意要点"><a href="#注意要点" class="headerlink" title="注意要点"></a>注意要点</h2><p><strong>distinct关键字：</strong>作用于所有的列，不仅仅是跟在其后的那一列。eg: select distinct vend_id,prod_price from products;  </p><p>除非指定的两列完全相同，否则所有的列都会被检索出来。</p><p><strong>order by 子句的位置</strong>：必须是语句中最后一条的句子，否则会输出错误信息；order by 位于where之后</p><p><strong>何时使用引号：</strong>单引号用来限制字符串。 将数值与字符串进行比较，就需要限定引号。</p><p><strong>in：</strong>where子句中用来指定要匹配值的清单关键字，功能与or相同</p><p><strong>通配符：</strong></p><p>1有一种情况吧通配符放在搜索模式的中间很有用，根据邮件地址的一部分来查找电子邮件eg：WHERE email like ‘b%@forta.com’</p><p>2通配符%不可以匹配null值</p><p>3 不要过度使用通配符，尽量不要把它们放在搜索模式的开始处（导致搜索慢），要注意位置，否则会报错</p><p><strong>计算字段</strong></p><p><strong>trim（）：去掉两边的空格  rtrim ltrim 右和左</strong></p><p>select concat（x, ‘(‘, y, ‘)’) as z from X order by x;  as最好使用它</p><p><strong>常用的文本处理函数</strong></p><p>soundex ：将任何文本串转化为描述其语音表示的字母数字模式算法</p><p>avg函数忽略null 的行</p><p>count函数 ：count（*）对行中所有的书进行计算，不管是包含的还是空值  count（）则忽略</p><p>distinct不能用于count（*）  必须使用列名 不能用于计算或表达式</p><p><strong>别名：</strong>在指定别名以包含某个聚集函数的结果时，不应该使用表中的实际列名；表别名只在查询中使用，与列别名不一样，表别名不返回到客户机</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p> 感谢你的阅读，祝你在 MySQL 的学习和实践中取得更大的成功！  让我们在 MySQL 的海洋中探索更多、学习更多^_^</p>]]></content>
      
      
      <categories>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术分享 </tag>
            
            <tag> 数据分析 </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>frp内网穿透：打开局域网的远程大门</title>
      <link href="/2023/07/06/frp-nei-wang-chuan-tou/"/>
      <url>/2023/07/06/frp-nei-wang-chuan-tou/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在现代科技发展的背景下，越来越多的人需要远程访问他们家庭或办公室网络中的设备。然而，由于网络安全限制，我们常常无法直接从外部访问局域网中的设备。这就是为什么内网穿透技术变得如此重要的原因。本文将向您介绍一种强大的<strong>内网穿透工具——frp</strong>，并向您展示如何使用它轻松实现远程访问。 </p><h1 id="内网穿透"><a href="#内网穿透" class="headerlink" title="内网穿透"></a>内网穿透</h1><h2 id="什么是内网穿透"><a href="#什么是内网穿透" class="headerlink" title="什么是内网穿透"></a>什么是内网穿透</h2><p><strong>内网穿透（NAT穿透）是一种网络技术，用于让外部网络可以访问位于私有内部网络中的设备或服务。</strong>在常见的网络环境中，私有内部网络（如家庭网络或公司局域网）通常使用了网络地址转换（Network Address Translation, NAT）来实现与公共互联网的连接，并将内部网络中的多个设备共享同一个公共IP地址 。</p><h2 id="为什么需要内网穿透"><a href="#为什么需要内网穿透" class="headerlink" title="为什么需要内网穿透"></a>为什么需要内网穿透</h2><p>由于NAT的存在，外部网络无法直接访问内部网络中的设备，因为它们位于不同的网络地址空间中。内网穿透技术通过一些特殊的手段，克服了这个限制，使得外部网络能够穿透NAT，直接与内部网络中的设备进行通信；</p><p><strong>应用场景：</strong></p><p>内网穿透广泛应用于各种场景，例如远程访问家庭网络中的摄像头、远程桌面控制内部计算机、在内网环境中搭建服务器并对外提供服务等。这些应用都依赖于内网穿透技术，使得外部用户能够通过公共网络安全地访问私有网络资源。 </p><h2 id="如何进行内网穿透"><a href="#如何进行内网穿透" class="headerlink" title="如何进行内网穿透"></a>如何进行内网穿透</h2><ol><li>选择合适的内网穿透工具：市场上有许多可供选择的工具，如Ngrok、FRP、花生壳等。根据你的需求和技术要求选择一个适合的工具。</li><li>下载和安装工具：根据所选工具的官方文档，下载并安装相应的内网穿透工具。确保你的操作系统和网络环境与工具的要求相符。</li><li>配置内网穿透工具：每个工具都有自己的配置方式，通常需要指定本地服务的端口号和要使用的域名或公网 IP 地址。按照工具的说明，进行必要的配置。</li><li>启动内网穿透工具：运行工具并启动内网穿透服务。工具会分配一个公共域名或 IP 地址，并将其映射到你指定的本地服务。</li><li>测试连接：使用外部网络，尝试通过工具提供的公共域名或 IP 地址访问你的本地服务。确保能够成功连接和使用。</li></ol><blockquote><p>本文将展示的为 frp内网穿透工具，服务器为centos系统</p></blockquote><h1 id="frp内网穿透"><a href="#frp内网穿透" class="headerlink" title="frp内网穿透"></a>frp内网穿透</h1><h2 id="frp简介"><a href="#frp简介" class="headerlink" title="frp简介"></a>frp简介</h2><p>frp 是一个开源、简洁易用、高性能的内网穿透和反向代理软件，支持 tcp, udp, http, https等协议。</p><p>frp 项目官网是：<a href="https://github.com/fatedier/frp" target="_blank" rel="noopener">https://github.com/fatedier/frp</a></p><p>中文文档：<a href="https://github.com/fatedier/frp/blob/master/README_zh.md" target="_blank" rel="noopener">https://github.com/fatedier/frp/blob/master/README_zh.md</a></p><p>除了安装过程，中文文档对使用过程已经介绍的非常详细，如遇到问题，建议先查看官方文档。</p><h2 id="frp原理"><a href="#frp原理" class="headerlink" title="frp原理"></a>frp原理</h2><ol><li>服务端配置：在公网上搭建一个 FRP 服务器作为中转节点。这个服务器需要有公网 IP 地址或域名，并安装配置好 FRP 服务器软件。</li><li>客户端配置：在内网中需要访问的设备上安装配置 FRP 客户端软件。客户端需要与服务端建立连接，因此需要知道服务器的 IP 地址或域名以及相应的端口号。</li><li>端口映射：在客户端配置文件中指定要映射到公网的本地服务的端口号。当外部请求到达 FRP 服务器时，服务器会将请求转发给客户端，并将客户端上对应端口的数据发送回客户端。</li><li>通信加密：FRP 支持对通信进行加密，以确保数据的安全传输。可以使用预共享密钥或证书来配置加密选项。</li><li>建立连接：客户端通过与 FRP 服务器建立长连接，实时保持与服务器的通信，并监听外部请求。</li><li>外部访问：当外部网络请求到达 FRP 服务器时，服务器将请求转发给客户端，客户端再将请求转发到本地的目标服务，从而实现了内网穿透。</li></ol><h2 id="frp部署"><a href="#frp部署" class="headerlink" title="frp部署"></a>frp部署</h2><h3 id="frp服务端"><a href="#frp服务端" class="headerlink" title="frp服务端"></a>frp服务端</h3><p>服务端建议部署在国内VPS，以提供良好的访问体验。</p><ol><li><p>打开 <a href="https://github.com/fatedier/frp/releases" target="_blank" rel="noopener">frp下载页面</a>，下载最新版的 <code>frp_0.51.0_linux_amd64.tar.gz</code>，然后上传到服务器连接Linux服务器，也可以ssh连接到服务器后用wget下载：</p><pre><code>wget https://github.com/fatedier/frp/releases/download/v0.51.0/frp_0.51.0_linux_amd64.tar.gz</code></pre></li><li><p>服务器上解压安装包： </p><pre><code>tar -zxvf frp_0.51.0_linux_amd64.tar.gz</code></pre></li><li><p>进入解压目录，找到 frps.ini ，填入以下内容：</p><p>vim vim frps.ini </p><pre><code>[common]bind_port = 7000    # frp监听的端口，默认是7000，可以改成其他的token = 3212344784    # 授权码，请改成更复杂的# frp管理后台端口，请按自己需求更改dashboard_port = 7500# frp管理后台用户名和密码，请改成自己的dashboard_user = bevis23dashboard_pwd = 3212344784enable_prometheus = true# frp日志配置log_file = /var/log/frps.loglog_level = infolog_max_days = 3</code></pre></li></ol><ol start="4"><li><p>设置和启动frp服务： </p><pre><code>mkdir -p /etc/frp    ## 创建一个名为 /etc/frp 的目录cp frps.ini /etc/frp    ## 将名为 frps.ini 的文件复制到 /etc/frp 目录中cp frps /usr/bin    ## 将名为 frps 的可执行文件复制到 /usr/bin 目录中，文件负责启动和运行 frps 服务</code></pre><p>创建frps.service文件，该文件用于启动和管理 frps 服务</p><pre><code>vim /etc/systemd/system/frps.service</code></pre><p>填下以下内容</p><pre><code>## 描述了服务的基本信息，如描述和依赖关系[Unit]Description=frps serviceAfter=network.target## 定义了服务的启动参数和命令，ExecStart 指定了启动 frps 的命令行，并通过 -c 参数指定了 frps.ini 配置文件的路径；estart=on-failure 表示在服务失败时会自动重启；User=frps 指定了服务以 frps 用户身份运行。LimitNOFILE=4096 设置了文件描述符的限制，可以根据需要进行调整。[Service]ExecStart=/usr/bin/frps -c /etc/frp/frps.iniRestart=on-failureUser=frpsLimitNOFILE=4096## 指定了服务的安装位置。WantedBy=multi-user.target 表示服务将被添加到多用户目标，以便在系统启动时自动启动。[Install]WantedBy=multi-user.target</code></pre><p>启动服务</p><pre><code>systemctl enable frpssystemctl start frps</code></pre></li><li><p>防火墙放行端口： </p><pre><code>firewall-cmd --permanent --add-port=7000/tcp    ## 添加监听端口firewall-cmd --permanent --add-port=7500/tcp    ## 添加管理后台端口   firewall-cmd --reload</code></pre></li><li><p>浏览器打开“http://服务器IP:后台管理端口” ，输入用户名和密码 </p></li></ol><h3 id="frp客户端"><a href="#frp客户端" class="headerlink" title="frp客户端"></a>frp客户端</h3><ol><li><p>客户端则同上下载对应的压缩包，客户端win，mac，linux对应下载对应的压缩包便可</p></li><li><p>解压，进入压缩包内</p></li><li><p>编辑frp.ini</p><blockquote><p>注意：</p><ol><li><p>一个服务端可以同时给多个客户端使用</p></li><li><p>[ssh]这样的名称必须全局唯一，即就算有多个客户端，也只能使用一次，其他的可以用[ssh2]、[ssh3]等；</p></li><li><p>除了type为http/https，端口只能被一个服务使用</p></li></ol></blockquote></li></ol><pre><code>   [common]    server_addr = 服务器ip   server_port = 7000    ## 请换成设置的服务器端口   token = 3212344784   # 配置ssh服务   [ssh]   type = tcp   local_ip = 127.0.0.1   local_port = 22   remote_port = 自定义的远程服务器端口 如2222   # 配置http服务，可用于小程序开发、远程调试等   [web]   type = http   local_ip = 127.0.0.1   local_port = 8080   subdomain = 子域名   remote_port = 自定义的远程服务器端口 如8080</code></pre><ol start="4"><li><p>登录服务器，防火墙放行监听的端口：</p><pre><code>firewall-cmd --permanent --add-port=2222/tcp  firewall-cmd --permanent --add-port=8080/tcpfirewall-cmd --reload</code></pre></li><li><p>运行</p><p>在windows上，在解压文件夹用./frpc.exe -c frpc.ini</p><p>在linux上，同服务器端设置服务</p></li><li><p>登录frp管理后台，客户端已连接上</p></li></ol><h2 id="frp安全性"><a href="#frp安全性" class="headerlink" title="frp安全性"></a>frp安全性</h2><p>在使用frp进行内网穿透时，安全性是至关重要的。以下是一些安全考虑和最佳实践：</p><ul><li>使用强密码：在frp配置文件中设置强密码以保护服务器和客户端的访问权限。</li><li>加密通信：启用frp的加密功能，确保数据在传输过程中的安全。</li><li>定期更新frp版本：及时更新frp软件以获取最新的安全补丁和功能改进。</li><li>防火墙和访问控制：根据需要，在服务器和客户端上配置防火墙规则和访问控制列表，限制访问权限。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p> 在本文中，我们深入了解了frp内网穿透工具，并展示了它如何帮助我们轻松实现远程访问。通过理解内网穿透技术的背景、掌握frp的原理和配置方法，以及遵循安全考虑和最佳实践，您可以打开局域网的远程大门，轻松访问位于内网的设备。无论是家庭网络、办公网络还是其他场景，frp都是一款功能强大且易于使用的工具，为我们提供了便利和灵活性。现在，您可以尝试使用frp，享受远程访问的便捷与自由！ </p>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
            <tag> 技术分享 </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客历程与优化记录</title>
      <link href="/2023/07/05/bo-ke-li-cheng-yu-you-hua-ji-lu/"/>
      <url>/2023/07/05/bo-ke-li-cheng-yu-you-hua-ji-lu/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><!-- 本文会记录本站自上线后的一系列优化和美化操作 --><!--同时记录使用的一些相关软件与技术--><blockquote><p> 本文会记录本站自上线后的一系列优化和美化操作 </p><p>同时记录使用的一些相关软件与技术</p></blockquote><p>一直有阅读和记录的习惯，以前都是使用有道云笔记、幕布、来记录自己的资源合集，所见所闻，所思所想； 个人热衷于利用技术工具解决问题，提高效率，享受通过科技创造和创新的过程 ；由于有道云笔记、幕布相对闭源，个人有着开源共享的精神，便萌生了建立这个博客网站的想法，开始搭建网站，选择hexo搭建，原因：完全免费且可以根据自己喜好更改</p><h2 id="为什么写博客，做博客网站："><a href="#为什么写博客，做博客网站：" class="headerlink" title="为什么写博客，做博客网站："></a><strong>为什么写博客，做博客网站：</strong></h2><ol><li>对知识点总结、回顾、思考 、 加深对技术理解 ， 给自己的岁月留下痕迹</li><li>提高个人的技术写作和思维能力 ， 提高快速解决问题的思维角度</li><li>锻炼自己规划，构建项目的能力，站在巨人的肩膀上，自己再对个人博客网站布局，模块设计，功能增加</li><li>帮助别人， 别人通过我的博客学习到一些知识，技能，解决问题的方法</li><li>更好的介绍自己 ，认识更多志同道合朋友</li><li>拥有一片只属于自己的净土，自由无拘束，写写文章，在这个世界上多留下点自己来过的痕迹</li></ol><blockquote><p>该博客主要采用的框架为Hexo，主题为matery，主要环境配置为 Node.js， npm包管理器， 博客托管于github page，到此，我的博客网站便初步搭建完成了。有关hexo和matery、其他的操作这里不再做赘述 </p></blockquote><h1 id="相关技术支持与使用"><a href="#相关技术支持与使用" class="headerlink" title="相关技术支持与使用"></a>相关技术支持与使用</h1><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p>Sublime Text：用于编辑代码，修改配置文件等</p><p>Typora：作为markdown编辑器，用于写文章</p><p>PicGo：图片上传工具，配合github作为图床</p><p>Snipaste：截图工具</p><p>git：hexo部署，上传</p><h2 id="技术支持"><a href="#技术支持" class="headerlink" title="技术支持"></a>技术支持</h2><p>github page：用于托管网站</p><p>github仓库：搭建图床</p><p>jsdlivr：图床cdn加速</p><p>netlify：整个网站托管，cdn加速</p><h1 id="美化优化"><a href="#美化优化" class="headerlink" title="美化优化"></a>美化优化</h1><h2 id="主题CSS样式配置"><a href="#主题CSS样式配置" class="headerlink" title="主题CSS样式配置"></a>主题CSS样式配置</h2><p>全局css样式配置，导航栏颜色渐变， 让博客网站具有独特的外观和风格 </p><h2 id="首页轮播图渐变更新"><a href="#首页轮播图渐变更新" class="headerlink" title="首页轮播图渐变更新"></a>首页轮播图渐变更新</h2><p>轮播图通过渐变更新的方式，可以展示多个精选文章或特色内容，让读者快速了解网站的亮点 </p><h2 id="不蒜子计数"><a href="#不蒜子计数" class="headerlink" title="不蒜子计数"></a>不蒜子计数</h2><p> 实时显示每篇文章的访问数量，网站浏览量，访问人数，提供数据参考和反馈 </p><h2 id="动态线条构建"><a href="#动态线条构建" class="headerlink" title="动态线条构建"></a>动态线条构建</h2><p>背景涌动线条，增加网站的动感和现代感 </p><h2 id="添加看板娘"><a href="#添加看板娘" class="headerlink" title="添加看板娘"></a>添加看板娘</h2><p> 增加博客网站的趣味性和人情味，眼部追随鼠标点击方向</p><h2 id="护眼模式昼夜转换"><a href="#护眼模式昼夜转换" class="headerlink" title="护眼模式昼夜转换"></a>护眼模式昼夜转换</h2><p> 添加夜间与白天模式切换功能 ， 可以根据自己的喜好选择合适的页面背景和文本颜色 </p><h2 id="天气插件"><a href="#天气插件" class="headerlink" title="天气插件"></a>天气插件</h2><p> 添加一个天气插件，显示当前的天气信息，可以方便地查看天气情况，为未来的出行或活动做准备 </p><h2 id="导航栏功能增加"><a href="#导航栏功能增加" class="headerlink" title="导航栏功能增加"></a>导航栏功能增加</h2><p>添加极客导航一栏，实现链接跳转，从静态网站跳转到个人可以方便更新，方便交互，且分类清晰的“库”，这是个人巧妙利用了其它可开源的记录软件结合，让博客有更好的资源收集跳转地，也方便读者寻找我所收集的资源</p><h2 id="每日60秒读懂世界"><a href="#每日60秒读懂世界" class="headerlink" title="每日60秒读懂世界"></a>每日60秒读懂世界</h2><p> 增加博客网站的独特性和更新频率，通过调用api，每天更新15则新闻和一条微语， 读者在短时间内获取有价值的知识和信息 </p><h2 id="文章右侧目录联动"><a href="#文章右侧目录联动" class="headerlink" title="文章右侧目录联动"></a>文章右侧目录联动</h2><p>文章旁侧的目录导航，可进度拖动</p><h2 id="全局滚动条更改"><a href="#全局滚动条更改" class="headerlink" title="全局滚动条更改"></a>全局滚动条更改</h2><p>更改滚动条样式美化</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>Hexo博客的搭建，是一点点优化起来的，Hexo 的灵活性较高，可以自定义主题、布局和功能，满足更多定制化需求。根据自己的喜好，打造一个自己喜欢的网站作品，这不断优化的期间，让自己收获不少；</p><p>个人博客网站，是一个属于自己的天地，乐在其中<del>~</del></p>]]></content>
      
      
      <categories>
          
          <category> 生活记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活记录 </tag>
            
            <tag> 分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>samba服务器搭建配置与连接公网</title>
      <link href="/2023/07/05/samba/"/>
      <url>/2023/07/05/samba/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>本文将呈现 ： 1.samba服务的相关背景与原理  2.samba服务的搭建与配置（针对内网）  3.配置win10连接公网ip连接samba服务（针对公网）</p><p>之前服务器于搭建chatgpt的微信机器人后，闲暇之余想做个文件服务器，选择了samba做文件共享，轻松搞定于局域网共享，但由于要给远方的朋友也使用，便有了让远方朋友连接公网ip的samba服务器，由于考虑到端口问题，比如445端口（注释），所以得突破这个点，后面有了一个思路，便是通过 netsh来设置端口映射</p><blockquote><p>注释！</p><p>samba是默认使用445端口进行通信，且服务针对windows， windows 默认连的是 445 端口 </p><p>2017年5月，出现了永恒之蓝病毒（比特币勒索病毒）， 永恒之蓝（EternalBlue）是一种利用Windows操作系统中的漏洞进行攻击的网络蠕虫病毒。它最初由美国国家安全局（NSA）开发，在泄露后被黑客组织使用，给全球范围内的计算机系统带来了严重的影响。  由此导致运营商（内地三大运营服务商）把 445 端口封了，因此现在无法通过 445 端口连接你的 linux 服务器了</p></blockquote><h1 id="1-samba服务简介"><a href="#1-samba服务简介" class="headerlink" title="1.samba服务简介"></a>1.samba服务简介</h1><h2 id="1-1什么是samba服务"><a href="#1-1什么是samba服务" class="headerlink" title="1.1什么是samba服务"></a>1.1什么是samba服务</h2><p> Samba是一个能让Linux系统应用Microsoft网络通讯协议的软件，而SMB是<strong>Server Message Block</strong>的缩写，即为服务器消息块 ，SMB主要是作为Microsoft的网络通讯协议，后来Samba将SMB通信协议应用到了Linux系统上，就形成了现在的Samba软件；Samba提供了一种在不同操作系统之间共享文件、打印机和其他资源的方法。它的本质是一个实现了SMB/CIFS协议的服务器软件，允许不同操作系统的计算机之间进行文件共享和通信。</p><h2 id="1-2samba服务的应用"><a href="#1-2samba服务的应用" class="headerlink" title="1.2samba服务的应用"></a>1.2samba服务的应用</h2><p><strong>Samba能做什么？</strong></p><ul><li><p>分享档案与打印机服务</p></li><li><p>可以提供用户登入Samba主机时的身份认证，以提供不同身份者的个别数据。</p></li><li><p>可以进行windows网络上的主机名解析</p></li><li><p>可以进行装置的分享</p><p><strong>Samba服务器的应用实例：</strong></p></li><li><p>利用软件直接编修WWW主机上面的网页数据</p><ul><li>用FTP修改，后上传；不方便，很有可能传上去旧版本的。</li><li>在线修改比较能迅速看到结果。</li></ul></li><li><p>做成可直接联机的文件服务器</p><ul><li>因为每个人登陆的账户名不同，这样对目录的权限也不同，实现权限控制。</li></ul></li></ul><h1 id="2-samba服务器的搭建（内网）"><a href="#2-samba服务器的搭建（内网）" class="headerlink" title="2.samba服务器的搭建（内网）"></a>2.samba服务器的搭建（内网）</h1><h2 id="第一步：安装samba服务"><a href="#第一步：安装samba服务" class="headerlink" title="第一步：安装samba服务"></a>第一步：安装samba服务</h2><pre class=" language-linux"><code class="language-linux">yum -y install samba*    ## 安装samba服务systemctl start smb      ## 启动服务systemctl enable smb    ##让系统在引导时自动启动 Samba 服务firewall-cmd --permanent --add-service=samba## 防火墙添加 Samba 服务的规则，允许传入和传出与 Samba 相关的网络流量，--permanent 参数表示将规则永久保存，以便在系统重启后仍然有效firewall-cmd --reload   ## 有permanent参数的时候需要马上重载生效getenforce ## 获取 SELinux 当前的执行模式，此时为permissive模式便可，否则使用命令：setenforce 0          ## Enforcing：表示 SELinux 正在强制执行安全策略，并且会拒绝违反策略的操作。          ## Permissive：表示 SELinux 已被启用，但仅会记录违反策略的操作而不阻止它们。          ## Disabled：表示 SELinux 已被禁用，不会对系统进行强制访问控制。</code></pre><h2 id="第二步：Samba服务的配置"><a href="#第二步：Samba服务的配置" class="headerlink" title="第二步：Samba服务的配置"></a>第二步：Samba服务的配置</h2><p> Samba服务的主要配置文件为：/etc/sambs/smb.conf , 主配置文件由两部分构成：Global 部分和 Share 部分</p><h3 id="1-global部分："><a href="#1-global部分：" class="headerlink" title="1.global部分："></a>1.global部分：</h3><p>该设置都是与Samba服务整体运行环境有关的选项，它的设置项目是针对所有共享资源的</p><pre><code>cat /etc/samba/smb.conf  # 查看配置文件内容# 文件内容如下,更详细的smb.conf配置内容可以上网查找，这里做部分注释# See smb.conf.example for a more detailed config file or# read the smb.conf manpage.# Run &#39;testparm&#39; to verify the config is correct after# you modified it.[global] #全局参数：该设置都是与Samba服务整体运行环境有关的选项，它的设置项目是针对所有共享资源的        workgroup =MYGROUP           #设定Samba Server所要加入的工作组或域        security = user        #安装验证方式，总共有四种，目前不再支持share级别        passdb backend = tdbsam        #定义用户后台类型，总共有三种        printing = cups        printcap name = cups        load printers = yes        #设置在Samba服务启动时是否共享打印机设备        cups options = raw        #打印机的选项[homes]        comment = Home Directories #描述信息        valid users = %S, %D%w%S  #有效访问用户        path = ~         #文件路径        browseable = No   #指定共享信息是否在“网上邻居”中可见        read only = No    #是否只读        inherit acls = Yes [printers]        comment = All Printers        path = /var/tmp #共享文件的实际路径。        printable = Yes        create mask = 0600        browseable = No[print$]        comment = Printer Drivers        path = /var/lib/samba/drivers        write list = root        create mask = 0664        directory mask = 0775</code></pre><h3 id="2-share部分："><a href="#2-share部分：" class="headerlink" title="2.share部分："></a>2.share部分：</h3><p>该设置针对的是共享目录个别的设置，只对当前的共享资源起作用</p><pre><code>vim /etc/samba/smb.conf## 在文件最后添加以下，此为测试[share]    comment = Share Directories  ## 这个参数提供对共享资源的描述    path=/www/share  ## 指定了要共享的目录路径    public = yes    ## public用来指定该共享是否允许guest账户访问    browseable = yes ## 共享将在网络上可见    writable = yes    ## 设置共享的可写性</code></pre><p>：wq！保存退出</p><p>还有其他参数可自行 选择设置： <strong>valid users = 允许访问该共享的用户</strong> ； <strong>invalid users = 禁止访问该共享的用户</strong> ； <strong>write list = 允许写入该共享的用户</strong> </p><pre><code>systemctl restart smb.service    ## 重启smb服务## 添加Samba用户smbpasswd –a username    ## 设置Samba用户的密码pdbedit –a username        ## 向Samba数据库中添加用户pdbedit -L    ## 查看已注册的Samba用户列表在Windows运行中键入\\Server_IP验证注意：：：第二次连接更换用户需要运行：net  use  *  /d  /y</code></pre><p>到此，服务器配置便完成</p><h1 id="3-samba服务配置连接（公网）"><a href="#3-samba服务配置连接（公网）" class="headerlink" title="3.samba服务配置连接（公网）"></a>3.samba服务配置连接（公网）</h1><p>在引言已经提到，由于永恒之蓝病毒的影响，445端口已封，目前无法通过 445 端口连接你的 linux 服务器了，下面的操作便是利用 netsh 来绕过这个端口，接下来介绍该工具与实现方法</p><h2 id="netsh简介"><a href="#netsh简介" class="headerlink" title="netsh简介"></a>netsh简介</h2><p> <strong>功能：</strong>Netsh是Windows操作系统中的命令行脚本实用工具，用于管理和配置网络功能 </p><p><strong>命令语法：</strong> 命令语法：Netsh命令的基本语法为 netsh <context> <subcontext> command </subcontext></context></p><blockquote><p>想要更多关于特定”netsh”命令及其用法的信息，可以在命令提示符中输入<code>netsh /?</code>或<code>netsh command /?</code>来查看内置帮助系统 </p></blockquote><h2 id="netsh实现本机端口映射"><a href="#netsh实现本机端口映射" class="headerlink" title="netsh实现本机端口映射"></a>netsh实现本机端口映射</h2><blockquote><p>更换原本的445端口 设置本机端口映射到你那台 samba 的 linux 服务器的 1314 端口。最后，你就可以通过<code>\\127.0.0.1</code>访问你的文件共享服务了 </p></blockquote><ol><li><h3 id="配置smb-conf，更改端口，-修改-Samba-主配置文件：-etc-samba-smb-conf-通过参数smb-ports-将-Samba-的端口更改为：1314，然后重启服务"><a href="#配置smb-conf，更改端口，-修改-Samba-主配置文件：-etc-samba-smb-conf-通过参数smb-ports-将-Samba-的端口更改为：1314，然后重启服务" class="headerlink" title="配置smb.conf，更改端口， 修改 Samba 主配置文件：/etc/samba/smb.conf ;通过参数smb ports 将 Samba 的端口更改为：1314，然后重启服务"></a>配置smb.conf，更改端口， 修改 Samba 主配置文件：/etc/samba/smb.conf ;通过参数smb ports 将 Samba 的端口更改为：1314，然后重启服务</h3><pre><code>vim /etc/samba/smb.conf# See smb.conf.example for a more detailed config file or# read the smb.conf manpage.# Run &#39;testparm&#39; to verify the config is correct after# you modified it.[global]        workgroup = SAMBA        security = user        passdb backend = tdbsam        printing = cups        printcap name = cups        load printers = yes        cups options = raw        smb ports = 1314 ## 添加此行systemctl restart smb.service    ## 重启服务## 查看端口[root@miyi_server ~]# netstat -nplt | grep smbtcp        0      0 0.0.0.0:1314            0.0.0.0:*               LISTEN      7528/smbdtcp6       0      0 :::1314                 :::*                    LISTEN      7528/smbdsamba服务配置到此完成</code></pre></li><li><h3 id="配置win10"><a href="#配置win10" class="headerlink" title="配置win10"></a>配置win10</h3><ol><li><p><strong>关闭 windows 的 445 端口</strong> ：</p><pre><code>## 使用cmd命令行关闭，也可通过任务管理器的服务里找到， 445 端口应该是一直被 LanmanServer 占用的，Windows共享服务的显示名称为Server，实际服务名为LanmanServer，为文件共享服务；sc config LanmanServer start= disablednet stop LanmanServer</code></pre></li><li><p><strong>启动 windows 的 ip helper 服务</strong> ：</p><pre><code>## sc config iphlpsvc start= auto用于配置Windows中“IP Helper”服务的启动类型。通过将其设置为“自动”，您将指示Windows在系统启动期间自动启动IP Helper服务，此ip helper用来搞端口转发sc config iphlpsvc start= auto</code></pre></li><li><p><strong>设置 windows 端口转发</strong> ：</p><pre><code>## connectaddress后为公网ip地址，运行后无显示，后用netsh interface portproxy add v4tov4 listenport=445 connectaddress=xxx.xx.xxx.xx connectport=1314## 注意：必须重启电脑，且服务器对应开启1314端口## 查看转发的端口:netsh interface portproxy show v4tov4</code></pre><p><img src="https://cdn.jsdelivr.net/gh/Bevis23/blog-pic/%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84.png" alt="端口映射"></p></li><li><p><strong>输入<code>\\127.0.0.1</code>访问服务器文件</strong>：</p><p>同内网一样的用户操作，权限操作，区别就是内网访问是同个同个网段的ip访问，而这个是通过访问 本地回环地址 ， 通过监听的本地端口号 ， 进行端口转发，将传入的连接从本地计算机的445端口转发到指定的目标 IP 地址和端口号 </p></li></ol></li></ol><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>samba服务的内外网连接到此为止，对于内网上的samba是相当方便的，对于公网上的连接，有这样的一个思路和方法，同样也算不错的； </p><p>结束之余，也想到了用内网穿透的方法，这里没去实现，顺带提一下</p><h2 id="内网穿透"><a href="#内网穿透" class="headerlink" title="内网穿透"></a>内网穿透</h2><p>内网穿透一般的步骤和方法：</p><ol><li>配置Samba服务器：首先，您需要在本地网络中配置并启动Samba服务器。确保Samba服务器已正确设置并具有共享文件夹。</li><li>选择内网穿透工具：选择一个适合您需求的内网穿透工具。常用的内网穿透工具包括ngrok、frp、inlets等。这些工具允许您创建一个隧道，将公网请求转发到本地网络。</li><li>下载和配置内网穿透工具：根据您选择的工具，下载并安装相应的软件。按照工具提供的说明进行配置，将本地Samba服务器的端口映射到公网IP上。</li><li>启动内网穿透服务：运行内网穿透工具并启动隧道服务。该服务会为您生成一个公网可访问的地址，将流量转发到本地Samba服务器。</li><li>访问Samba服务器：使用生成的公网地址，您就可以从任何具有互联网连接的设备上访问Samba服务器了。只需将生成的地址输入到Samba客户端中，即可连接到Samba服务器并访问共享文件夹。</li></ol><p>使用内网穿透技术会涉及到网络安全方面的问题。确保已经采取了必要的安全措施，如设置强密码、使用加密连接等，以保护的Samba服务器和数据的安全性。</p><p>   记录<del>~</del>收工</p>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 技术分享 </tag>
            
            <tag> 服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>宝塔面板-简化服务器管理与部署的利器</title>
      <link href="/2023/07/02/bao-ta/"/>
      <url>/2023/07/02/bao-ta/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p> 在当今数字化时代，拥有一个稳定高效的服务器以及能够轻松管理和部署应用程序的能力对于个人用户和小型企业来说至关重要。然而，服务器管理和应用程序部署常常需要专业知识和复杂的操作步骤，给非技术背景的用户带来了挑战。正是为了解决这一问题，宝塔面板应运而生。宝塔面板以其简单易用、功能强大的特点，成为了许多人理想的选择。 </p><h1 id="宝塔简介"><a href="#宝塔简介" class="headerlink" title="宝塔简介"></a>宝塔简介</h1><p> 宝塔面板是一款服务器管理软件，可以帮助用户建立网站，一键配置服务器环境，使得用户通过web界面就可以轻松的管理安装所用的服务器软件。  </p><!--主要特点和功能：--> <ol><li>简单易用：宝塔提供直观的Web界面，使服务器管理变得简单易用，即使对于没有专业技术知识的用户也能轻松上手。</li><li>多服务器管理：通过宝塔，您可以同时管理多个服务器，包括虚拟私有服务器（VPS）、独立服务器等，无需登录到每个服务器进行管理。</li><li>网站管理：宝塔支持快速创建、删除、备份和恢复网站，还可以管理域名、SSL证书、FTP账号等。</li><li>数据库管理：宝塔提供MySQL、Redis、MongoDB等常用数据库的管理功能，可以方便地创建数据库、导入导出数据、管理用户等。</li><li>文件管理：通过宝塔的文件管理器，您可以在Web界面中直接管理服务器上的文件和目录，进行上传、下载、编辑等操作。</li><li>应用程序部署：宝塔支持一键安装各种流行的Web应用程序，如WordPress、Joomla、Discuz等，让您能够快速搭建网站。</li><li>监控和统计：宝塔提供实时的服务器资源监控和统计数据，包括CPU、内存、磁盘使用情况等，方便您了解服务器的运行状态。</li><li>安全性：宝塔内置了防火墙、安全加固等功能，可以提高服务器的安全性，减少潜在的风险。</li></ol><h1 id="宝塔的安装"><a href="#宝塔的安装" class="headerlink" title="宝塔的安装"></a>宝塔的安装</h1><p> <strong>宝塔官网地址：<a href="https://www.bt.cn/new/index.html" target="_blank" rel="noopener">https://www.bt.cn/new/index.html</a></strong> </p><p>操作步骤：</p><ol><li><p>访问官网，点击“立即免费安装”</p></li><li><p>点击“安装脚本”</p></li><li><p>根据自己服务器系统，选择对应的脚本，我的服务器部署的是Centos系统，所以我这里选择的是Centos安装脚本</p></li><li><p>复制命令执行命令进行安装</p><pre class=" language-linux"><code class="language-linux">yum install -y wget && wget -O install.sh http://download.bt.cn/install/install_6.0.sh && sh install.sh</code></pre></li><li><p>安裝成功效果图，将端口信息和账号密码等保存记录起来</p><img src="https://cdn.jsdelivr.net/gh/Bevis23/blog-pic/%E9%9D%A2%E6%9D%BF%E5%AE%89%E8%A3%85%E6%88%90%E5%8A%9F.png" style="zoom:50%;"></li><li><p>服务器安全组添加36085端口规则</p><img src="https://cdn.jsdelivr.net/gh/Bevis23/blog-pic/%E5%AE%9D%E5%A1%94%E7%AB%AF%E5%8F%A3%E6%B7%BB%E5%8A%A0.png" style="zoom:50%;"></li></ol><h1 id="宝塔面板的使用"><a href="#宝塔面板的使用" class="headerlink" title="宝塔面板的使用"></a>宝塔面板的使用</h1><ol><li><h2 id="登录宝塔面板"><a href="#登录宝塔面板" class="headerlink" title="登录宝塔面板"></a>登录宝塔面板</h2><ol><li>在浏览器地址栏中输入所记录的外网面板地址，例如：<a href="http://ip：端口号/面板值" target="_blank" rel="noopener">http://ip：端口号/面板值</a></li><li>出现登录界面：输入刚才记录的账号和密码，点击“登录”</li><li>勾选“我已阅读并同意‘用户协议’”</li><li>绑定宝塔账号： 第一次登录需要绑定宝塔账号，要是有宝塔账号的直接登录就可以，没有的话就先去注册一个再进行登录 </li></ol></li><li><h2 id="安装环境套件"><a href="#安装环境套件" class="headerlink" title="安装环境套件"></a>安装环境套件</h2><ol><li>首次使用宝塔面板推荐安装一组套件，对于刚接触Linux环境部署的博友们，推荐使用<em>LNMP</em>，采用极速安装、一键安装的方式 <!-- LNMP和LAMP环境主要的区别在于web服务器上面，LNMP使用的是Nginx服务器，而LAMP使用的是Apache服务器。Nginx 性能稳定、功能丰富、运维简单、处理静态文件速度快且消耗系统资源极少。 --></li></ol></li><li><h2 id="宝塔面板首页介绍"><a href="#宝塔面板首页介绍" class="headerlink" title="宝塔面板首页介绍"></a>宝塔面板首页介绍</h2><p><img src="https://cdn.jsdelivr.net/gh/Bevis23/blog-pic/%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF%E4%BB%8B%E7%BB%8D.png" alt></p><ol><li>系统操作<br>显示当前服务器系统类型、服务器运行时间、面板版本、面板升级更新入口、并提供宝塔账号绑定、微信小程序绑定、服务器重启、面板重启、修复面板等快捷功能。</li><li>服务器状态<br>显示当前服务器CPU、内存、硬盘的使用率、内存清理，所有状态均取自服务器真实数据。<br>内存的清理：点击内存图标中的小火箭图标，即可实现清理功能。</li><li>站点信息<br>显示当前面板管理的站点、FTP、数据库数量，仅提供数量显示，如需添加站点，请在网站选项中添加站点。</li><li>软件管理<br>首页软件快速方式，可以实现拖动图片，更换顺序、管理软件等功能。</li><li>网络流量<br>实时显示当前服务器网络流量的上传和下载速度，总上传流量，总下载流量。<br>注：当前网络流量数据，直接取自网卡数据，包含内外网流量。</li></ol></li></ol><p>   到此为止宝塔面板便安装成功，使用的话针对各自需求来做， 宝塔面板作为一款简化服务器管理和应用程序部署的利器，具有诸多优势。它提供了直观的Web界面，使得服务器管理变得简单~ </p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>   总之，宝塔作为一款强大而全面的服务器管理面板软件，为用户提供了简化服务器管理和网站运维的便利。无论是初学者还是有经验的开发人员，都可以通过宝塔轻松地搭建、配置和管理自己的服务器和网站。它提供了丰富的功能，包括网站管理、数据库管理、文件管理、应用管理、服务器监控、安全设置和DNS管理等。通过宝塔，您可以更加高效地管理和维护您的服务器和网站，节省时间和精力，使您能够专注于更重要的任务和项目。无论是个人网站、企业网站还是开发团队，宝塔都是一个值得推荐和使用的优秀工具。 让它成为你提高效率的工具吧<del>~</del></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 工具 </tag>
            
            <tag> 服务器 </tag>
            
            <tag> 可视化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>chatgpt-prompt工程</title>
      <link href="/2023/06/29/chatgpt-prompt-gong-cheng/"/>
      <url>/2023/06/29/chatgpt-prompt-gong-cheng/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>​        在人工智能技术的不断发展中，chatgpt 这一强大的聊天机器人应运而生 ；强大的AI模型，在聊天对话中，展示的能力有目共睹；在大家都享用AI带来的某些便利的时候，心细的人已经发现了一个问题——AI对于不同的提问，给出的回答，存在着一些差距；因此，提示词（prompt）的重要性便显现出来了；</p><p>​         本文将探讨如何充分利用 prompt 的力量，旨在帮助读者更好地与 GPT 进行互动。我们将介绍一些有效的 prompt 设计策略，并分享一些提示和技巧，使您能够通过巧妙构建 prompt 的方式，获得令人满意的回答和交流结果。 </p><!--注：本文根据开源文章，结合吴恩达prompt工程公开课总结，右边目录栏快速选择需要的内容--><blockquote><p>在我的导航栏里的AI板块，可以详见更多AI有关的知识；  针对prompt提示工程，有吴恩达的提示词公开课总结</p></blockquote><h1 id="Prompt-工程技术简介"><a href="#Prompt-工程技术简介" class="headerlink" title="Prompt 工程技术简介"></a>Prompt 工程技术简介</h1><h2 id="什么是-Prompt-工程？"><a href="#什么是-Prompt-工程？" class="headerlink" title="什么是 Prompt 工程？"></a>什么是 Prompt 工程？</h2><p> Prompt 工程是创建提示或指导像 ChatGPT 这样的语言模型输出的过程。它允许用户控制模型的输出并生成符合其特定需求的文本 </p><h2 id="prompt组成元素"><a href="#prompt组成元素" class="headerlink" title="prompt组成元素"></a>prompt组成元素</h2><ul><li>任务：对提示要求模型生成的内容进行清晰而简洁的陈述。</li><li>指令：在生成文本时模型应遵循的指令。</li><li>角色：模型在生成文本时应扮演的角色。</li></ul><h2 id="prompt原则"><a href="#prompt原则" class="headerlink" title="prompt原则"></a>prompt原则</h2><pre><code>​​Principles of PromptingPrinciple1——Write clear and specific instructionsPrinciple 2——Give the model time to think原则一：写清楚清晰和具体结构的指令策略1：使用分隔符Triple quotes:&quot;&quot;&quot;Triple backticks:&#39;&#39;&#39;Triple dashes:---Angle brackets:&lt; &gt;XML tags:策略2：要求结构化输出HTML、JSON策略3：要求模型检查是否满足指令条件 (ifelse)策略4：few-shot 提示给出完成任务的成功例子然后要求模型执行任务；即提供少量示例，如文本风格或语气原则二：给模型足够时间来思考策略1：指定完成任务所需的步骤策略2：指导模型自己尝试解答问题后再对需要决策的指令对比判断​​模型的局限性虚假知识:模型给出看似真实实则编造的知识，即“一本正经的胡说八道”解决方案按照两个原则进行提示要求模型找到文本中的任何相关引用要求模型使用引用来回答问题</code></pre><h2 id="prompt的优化迭代"><a href="#prompt的优化迭代" class="headerlink" title="prompt的优化迭代"></a>prompt的优化迭代</h2><pre><code>第一个提示是否有效不里要，重要的是找到最终有效提示的过程  一轮选代的步骤：  1.按照两个提示原则简化第一个提示  2.分析指令不清晰或未给足模型间思考的步骤  3.改进生成新的提示在多个样本上迭代开发测试比较性能‘让我们一步一步思考’——提升回答的逻辑性</code></pre><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p><img src="https://cdn.jsdelivr.net/gh/Bevis23/blog-pic/%E5%BA%94%E7%94%A8.png" alt="应用"></p><h1 id="指令提示技术"><a href="#指令提示技术" class="headerlink" title="指令提示技术"></a>指令提示技术</h1><p> 指令提示技术是通过为模型提供具体指令来引导ChatGPT的输出 ， 确保输出相关和高质量 内容；</p><pre><code>提示公式：“按照以下指示生成[任务]：[指令]”</code></pre><p>示例：</p><h2 id="生成客户服务响应："><a href="#生成客户服务响应：" class="headerlink" title="生成客户服务响应："></a><strong>生成客户服务响应：</strong></h2><ul><li>任务：生成响应客户查询</li><li>指令：响应应该专业且提供准确的信息</li><li>提示公式：“按照以下指示生成专业且准确的客户查询响应：响应应该专业且提供准确的信息。”</li></ul><h2 id="生成法律文件："><a href="#生成法律文件：" class="headerlink" title="生成法律文件："></a><strong>生成法律文件：</strong></h2><ul><li>任务：生成法律文件</li><li>指令：文件应符合相关法律法规</li><li>提示公式：“按照以下指示生成符合相关法律法规的法律文件：文件应符合相关法律法规。”</li></ul><h1 id="角色提示"><a href="#角色提示" class="headerlink" title="角色提示"></a>角色提示</h1><p> 角色提示技术是通过为ChatGPT指定一个特定的角色来引导其输出的一种方式，生成针对特定上下文或受众的文本 </p><pre><code>提示公式：“作为[角色]生成[任务]”</code></pre><p>示例：</p><h2 id="生成客户服务回复："><a href="#生成客户服务回复：" class="headerlink" title="生成客户服务回复："></a><strong>生成客户服务回复：</strong></h2><ul><li>任务：生成对客户查询的回复</li><li>角色：客户服务代表</li><li>提示公式：“作为客户服务代表，生成对客户查询的回复。”</li></ul><h2 id="生成法律文件：-1"><a href="#生成法律文件：-1" class="headerlink" title="生成法律文件："></a><strong>生成法律文件：</strong></h2><ul><li>任务：生成法律文件</li><li>角色：律师</li><li>提示公式：“作为律师，生成法律文件。”</li></ul><h2 id="角色提示技术与指令提示和种子词提示结合使用"><a href="#角色提示技术与指令提示和种子词提示结合使用" class="headerlink" title="角色提示技术与指令提示和种子词提示结合使用"></a>角色提示技术与指令提示和种子词提示结合使用</h2><p><strong>下面是一个示例，展示了如何将指令提示、角色提示和种子词提示技术结合使用：</strong></p><ul><li>任务：为新智能手机生成产品描述</li><li>指令：描述应该是有信息量的，具有说服力，并突出智能手机的独特功能</li><li>角色：市场代表 种子词：“创新的”</li><li>提示公式：“作为市场代表，生成一个有信息量的、有说服力的产品描述，突出新智能手机的创新功能。该智能手机具有以下功能[插入您的功能]”</li></ul><p>结合使用可以增强ChatGPT的输出 </p><h1 id="标准提示"><a href="#标准提示" class="headerlink" title="标准提示"></a>标准提示</h1><p> 标准提示是一种简单的方法，通过为模型提供一个特定的任务来引导ChatGPT的输出；</p><pre><code>提示公式：“生成一个[任务]”</code></pre><p>例如：</p><h2 id="生成新闻文章的摘要："><a href="#生成新闻文章的摘要：" class="headerlink" title="生成新闻文章的摘要："></a><strong>生成新闻文章的摘要：</strong></h2><ul><li>任务：总结这篇新闻文章</li><li>提示公式：“生成这篇新闻文章的摘要”</li></ul><h2 id="生成一篇产品评论："><a href="#生成一篇产品评论：" class="headerlink" title="生成一篇产品评论："></a><strong>生成一篇产品评论：</strong></h2><ul><li>任务：为一款新智能手机撰写评论</li><li>提示公式：“生成这款新智能手机的评论”</li></ul><h2 id="将标准提示、角色提示和种子词提示技术结合使用的示例："><a href="#将标准提示、角色提示和种子词提示技术结合使用的示例：" class="headerlink" title="将标准提示、角色提示和种子词提示技术结合使用的示例："></a><strong>将标准提示、角色提示和种子词提示技术结合使用的示例：</strong></h2><ul><li>任务：为一台新笔记本电脑撰写产品评论</li><li>说明：评论应客观、信息丰富，强调笔记本电脑的独特特点</li><li>角色：技术专家</li><li>种子词：“强大的”</li><li>提示公式：“作为一名技术专家，生成一个客观而且信息丰富的产品评论，强调新笔记本电脑的强大特点。”</li></ul><h1 id="零、一和少样本提示"><a href="#零、一和少样本提示" class="headerlink" title="零、一和少样本提示"></a>零、一和少样本提示</h1><p>零样本、一样本和少样本提示是用于从ChatGPT生成文本的技术，最少或没有任何示例。当特定任务的数据有限或任务是新的且未定义时，这些技术非常有用。</p><p>当任务没有可用的示例时，使用零样本提示技术。模型提供一个通用任务，根据对任务的理解生成文本。</p><p>当任务只有一个示例可用时，使用一样本提示技术。模型提供示例，并根据对示例的理解生成文本。</p><p>当任务只有有限数量的示例可用时，使用少样本提示技术。模型提供示例，并根据对示例的理解生成文本。</p><pre><code>提示公式：“基于[数量]个示例生成文本”</code></pre><p>例如：</p><h2 id="为没有可用示例的新产品编写产品描述："><a href="#为没有可用示例的新产品编写产品描述：" class="headerlink" title="为没有可用示例的新产品编写产品描述："></a><strong>为没有可用示例的新产品编写产品描述：</strong></h2><ul><li>任务：为新的智能手表编写产品描述</li><li>提示公式：“基于零个示例为这款新智能手表生成产品描述”</li></ul><h2 id="使用一个示例生成产品比较："><a href="#使用一个示例生成产品比较：" class="headerlink" title="使用一个示例生成产品比较："></a><strong>使用一个示例生成产品比较：</strong></h2><ul><li>任务：将新款智能手机与最新的iPhone进行比较</li><li>提示公式：“使用一个示例（最新的iPhone）为这款新智能手机生成产品比较”</li></ul><h2 id="使用少量示例生成产品评论："><a href="#使用少量示例生成产品评论：" class="headerlink" title="使用少量示例生成产品评论："></a><strong>使用少量示例生成产品评论：</strong></h2><ul><li>任务：为新的电子阅读器撰写评论</li><li>提示公式：“使用少量示例（3个其他电子阅读器）为这款新电子阅读器生成评论”</li></ul><h1 id="“让我们思考一下”提示"><a href="#“让我们思考一下”提示" class="headerlink" title="“让我们思考一下”提示"></a>“让我们思考一下”提示</h1><p> “让我们思考一下”提示是一种技巧，可鼓励ChatGPT生成反思和思考性的文本。这种技术适用于撰写论文、诗歌或创意写作等任务 。</p><p>例如：</p><h2 id="生成一篇反思性论文："><a href="#生成一篇反思性论文：" class="headerlink" title="生成一篇反思性论文："></a><strong>生成一篇反思性论文：</strong></h2><ul><li>任务：就个人成长主题写一篇反思性论文</li><li>提示公式：“让我们思考一下：个人成长”</li></ul><h2 id="生成一首诗："><a href="#生成一首诗：" class="headerlink" title="生成一首诗："></a><strong>生成一首诗：</strong></h2><ul><li>任务：写一首关于季节变化的诗</li><li>提示公式：“让我们思考一下：季节变化”</li></ul><p>这个提示要求对特定主题或想法展开对话或讨论。发言者邀请ChatGPT参与讨论相关主题。</p><p>模型提供了一个提示，作为对话或文本生成的起点。</p><p><strong>要使用“让我们思考一下提示”技术与ChatGPT，您可以遵循以下步骤：</strong></p><ol><li>确定您要讨论的主题或想法。</li><li>制定一个明确表达主题或想法的提示，并开始对话或文本生成。</li><li>用“让我们思考”或“让我们讨论”开头的提示，表明您正在启动对话或讨论。</li></ol><p><strong>以下是使用此技术的一些提示示例：</strong></p><ul><li>提示：“让我们思考气候变化对农业的影响”</li><li>提示：“让我们讨论人工智能的当前状态”</li><li>提示：“让我们谈谈远程工作的好处和缺点” 您还可以添加开放式问题、陈述或一段您希望模型继续或扩展的文本。</li></ul><p>提供提示后，模型将使用其训练数据和算法生成与提示相关的响应，并以连贯的方式继续对话。</p><p>这种独特的提示有助于ChatGPT以不同的视角和角度给出答案，从而产生更具动态性和信息性的段落。</p><h1 id="自洽提示"><a href="#自洽提示" class="headerlink" title="自洽提示"></a>自洽提示</h1><p> 自洽提示是一种技术，用于确保ChatGPT的输出与提供的输入一致。这种技术对于事实核查、数据验证或文本生成中的一致性检查等任务非常有用。 </p><h2 id="示例1：文本生成"><a href="#示例1：文本生成" class="headerlink" title="示例1：文本生成"></a><strong>示例1：文本生成</strong></h2><ul><li>任务：生成产品评论</li><li>指令：评论应与输入中提供的产品信息一致</li><li>提示公式：“生成与以下产品信息一致的产品评论[插入产品信息]”</li></ul><h2 id="示例2：文本摘要"><a href="#示例2：文本摘要" class="headerlink" title="示例2：文本摘要"></a><strong>示例2：文本摘要</strong></h2><ul><li>任务：概括一篇新闻文章</li><li>指令：摘要应与文章中提供的信息一致</li><li>提示公式：“用与提供的信息一致的方式概括以下新闻文章[插入新闻文章]”</li></ul><h2 id="示例3：文本完成"><a href="#示例3：文本完成" class="headerlink" title="示例3：文本完成"></a><strong>示例3：文本完成</strong></h2><ul><li>任务：完成一个句子</li><li>指令：完成应与输入中提供的上下文一致</li><li>提示公式：“以与提供的上下文一致的方式完成以下句子[插入句子]”</li></ul><h2 id="示例4：事实核查与数据验证"><a href="#示例4：事实核查与数据验证" class="headerlink" title="示例4：事实核查与数据验证"></a><strong>示例4：</strong>事实核查与数据验证</h2><ol><li><p><strong>事实核查：</strong></p><p>任务：检查给定新闻文章的一致性</p><p>输入文本：“文章中陈述该城市的人口为500万，但后来又说该城市的人口为700万。”</p><p>提示公式：“请确保以下文本是自洽的：文章中陈述该城市的人口为500万，但后来又说该城市的人口为700万。”</p></li><li><p><strong>数据验证：</strong></p><p>任务：检查给定数据集的一致性</p><p>输入文本：“数据显示7月份的平均温度为30度，但最低温度记录为20度。”</p><p>提示公式：“请确保以下文本是自洽的：数据显示7月份的平均温度为30度，但最低温度记录为20度。”</p></li></ol><h1 id="种子词提示"><a href="#种子词提示" class="headerlink" title="种子词提示"></a>种子词提示</h1><p> 种子词提示是一种通过提供特定的种子词或短语来控制ChatGPT输出的技术。种子词提示的提示公式是种子词或短语，后跟指令“请根据以下种子词生成文本”。 </p><p>示例：</p><h2 id="文本生成："><a href="#文本生成：" class="headerlink" title="文本生成："></a><strong>文本生成：</strong></h2><ul><li>任务：编写一篇有关龙的故事</li><li>种子词：“龙”</li><li>提示公式：“请根据以下种子词生成文本：龙”</li></ul><h2 id="语言翻译："><a href="#语言翻译：" class="headerlink" title="语言翻译："></a><strong>语言翻译：</strong></h2><ul><li>任务：将一句话从英语翻译成西班牙语</li><li>种子词：“你好”</li><li>提示公式：“请根据以下种子词生成文本：你好”</li></ul><h2 id="种子词提示可以与角色提示和指令提示相结合"><a href="#种子词提示可以与角色提示和指令提示相结合" class="headerlink" title="种子词提示可以与角色提示和指令提示相结合"></a>种子词提示可以与角色提示和指令提示相结合</h2><h2 id="示例1：文本生成-1"><a href="#示例1：文本生成-1" class="headerlink" title="示例1：文本生成"></a><strong>示例1：文本生成</strong></h2><ul><li>任务：编写一首诗</li><li>指令：诗应与种子词“爱”相关，并以十四行诗的形式书写。</li><li>角色：诗人</li><li>提示公式：“作为诗人，根据以下种子词生成与“爱”相关的十四行诗：”</li></ul><h2 id="示例2：文本完成"><a href="#示例2：文本完成" class="headerlink" title="示例2：文本完成"></a><strong>示例2：文本完成</strong></h2><ul><li>任务：完成一句话</li><li>指令：完成应与种子词“科学”相关，并以研究论文的形式书写。</li><li>角色：研究员</li><li>提示公式：“作为研究员，请在与种子词“科学”相关且以研究论文的形式书写的情况下完成以下句子：[插入句子]”</li></ul><h2 id="示例3：文本摘要"><a href="#示例3：文本摘要" class="headerlink" title="示例3：文本摘要"></a><strong>示例3：文本摘要</strong></h2><ul><li>任务：摘要一篇新闻文章</li><li>指令：摘要应与种子词“政治”相关，并以中立和公正的语气书写。</li><li>角色：记者</li><li>提示公式：“作为记者，请以中立和公正的语气摘要以下新闻文章，与种子词“政治”相关：[插入新闻文章]”</li></ul><h1 id="知识生成提示"><a href="#知识生成提示" class="headerlink" title="知识生成提示"></a>知识生成提示</h1><p> 知识生成提示是一种从ChatGPT中引出新的、原创的信息的技术。</p><h2 id="示例1：知识生成"><a href="#示例1：知识生成" class="headerlink" title="示例1：知识生成"></a><strong>示例1：知识生成</strong></h2><ul><li>任务：生成有关特定主题的新信息</li><li>说明：生成的信息应准确且与主题相关</li><li>提示公式：“生成有关[特定主题]的新的准确信息”</li></ul><h2 id="示例2：问答"><a href="#示例2：问答" class="headerlink" title="示例2：问答"></a><strong>示例2：问答</strong></h2><ul><li>任务：回答问题</li><li>说明：答案应准确且与问题相关</li><li>提示公式：“回答以下问题：[插入问题]”</li></ul><h2 id="示例3：知识整合"><a href="#示例3：知识整合" class="headerlink" title="示例3：知识整合"></a><strong>示例3：知识整合</strong></h2><ul><li>任务：将新信息与现有知识整合</li><li>说明：整合应准确且与主题相关</li><li>提示公式：“将以下信息与有关[特定主题]的现有知识整合：[插入新信息]”</li></ul><h2 id="示例4：数据分析"><a href="#示例4：数据分析" class="headerlink" title="示例4：数据分析"></a><strong>示例4：数据分析</strong></h2><ul><li>任务：从给定的数据集中生成有关客户行为的见解</li><li>提示公式：“请从这个数据集中生成有关客户行为的新的和原创的信息”</li></ul><h1 id="知识整合提示"><a href="#知识整合提示" class="headerlink" title="知识整合提示"></a>知识整合提示</h1><p> 利用模型的现有知识来整合新信息或连接不同的信息片段。 </p><h2 id="如何与ChatGPT一起使用："><a href="#如何与ChatGPT一起使用：" class="headerlink" title="如何与ChatGPT一起使用："></a><strong>如何与ChatGPT一起使用：</strong></h2><ul><li>模型应该提供新信息和现有知识作为输入，以及指定生成文本的任务或目标的提示。</li><li>提示应包括有关所需输出的信息，例如要生成的文本类型以及任何特定的要求或限制。</li></ul><h2 id="示例1：知识整合"><a href="#示例1：知识整合" class="headerlink" title="示例1：知识整合"></a><strong>示例1：知识整合</strong></h2><ul><li>任务：将新信息与现有知识整合</li><li>说明：整合应准确且与主题相关</li><li>提示公式：“将以下信息与关于[具体主题]的现有知识整合：[插入新信息]”</li></ul><h2 id="示例2：连接信息片段"><a href="#示例2：连接信息片段" class="headerlink" title="示例2：连接信息片段"></a><strong>示例2：连接信息片段</strong></h2><ul><li>任务：连接不同的信息片段</li><li>说明：连接应相关且逻辑清晰</li><li>提示公式：“以相关且逻辑清晰的方式连接以下信息片段：[插入信息1] [插入信息2]”</li></ul><h2 id="示例3：更新现有知识"><a href="#示例3：更新现有知识" class="headerlink" title="示例3：更新现有知识"></a><strong>示例3：更新现有知识</strong></h2><ul><li>任务：使用新信息更新现有知识</li><li>说明：更新的信息应准确且相关</li><li>提示公式：“使用以下信息更新[具体主题]的现有知识：[插入新信息]”</li></ul><h1 id="多项选择提示"><a href="#多项选择提示" class="headerlink" title="多项选择提示"></a>多项选择提示</h1><p> 技术向模型提供一个问题或任务以及一组预定义的选项作为潜在答案。</p><h2 id="示例1：问答"><a href="#示例1：问答" class="headerlink" title="示例1：问答"></a><strong>示例1：问答</strong></h2><ul><li>任务：回答一个多项选择题</li><li>说明：答案应该是预定义的选项之一</li><li>提示公式：“通过选择以下选项之一回答以下问题：[插入问题] [插入选项1] [插入选项2] [插入选项3]”</li></ul><h2 id="示例2：文本完成-1"><a href="#示例2：文本完成-1" class="headerlink" title="示例2：文本完成"></a><strong>示例2：文本完成</strong></h2><ul><li>任务：使用预定义选项之一完成句子</li><li>说明：完成应该是预定义的选项之一</li><li>提示公式：“通过选择以下选项之一完成以下句子：[插入句子] [插入选项1] [插入选项2] [插入选项3]”</li></ul><h2 id="示例3：情感分析"><a href="#示例3：情感分析" class="headerlink" title="示例3：情感分析"></a><strong>示例3：情感分析</strong></h2><ul><li>任务：将文本分类为积极、中立或消极</li><li>说明：分类应该是预定义的选项之一</li><li>提示公式：“通过选择以下选项之一，将以下文本分类为积极、中立或消极：[插入文本] [积极] [中立] [消极]”</li></ul><h1 id="可解释的软提示"><a href="#可解释的软提示" class="headerlink" title="可解释的软提示"></a>可解释的软提示</h1><p> 可解释的软提示是一种技术，可以在提供一定的灵活性的同时控制模型生成的文本。它通过提供一组受控输入和关于所需输出的附加信息来实现。这种技术可以生成更具解释性和可控性的生成文本。 </p><h2 id="示例1：文本生成-2"><a href="#示例1：文本生成-2" class="headerlink" title="示例1：文本生成"></a><strong>示例1：文本生成</strong></h2><ul><li>任务：生成一个故事</li><li>指令：故事应基于一组给定的角色和特定的主题</li><li>提示公式：“基于以下角色生成故事：[插入角色]和主题：[插入主题]”</li></ul><h2 id="示例2：文本完成-2"><a href="#示例2：文本完成-2" class="headerlink" title="示例2：文本完成"></a><strong>示例2：文本完成</strong></h2><ul><li>任务：完成一句话</li><li>指令：完成应以特定作者的风格为基础</li><li>提示公式：“以[特定作者]的风格完成以下句子：[插入句子]”</li></ul><h2 id="示例3：语言建模"><a href="#示例3：语言建模" class="headerlink" title="示例3：语言建模"></a><strong>示例3：语言建模</strong></h2><ul><li>任务：以特定风格生成文本</li><li>指令：文本应以特定时期的风格为基础</li><li>提示公式：“以[特定时期]的风格生成文本：[插入上下文]”</li></ul><h1 id="控制生成提示"><a href="#控制生成提示" class="headerlink" title="控制生成提示"></a>控制生成提示</h1><p>控制生成提示是一种技术，可让模型在生成文本时对输出进行高度控制。</p><p>这可以通过提供一组特定的输入来实现，例如模板、特定词汇或一组约束条件，这些输入可用于指导生成过程。</p><h2 id="示例1：文本生成-3"><a href="#示例1：文本生成-3" class="headerlink" title="示例1：文本生成"></a><strong>示例1：文本生成</strong></h2><ul><li>任务：生成一个故事</li><li>说明：该故事应基于特定的模板</li><li>提示公式：“根据以下模板生成故事：[插入模板]”</li></ul><h2 id="示例2：文本补全"><a href="#示例2：文本补全" class="headerlink" title="示例2：文本补全"></a><strong>示例2：文本补全</strong></h2><ul><li>任务：完成一句话</li><li>说明：完成应使用特定的词汇</li><li>提示公式：“使用以下词汇完成以下句子：[插入词汇]：[插入句子]”</li></ul><h2 id="示例3：语言建模-1"><a href="#示例3：语言建模-1" class="headerlink" title="示例3：语言建模"></a><strong>示例3：语言建模</strong></h2><ul><li>任务：以特定风格生成文本</li><li>说明：文本应遵循一组特定的语法规则</li><li>提示公式：“生成遵循以下语法规则的文本：[插入规则]：[插入上下文]”</li></ul><h1 id="问答提示"><a href="#问答提示" class="headerlink" title="问答提示"></a>问答提示</h1><p> 问答提示是一种技术，可以让模型生成回答特定问题或任务的文本。通过将问题或任务与可能与问题或任务相关的任何其他信息一起作为输入提供给模型来实现此目的。 </p><h2 id="示例1：事实问题回答"><a href="#示例1：事实问题回答" class="headerlink" title="示例1：事实问题回答"></a><strong>示例1：事实问题回答</strong></h2><ul><li>任务：回答一个事实性问题</li><li>说明：答案应准确且相关</li><li>提示公式：“回答以下事实问题：[插入问题]”</li></ul><h2 id="示例2：定义"><a href="#示例2：定义" class="headerlink" title="示例2：定义"></a><strong>示例2：定义</strong></h2><ul><li>任务：提供一个词的定义</li><li>说明：定义应准确</li><li>提示公式：“定义以下词汇：[插入单词]”</li></ul><h2 id="示例3：信息检索"><a href="#示例3：信息检索" class="headerlink" title="示例3：信息检索"></a><strong>示例3：信息检索</strong></h2><ul><li>任务：从特定来源检索信息</li><li>说明：检索到的信息应相关</li><li>提示公式：“从以下来源检索有关[特定主题]的信息：[插入来源]” 这对于问答和信息检索等任务非常有用。</li></ul><h1 id="概述提示"><a href="#概述提示" class="headerlink" title="概述提示"></a>概述提示</h1><p> 概述提示是一种技术，允许模型在保留其主要思想和信息的同时生成给定文本的较短版本。 </p><p><strong>如何在ChatGPT中使用：</strong></p><ul><li>应该向模型提供较长的文本作为输入，并要求其生成该文本的摘要。</li><li>提示还应包括有关所需输出的信息，例如摘要的所需长度和任何特定要求或限制。</li></ul><h2 id="示例1：文章概述"><a href="#示例1：文章概述" class="headerlink" title="示例1：文章概述"></a><strong>示例1：文章概述</strong></h2><ul><li>任务：概述新闻文章</li><li>说明：摘要应是文章主要观点的简要概述</li><li>提示公式：“用一句简短的话概括以下新闻文章：[插入文章]”</li></ul><h2 id="示例2：会议记录"><a href="#示例2：会议记录" class="headerlink" title="示例2：会议记录"></a><strong>示例2：会议记录</strong></h2><ul><li>任务：概括会议记录</li><li>说明：摘要应突出会议的主要决策和行动</li><li>提示公式：“通过列出主要决策和行动来总结以下会议记录：[插入记录]”</li></ul><h2 id="示例3：书籍摘要"><a href="#示例3：书籍摘要" class="headerlink" title="示例3：书籍摘要"></a><strong>示例3：书籍摘要</strong></h2><ul><li>任务：总结一本书</li><li>说明：摘要应是书的主要观点的简要概述</li><li>提示公式：“用一段简短的段落总结以下书籍：[插入书名]”</li></ul><h1 id="对话提示"><a href="#对话提示" class="headerlink" title="对话提示"></a>对话提示</h1><p> 对话提示是一种技术，允许模型生成模拟两个或更多实体之间对话的文本。通过为模型提供一个上下文和一组角色或实体，以及它们的角色和背景，并要求模型在它们之间生成对话。 </p><h2 id="示例1：对话生成"><a href="#示例1：对话生成" class="headerlink" title="示例1：对话生成"></a><strong>示例1：对话生成</strong></h2><ul><li>任务：生成两个角色之间的对话</li><li>说明：对话应自然且与给定上下文相关</li><li>提示公式：“在以下情境中生成以下角色之间的对话[插入角色]”</li></ul><h2 id="示例2：故事写作"><a href="#示例2：故事写作" class="headerlink" title="示例2：故事写作"></a><strong>示例2：故事写作</strong></h2><ul><li>任务：在故事中生成对话</li><li>说明：对话应与故事的角色和事件一致</li><li>提示公式：“在以下故事中生成以下角色之间的对话[插入故事]”</li></ul><h2 id="示例3：聊天机器人开发"><a href="#示例3：聊天机器人开发" class="headerlink" title="示例3：聊天机器人开发"></a><strong>示例3：聊天机器人开发</strong></h2><ul><li>任务：为客服聊天机器人生成对话</li><li>说明：对话应专业且提供准确的信息</li><li>提示公式：“在客户询问[插入主题]时，为客服聊天机器人生成专业和准确的对话”</li></ul><h1 id="对抗性提示"><a href="#对抗性提示" class="headerlink" title="对抗性提示"></a>对抗性提示</h1><p> 对抗性提示是一种技术，它允许模型生成抵抗某些类型的攻击或偏见的文本。这种技术可用于训练更为稳健和抵抗某些类型攻击或偏见的模型。 </p><h2 id="示例1：用于文本分类的对抗性提示"><a href="#示例1：用于文本分类的对抗性提示" class="headerlink" title="示例1：用于文本分类的对抗性提示"></a><strong>示例1：用于文本分类的对抗性提示</strong></h2><ul><li>任务：生成被分类为特定标签的文本</li><li>说明：生成的文本应难以分类为特定标签</li><li>提示公式：“生成难以分类为[插入标签]的文本”</li></ul><h2 id="示例2：用于情感分析的对抗性提示"><a href="#示例2：用于情感分析的对抗性提示" class="headerlink" title="示例2：用于情感分析的对抗性提示"></a><strong>示例2：用于情感分析的对抗性提示</strong></h2><ul><li>任务：生成难以分类为特定情感的文本</li><li>说明：生成的文本应难以分类为特定情感</li><li>提示公式：“生成难以分类为具有[插入情感]情感的文本”</li></ul><h2 id="示例3：用于语言翻译的对抗性提示"><a href="#示例3：用于语言翻译的对抗性提示" class="headerlink" title="示例3：用于语言翻译的对抗性提示"></a><strong>示例3：用于语言翻译的对抗性提示</strong></h2><ul><li>任务：生成难以翻译的文本</li><li>说明：生成的文本应难以翻译为目标语言</li><li>提示公式：“生成难以翻译为[插入目标语言]的文本”</li></ul><h1 id="聚类提示"><a href="#聚类提示" class="headerlink" title="聚类提示"></a>聚类提示</h1><p>聚类提示是一种技术，它可以让模型根据某些特征或特点将相似的数据点分组在一起。</p><p>通过提供一组数据点并要求模型根据某些特征或特点将它们分组成簇，可以实现这一目标。 这种技术在数据分析、机器学习和自然语言处理等任务中非常有用。 </p><h2 id="示例1：客户评论的聚类"><a href="#示例1：客户评论的聚类" class="headerlink" title="示例1：客户评论的聚类"></a><strong>示例1：客户评论的聚类</strong></h2><ul><li>任务：将相似的客户评论分组在一起</li><li>说明：应根据情感将评论分组</li><li>提示公式：“将以下客户评论根据情感分组成簇：[插入评论]”</li></ul><h2 id="示例2：新闻文章的聚类"><a href="#示例2：新闻文章的聚类" class="headerlink" title="示例2：新闻文章的聚类"></a><strong>示例2：新闻文章的聚类</strong></h2><ul><li>任务：将相似的新闻文章分组在一起</li><li>说明：应根据主题将文章分组</li><li>提示公式：“将以下新闻文章根据主题分组成簇：[插入文章]”</li></ul><h2 id="示例3：科学论文的聚类"><a href="#示例3：科学论文的聚类" class="headerlink" title="示例3：科学论文的聚类"></a><strong>示例3：科学论文的聚类</strong></h2><ul><li>任务：将相似的科学论文分组在一起</li><li>说明：应根据研究领域将论文分组</li><li>提示公式：“将以下科学论文根据研究领域分组成簇：[插入论文]”</li></ul><h1 id="强化学习提示"><a href="#强化学习提示" class="headerlink" title="强化学习提示"></a>强化学习提示</h1><p> 强化学习提示是一种技术，可以使模型从过去的行动中学习，并随着时间的推移提高其性能。要在ChatGPT中使用强化学习提示，需要为模型提供一组输入和奖励，并允许其根据接收到的奖励调整其行为。提示还应包括有关期望输出的信息，例如要完成的任务以及任何特定要求或限制。这种技术对于决策制定、游戏玩法和自然语言生成等任务非常有用。 </p><h2 id="示例1：用于文本生成的强化学习"><a href="#示例1：用于文本生成的强化学习" class="headerlink" title="示例1：用于文本生成的强化学习"></a><strong>示例1：用于文本生成的强化学习</strong></h2><ul><li>任务：生成与特定风格一致的文本</li><li>说明：模型应根据为生成与特定风格一致的文本而接收到的奖励来调整其行为</li><li>提示公式：“使用强化学习来生成与以下风格一致的文本[插入风格]”</li></ul><h2 id="示例2：用于语言翻译的强化学习"><a href="#示例2：用于语言翻译的强化学习" class="headerlink" title="示例2：用于语言翻译的强化学习"></a><strong>示例2：用于语言翻译的强化学习</strong></h2><ul><li>任务：将文本从一种语言翻译成另一种语言</li><li>说明：模型应根据为生成准确翻译而接收到的奖励来调整其行为</li><li>提示公式：“使用强化学习将以下文本[插入文本]从[插入语言]翻译成[插入语言]”</li></ul><h2 id="示例3：用于问答的强化学习"><a href="#示例3：用于问答的强化学习" class="headerlink" title="示例3：用于问答的强化学习"></a><strong>示例3：用于问答的强化学习</strong></h2><ul><li>任务：回答问题</li><li>说明：模型应根据为生成准确答案而接收到的奖励来调整其行为</li><li>提示公式：“使用强化学习来回答以下问题[插入问题]”</li></ul><h1 id="课程学习提示"><a href="#课程学习提示" class="headerlink" title="课程学习提示"></a>课程学习提示</h1><p>  课程学习是一种技术，允许模型通过先训练简单任务，逐渐增加难度来学习复杂任务。 此技术对自然语言处理、图像识别和机器学习等任务非常有用。 </p><h2 id="示例1：用于文本生成的课程学习"><a href="#示例1：用于文本生成的课程学习" class="headerlink" title="示例1：用于文本生成的课程学习"></a><strong>示例1：用于文本生成的课程学习</strong></h2><ul><li>任务：生成与特定风格一致的文本</li><li>说明：模型应该在移动到更复杂的风格之前先在简单的风格上进行训练。</li><li>提示公式：“使用课程学习来生成与以下风格[插入风格]一致的文本，按照以下顺序[插入顺序]。”</li></ul><h2 id="示例2：用于语言翻译的课程学习"><a href="#示例2：用于语言翻译的课程学习" class="headerlink" title="示例2：用于语言翻译的课程学习"></a><strong>示例2：用于语言翻译的课程学习</strong></h2><ul><li>任务：将文本从一种语言翻译成另一种语言</li><li>说明：模型应该在移动到更复杂的语言之前先在简单的语言上进行训练。</li><li>提示公式：“使用课程学习将以下语言[插入语言]的文本翻译成以下顺序[插入顺序]。”</li></ul><h2 id="示例3：用于问题回答的课程学习"><a href="#示例3：用于问题回答的课程学习" class="headerlink" title="示例3：用于问题回答的课程学习"></a><strong>示例3：用于问题回答的课程学习</strong></h2><ul><li>任务：回答问题</li><li>说明：模型应该在移动到更复杂的问题之前先在简单的问题上进行训练。</li><li>提示公式：“使用课程学习来回答以下问题[插入问题]，按照以下顺序[插入顺序]生成答案。”</li></ul><h1 id="情感分析提示"><a href="#情感分析提示" class="headerlink" title="情感分析提示"></a>情感分析提示</h1><p> 情感分析是一种技术，允许模型确定文本的情绪色彩或态度 ， 提示还应包括关于所需输出的信息，例如要检测的情感类型（例如积极的、消极的、中立的）和任何特定要求或约束条件。 </p><h2 id="示例1：客户评论的情感分析"><a href="#示例1：客户评论的情感分析" class="headerlink" title="示例1：客户评论的情感分析"></a><strong>示例1：客户评论的情感分析</strong></h2><ul><li>任务：确定客户评论的情感</li><li>说明：模型应该将评论分类为积极的、消极的或中立的</li><li>提示公式：“对以下客户评论进行情感分析[插入评论]，并将它们分类为积极的、消极的或中立的。”</li></ul><h2 id="示例2：推文的情感分析"><a href="#示例2：推文的情感分析" class="headerlink" title="示例2：推文的情感分析"></a><strong>示例2：推文的情感分析</strong></h2><ul><li>任务：确定推文的情感</li><li>说明：模型应该将推文分类为积极的、消极的或中立的</li><li>提示公式：“对以下推文进行情感分析[插入推文]，并将它们分类为积极的、消极的或中立的。”</li></ul><h2 id="示例3：产品评论的情感分析"><a href="#示例3：产品评论的情感分析" class="headerlink" title="示例3：产品评论的情感分析"></a><strong>示例3：产品评论的情感分析</strong></h2><ul><li>任务：确定产品评论的情感</li><li>说明：模型应该将评论分类为积极的、消极的或中立的</li><li>提示公式：“对以下产品评论进行情感分析[插入评论]，并将它们分类为积极的、消极的或中立的。”</li></ul><h1 id="命名实体识别提示"><a href="#命名实体识别提示" class="headerlink" title="命名实体识别提示"></a>命名实体识别提示</h1><p> 命名实体识别（NER）是一种技术，它可以使模型识别和分类文本中的命名实体，  提示还应包括有关所需输出的信息，例如要识别的命名实体类型（例如人名、组织机构、地点、日期）以及任何特定要求或约束条件。 </p><h2 id="示例1：新闻文章中的命名实体识别"><a href="#示例1：新闻文章中的命名实体识别" class="headerlink" title="示例1：新闻文章中的命名实体识别"></a><strong>示例1：新闻文章中的命名实体识别</strong></h2><ul><li>任务：在新闻文章中识别和分类命名实体</li><li>说明：模型应识别和分类人名、组织机构、地点和日期</li><li>提示公式：“在以下新闻文章[插入文章]上执行命名实体识别，并识别和分类人名、组织机构、地点和日期。”</li></ul><h2 id="示例2：法律文件中的命名实体识别"><a href="#示例2：法律文件中的命名实体识别" class="headerlink" title="示例2：法律文件中的命名实体识别"></a><strong>示例2：法律文件中的命名实体识别</strong></h2><ul><li>任务：在法律文件中识别和分类命名实体</li><li>说明：模型应识别和分类人名、组织机构、地点和日期</li><li>提示公式：“在以下法律文件[插入文件]上执行命名实体识别，并识别和分类人名、组织机构、地点和日期。”</li></ul><h2 id="示例3：研究论文中的命名实体识别"><a href="#示例3：研究论文中的命名实体识别" class="headerlink" title="示例3：研究论文中的命名实体识别"></a><strong>示例3：研究论文中的命名实体识别</strong></h2><ul><li>任务：在研究论文中识别和分类命名实体</li><li>说明：模型应识别和分类人名、组织机构、地点和日期</li><li>提示公式：“在以下研究论文[插入论文]上执行命名实体识别，并识别和分类人名、组织机构、地点和日期。”</li></ul><h1 id="文本分类提示"><a href="#文本分类提示" class="headerlink" title="文本分类提示"></a>文本分类提示</h1><p> 文本分类是一种技术，它可以让模型将文本分成不同的类别。这种技术对于自然语言处理、文本分析和情感分析等任务非常有用。  要在ChatGPT中使用文本分类提示，模型需要提供一段文本，并要求它根据预定义的类别或标签进行分类。提示还应包括有关所需输出的信息，例如类别或标签的数量以及任何特定的要求或约束。 </p><h2 id="示例1：对客户评论进行文本分类"><a href="#示例1：对客户评论进行文本分类" class="headerlink" title="示例1：对客户评论进行文本分类"></a><strong>示例1：对客户评论进行文本分类</strong></h2><ul><li>任务：将客户评论分类为不同的类别，例如电子产品、服装和家具</li><li>说明：模型应根据评论的内容对其进行分类</li><li>提示公式：“对以下客户评论 [插入评论] 进行文本分类，并根据其内容将其分类为不同的类别，例如电子产品、服装和家具。”</li></ul><h2 id="示例2：对新闻文章进行文本分类"><a href="#示例2：对新闻文章进行文本分类" class="headerlink" title="示例2：对新闻文章进行文本分类"></a><strong>示例2：对新闻文章进行文本分类</strong></h2><ul><li>任务：将新闻文章分类为不同的类别，例如体育、政治和娱乐</li><li>说明：模型应根据文章的内容对其进行分类</li><li>提示公式：“对以下新闻文章 [插入文章] 进行文本分类，并根据其内容将其分类为不同的类别，例如体育、政治和娱乐。”</li></ul><h2 id="示例3：对电子邮件进行文本分类"><a href="#示例3：对电子邮件进行文本分类" class="headerlink" title="示例3：对电子邮件进行文本分类"></a><strong>示例3：对电子邮件进行文本分类</strong></h2><ul><li>任务：将电子邮件分类为不同的类别，例如垃圾邮件、重要邮件或紧急邮件</li><li>说明：模型应根据电子邮件的内容和发件人对其进行分类</li><li>提示公式：“对以下电子邮件 [插入电子邮件] 进行文本分类，并根据其内容和发件人将其分类为不同的类别，例如垃圾邮件、重要邮件或紧急邮件。”</li></ul><h1 id="文本生成提示"><a href="#文本生成提示" class="headerlink" title="文本生成提示"></a>文本生成提示</h1><p> 文本生成提示与本书中提到的其他提示技术相关，例如：零、一、几次提示，受控生成提示，翻译提示，语言建模提示，句子补全提示等。这些提示都与生成文本有关，但它们在生成文本的方式和放置在生成文本上的特定要求或限制方面有所不同。文本生成提示可用于微调预训练模型或训练新模型以执行特定任务。 </p><h2 id="示例1：故事创作的文本生成"><a href="#示例1：故事创作的文本生成" class="headerlink" title="示例1：故事创作的文本生成"></a><strong>示例1：故事创作的文本生成</strong></h2><ul><li>任务：根据给定的提示生成故事</li><li>说明：故事应至少包含1000个单词，并包括一组特定的角色和情节。</li><li>提示公式：“根据以下提示[插入提示]生成一个至少包含1000个单词，包括角色[插入角色]和情节[插入情节]的故事。”</li></ul><h2 id="示例2：语言翻译的文本生成"><a href="#示例2：语言翻译的文本生成" class="headerlink" title="示例2：语言翻译的文本生成"></a><strong>示例2：语言翻译的文本生成</strong></h2><ul><li>任务：将给定的文本翻译成另一种语言</li><li>说明：翻译应准确并符合习惯用语。</li><li>提示公式：“将以下文本[插入文本]翻译成[插入目标语言]，并确保其准确且符合习惯用语。”</li></ul><h2 id="示例3：文本完成的文本生成"><a href="#示例3：文本完成的文本生成" class="headerlink" title="示例3：文本完成的文本生成"></a><strong>示例3：文本完成的文本生成</strong></h2><ul><li>任务：完成给定的文本</li><li>说明：生成的文本应与输入文本连贯一致。</li><li>提示公式：“完成以下文本[插入文本]，并确保其连贯一致且符合输入文本。”</li></ul><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>在本文中，我们探讨了充分利用prompt的力量与聊天机器人进行互动的重要性。通过选择合适的提示词、添加背景知识和约束条件，以及运用多轮对话和上下文引用等技巧，我们可以获得令人满意的回答和交流结果。不断调整和优化prompt是一个持续的过程，通过这些方法，我们能够更好地与聊天机器人互动，探索和发展人工智能技术，为未来的交流带来新的可能性。</p>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
            <tag> chatgpt </tag>
            
            <tag> 人工智能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>社会工程学</title>
      <link href="/2023/06/26/she-hui-gong-cheng-xue/"/>
      <url>/2023/06/26/she-hui-gong-cheng-xue/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="何为社会工程学攻击"><a href="#何为社会工程学攻击" class="headerlink" title="何为社会工程学攻击?"></a>何为社会工程学攻击?</h1><p>社会工程学是一种通过对受害者心理弱点、本能反应、好奇心、信任、贪婪等心理陷阱进行诸如欺骗、伤害等危害手段。</p><p>社工库的形成过程：拖库（黑客入侵有价值的网站，盗取用户数据库）——洗库（清洗数据，并将有价值的用户数据变现交易）——撞库（将得到的数据在其他网站上进行登录测试）——社工库（社工库指整合多个被盗数据库，形成专门用于社工欺诈的多维度海量用户信息）</p><h1 id="多种角度讲解我们的信息是如何泄露"><a href="#多种角度讲解我们的信息是如何泄露" class="headerlink" title="多种角度讲解我们的信息是如何泄露"></a>多种角度讲解我们的信息是如何泄露</h1><h2 id="信息泄露之密码学"><a href="#信息泄露之密码学" class="headerlink" title="信息泄露之密码学"></a>信息泄露之密码学</h2><p> 密码学是信息安全领域的一个重要分支，主要研究如何通过密码算法来保护数据安全性、完整性和机密性。在信息泄露方面，密码学扮演着至关重要的角色，尤其是在密码保护和加密方面 ；</p><p>常用的md5加密：MD5 是一种哈希算法，已被证明存在碰撞攻击， 可以通过特定的攻击手段生成相同的 MD5 值，这意味着 MD5 不再是安全的加密方式。因此，对于安全性要求高的应用场景，不应该使用 MD5 作为加密算法。 </p><p> SHA-256 (Secure Hash Algorithm 256-bit) 是比 MD5 更强大和安全的哈希算法，并且目前还没有被证明存在有效的攻击方法。SHA-256 可以产生一个 256 位长度的哈希值，通常用于数字签名、消息认证、信息摘要等领域 </p><h2 id="信息泄露之whois查询"><a href="#信息泄露之whois查询" class="headerlink" title="信息泄露之whois查询"></a>信息泄露之whois查询</h2><p>whois(读作“Who is”，非缩写)是用来查询域名的IP以及所有者等信息的传输协议。简单说，whois就是一个用来查询域名是否已经被注册，以及注册域名的详细信息的数据库(如域名所有人、域名注册商)。通过whois来实现对域名信息的查询。早期的whois查询多以命令列接口存在，但是现在出现了一些网页接口简化的线上查询工具，可以一次向不同的数据库查询。网页接口的查询工具仍然依赖whois协议向服务器发送查询请求，命令列接口的工具仍然被系统管理员广泛使用。whois通常使用TCP协议43端口。每个域名/1P的whois信息由对应的管理机构保存。</p><h2 id="信息泄露之Maltego"><a href="#信息泄露之Maltego" class="headerlink" title="信息泄露之Maltego"></a>信息泄露之Maltego</h2><p> Maltego是一款功能强大的开源情报（OSINT）和数据可视化工具，用于信息收集和分析。它允许用户从各种来源（如DNS记录、社交媒体资料、公共记录和其他在线来源）收集信息，并以图形格式呈现所收集数据之间的关系。 Maltego可用于各种目的，包括威胁情报、欺诈检测、网络基础设施映射和漏洞分析。该工具被广泛用于安全专业人员、执法机构和调查记者。  </p><h2 id="信息泄露之地址-利用XSS进行定位"><a href="#信息泄露之地址-利用XSS进行定位" class="headerlink" title="信息泄露之地址(利用XSS进行定位)"></a>信息泄露之地址(利用XSS进行定位)</h2><p>  这种攻击通常使用JavaScript代码注入到网页中，该代码会向远程服务器发送请求，从而暴露了用户的位置信息。攻击者可能会将这些数据用于诈骗、跟踪或其他恶意行为；对于网络诈骗的犯罪分子，只有真的定位到了他的精确位置，报警处理追回财产的可能性才会最大。当于个人用户，在上网冲浪的过程中，随意点开别人的连接也会造成地址信息的泄露；</p><h2 id="信息泄露之身份信息泄露"><a href="#信息泄露之身份信息泄露" class="headerlink" title="信息泄露之身份信息泄露"></a>信息泄露之身份信息泄露</h2><p> 身份信息泄露是指个人的敏感身份信息被未经授权的第三方获取或公开。这些身份信息可能包括姓名、出生日期、社会安全号码、银行账户信息、信用卡号码、驾驶执照号码等，可以被用于欺诈、盗窃身份、恶意活动等。</p><p>身份信息泄露的主要原因包括以下几个方面：</p><ol><li>网络攻击：网络黑客或骇客利用漏洞攻击目标系统，获取个人身份信息。</li><li>社交工程：攻击者通过伪造身份或其他手段，获取个人身份信息。</li><li>数据泄露：企业或机构的数据库被黑客攻击或失窃，导致个人身份信息被泄露。</li><li>丢失或遗忘：重要文件或设备在日常生活中丢失或忘记带走，从而导致个人身份信息泄露</li></ol><h2 id="信息泄露之大数据"><a href="#信息泄露之大数据" class="headerlink" title="信息泄露之大数据"></a>信息泄露之大数据</h2><p>大数据分析可能导致隐私泄露：大数据包含了大量的个人信息和行为数据，因此，当这些数据被大规模地收集和分析时，可能会揭示出原本不为人知的个人隐私。例如，通过分析某人的社交媒体、购买历史、搜索记录等数据，就可以得到他的生活习惯、兴趣爱好、家庭情况等敏感信息。</p><p>大数据存储可能存在安全风险：大数据通常需要使用分布式计算技术进行存储，这意味着数据可能分散在多个地方存储，同时还存在网络传输和访问的安全风险。任何未授权的访问、黑客攻击或数据泄露都可能导致个人信息的泄露。</p><h1 id="如何防范社会工程学"><a href="#如何防范社会工程学" class="headerlink" title="如何防范社会工程学"></a>如何防范社会工程学</h1><ol><li>增强安全意识：加强个人和组织成员对于社会工程学攻击的认知，提高警惕，不要轻信陌生人或来源不明的信息。</li><li>加强身份验证：在重要场合或需要保护敏感信息时，应该采取多因素身份验证，如使用密码、指纹识别、智能卡等方式来确认身份。</li><li>不透露个人信息：避免随意透露个人敏感信息，如社会安全号码、银行账户、信用卡号等。</li><li>定期更改密码：采用强密码并定期更改，不要将相同的密码用于多个账户。</li><li>借助技术手段：采用杀毒软件、防火墙、反垃圾邮件过滤器等技术手段，以及进行安全培训和演练，提高组织成员的安全意识和防范能力。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
            <tag> 社工 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>google_hacking</title>
      <link href="/2023/06/13/google-hacking/"/>
      <url>/2023/06/13/google-hacking/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在我们日常生活中，Google已经成为了获取信息的重要工具。然而，这个强大的搜索引擎同时也可能被用来进行一些我们未曾察觉的活动，这其中就包括Google hacking，对于经常使用google的我，利用其该语法功能，更加精准便捷地搜索到很多东西，为此，做以下总结记录</p><h2 id="Google-hacking是什么？"><a href="#Google-hacking是什么？" class="headerlink" title="Google hacking是什么？"></a>Google hacking是什么？</h2><p>Google hacking，维基百科解释： 是指利用谷歌搜索引擎中的高级操作符，在搜索结果中定位特定的文本字符串 。这种技术利用的是网站配置和代码中存在的安全漏洞，通过特定的搜索语法来寻找和利用这些漏洞。</p><h2 id="Google-hacking常用的技术语法"><a href="#Google-hacking常用的技术语法" class="headerlink" title="Google hacking常用的技术语法"></a>Google hacking常用的技术语法</h2><p>列举常用的google语法，通过这些语法更好定位想要的信息；更多详细的语法，可以进数据库查看</p><ul><li><strong>site:</strong>：这个操作符可以让你只在特定网站内进行搜索。例如，”site:example.com” 就会在 example.com 网站内搜索。</li><li><strong>filetype:</strong>：这个操作符可以帮助你搜索特定类型的文件。例如，”filetype:pdf” 就会搜索PDF文件。</li><li><strong>intitle:</strong>：使用这个操作符可以搜索包含特定词语的网页标题。例如，”intitle:password” 会搜索标题中含有 “password” 的网页。</li><li><strong>inurl:</strong>：这个操作符可以搜索URL中包含特定词语的网页。例如，”inurl:admin” 会搜索URL中包含 “admin” 的网页。</li><li><strong>intext:</strong>：使用这个操作符可以搜索网页正文中包含特定词语的网页。例如，”intext:confidential” 会搜索正文中含有 “confidential” 的网页。</li><li><strong>cache:</strong>：这个操作符可以帮助你查看Google对某个网页的缓存版本。例如，”cache:example.com” 会显示Google最近一次索引 example.com 的快照。</li><li><strong>link:</strong>：这个操作符可以帮助你查找链接到特定URL的所有网页，不过这个功能在2017年被Google关闭，现在可能已经不能用了。</li><li><strong>info:</strong>：这个操作符可以帮助你获取关于特定URL的基本信息，如网页描述、相关链接等。</li><li><strong>related:</strong>：这个操作符可以帮你查找和特定网站内容相关的网站。</li><li><strong>stocks:</strong>：这个操作符可以帮助你查找特定公司的股票信息。</li></ul><blockquote><p>google hacking语法库：<a href="https://www.exploit-db.com/google-hacking-database" target="_blank" rel="noopener">https://www.exploit-db.com/google-hacking-database</a></p></blockquote><p>符号类</p><ul><li><strong>使用双引号(“ “)进行精确匹配</strong>：例如，搜索 “太阳能电池” 将只返回包含完整词组 “太阳能电池” 的结果。</li><li><strong>使用减号(-)排除特定词汇</strong>：例如，搜索 “iPhone -12” 将返回与 iPhone 相关的结果，但不包括 “iPhone 12”。</li><li><strong>使用星号(*)作为通配符</strong>：例如，搜索 “Apple 的 * 手机” 可以返回 “Apple 的 iPhone 手机”、”Apple 的 5G 手机” 等结果。</li><li><strong>使用 OR 查询多个词</strong>：例如，搜索 “华为 OR 小米” 将返回与 “华为” 或 “小米” 相关的结果</li></ul><h2 id="如何利用-防范Google-hacking？"><a href="#如何利用-防范Google-hacking？" class="headerlink" title="如何利用/防范Google hacking？"></a>如何利用/防范Google hacking？</h2><p>利用: 利用好google hacking 可以更准确找到自己需要的信息，做到真正的高效搜索</p><p>防范：Google hacking的首要步骤是对自己的网络环境有深入的了解，包括服务器配置、代码安全等。其次，定期进行安全审计和漏洞扫描也非常重要，这可以帮助我们及时发现并修复潜在的安全问题。最后，我们还可以通过robots.txt文件来限制搜索引擎对敏感信息的索引，从而避免信息被黑客搜索到。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>google hacking 是一种对个人搜索有利的语法知识，加以利用是我们在日常使用中的好利刃；虽然Google hacking可能会带来安全威胁，但只要我们有充足的了解和正确的防范措施，就完全可以保护我们的信息安全。通过持续学习和保持警惕，我们能够在享受互联网带来的便利的同时，也保护好自己的网络安全。</p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
            <tag> 技术分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日60s读懂世界</title>
      <link href="/2023/06/11/mei-ri-60s/"/>
      <url>/2023/06/11/mei-ri-60s/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img src="https://api.03c3.cn/zb/" alt="每日60s读懂世界">]]></content>
      
      
      <categories>
          
          <category> 分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>chatgpt接入微信</title>
      <link href="/2023/06/11/chatgpt-jie-ru-wei-xin/"/>
      <url>/2023/06/11/chatgpt-jie-ru-wei-xin/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="做好前期准备"><a href="#做好前期准备" class="headerlink" title="做好前期准备"></a>做好前期准备</h1><ul><li>一台云服务器</li><li>一个chatgpt账号，带有apikey，用于使用api接口</li><li>github账号 ，用于获取项目</li><li>还有就是一颗愿意折腾，好奇的心，打造属于自己私人小助手和小群体的群聊助手伙伴</li></ul><h1 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h1><img src="https://cdn.jsdelivr.net/gh/Bevis23/blog-pic/bot%E6%95%88%E6%9E%9C%E5%9B%BE.png" style="zoom:20%;"><h2 id="服务器选择"><a href="#服务器选择" class="headerlink" title="服务器选择"></a>服务器选择</h2><p>由于api接口后期也被墙了，使用境外服务器的话就不需要配置代理，相对方便；</p><p>我个人是弄了一台腾讯云，轻量级， CentOS7.6的操作系统 ；新人首次112一年，够用；</p><h2 id="chatgpt账号注册"><a href="#chatgpt账号注册" class="headerlink" title="chatgpt账号注册"></a>chatgpt账号注册</h2><p>注册的话，用邮箱，用sms接码验证便可注册，这里不具体阐述，会自带5$的api额度</p><h2 id="github账号"><a href="#github账号" class="headerlink" title="github账号"></a>github账号</h2><p>直接账号注册，做好相关配置，获取机器人项目</p><p>项目地址：<a href="https://github.com/zhayujie/chatgpt-on-wechat" target="_blank" rel="noopener">https://github.com/zhayujie/chatgpt-on-wechat</a></p><p>项目克隆步骤:</p><p>1配置ssh key</p><p>到服务器输入命令： </p><pre class=" language-linux"><code class="language-linux">ssh-keygen -t rsa -C "xxxx@test.com"  #然后一直回车即可</code></pre><p> 2 输入以下命令，查看，复制生成的key ：</p><pre><code>cat ~/.ssh/id_rsa.pub</code></pre><p>3将复制的内容放置于github上ssh keys上，保存即可</p><h1 id="部署操作步骤"><a href="#部署操作步骤" class="headerlink" title="部署操作步骤"></a>部署操作步骤</h1><h2 id="安装相关工具和环境部署"><a href="#安装相关工具和环境部署" class="headerlink" title="安装相关工具和环境部署"></a>安装相关工具和环境部署</h2><p>环境要求为python3.9+版本</p><p> 查看一下服务器是否有下载python和git：</p><pre><code>[root@miyi_server ~]# python3 -VPython 3.9.2[root@miyi_server ~]# git --versiongit version 1.8.3.1</code></pre><p>我已经安装，假设你的服务器还没安装的话，则做如下操作，代码和注释已经很清晰，照着来就可以</p><pre><code>yum update #更新下yum源yum install -y git #安装gitcd /home #切换到/home目录下git clone git@github.com:zhayujie/chatgpt-on-wechat.git #去github仓库克隆项目yum install -y wget #安装wget，用于从Web服务器上下载python3文件wget https://www.python.org/ftp/python/3.9.2/Python-3.9.2.tgz #下载文件tar -xzvf Python-3.9.2.tgz #对文件进行解压yum install -y gcc # 从这里开始安装相关依赖yum install -y zlib-develyum install openssl-develyum install libffi-devel</code></pre><h2 id="配置python环境"><a href="#配置python环境" class="headerlink" title="配置python环境"></a>配置python环境</h2><p>对python进行相关操作</p><pre><code>cd /home/Python-3.9.2 #进入目录##编译python./configuremake altinstallln -s /usr/local/bin/python3.9 /usr/bin/python3 #加入软链接，指向该目录yum install -y python3-pip  #安装pip3##安装相关依赖包pip3 install itchat-uos==1.5.0.dev0 #安装微信机器人的包pip3 install --upgrade openai  #对openai 的包进行更新##假如更新过后python的版本发生了改变，则需要重新设置一下rm /usr/bin/python3 #删除python3软连接 ln -s /usr/local/bin/python3.9 /usr/bin/python3 #重新加入软连接pip3 install --upgrade openai #对openai 的包进行更新</code></pre><h2 id="项目配置文件操作"><a href="#项目配置文件操作" class="headerlink" title="项目配置文件操作"></a>项目配置文件操作</h2><p>python相关配置完成之后，对项目目录进行设置，配置相关参数</p><pre><code>cd ../chatgpt-on-wechat/ #进入项目目录cp config-template.json config.json #负制一份配置文件## 使用vim工具进行编辑，假设你服务器没有，只需要yum install -y vimvim config.json #打开配置文件</code></pre><p>以下配置文件的内容参数解析，根据我的注释做个人设置即可</p><pre><code>{  &quot;open_ai_api_key&quot;: &quot;此处输入你自己的apikey&quot;,  &quot;model&quot;: &quot;gpt-3.5-turbo&quot;,  &quot;proxy&quot;: &quot;http://127.0.0.1:7890&quot;, #这便是需要配置代理的情况，假设你是境外服务器，则没有这个  &quot;single_chat_prefix&quot;: [    &quot;dan&quot; #此处为私人聊天的触发词选项，我设置为dan，私人聊天便会按照这个触发词来决定是否由bot回答  ],  &quot;single_chat_reply_prefix&quot;: &quot;&quot;,  &quot;group_chat_prefix&quot;: [    &quot;@dan&quot;  #群聊触发 为@dan  ],  &quot;group_name_white_list&quot;: [    &quot;ALL_GROUP&quot;  #设置所有群都开启bot功能  ],  &quot;group_chat_in_one_session&quot;: [    &quot;ChatGPT测试群&quot;   ],  &quot;image_create_prefix&quot;: [    &quot;画&quot;,    &quot;看&quot;,    &quot;找&quot; #此为图片触发词  ],  &quot;speech_recognition&quot;: true,  #是否打开语音识别，针对私聊  &quot;group_speech_recognition&quot;: false,  #是否打开语音识别，针对群聊  &quot;voice_reply_voice&quot;: false, #是否开启语音回复  &quot;conversation_max_tokens&quot;: 10000, #回复token的限制长度  &quot;expires_in_seconds&quot;: 3600, #响应时间  &quot;character_desc&quot;: &quot;你是ChatGPT, 一个由OpenAI训练的大型语言模型, 你旨在回答并解决人们的任何问题，并且可以使用多种语言与人交流。&quot;,  &quot;subscribe_msg&quot;: &quot;感谢您的关注！\n这里是ChatGPT，可以自由对话。\n支持语音对话。\n支持图片输入。\n支持图片输出，画字开头的消息将按要求创作图片。\n支持tool、角色扮演和文字冒险等丰富的插件。\n输入{trigger_prefix}#help 查看详细指令。&quot;}</code></pre><p>配置完成 按ESC 输入  :wq 便可以保存退出</p><p>安装运行相关的python3库</p><pre><code>pip3 install chatgpt_tool_hubpip3 install qrcodepip3 install pyqrcodepython3 app.py #运行app.py，便会出现二维码，扫码登录即可使用机器人</code></pre><h2 id="让bot永不间断地回复"><a href="#让bot永不间断地回复" class="headerlink" title="让bot永不间断地回复"></a>让bot永不间断地回复</h2><p>服务是用终端进行连接的，终端进程会随着终端的关闭同时关闭，这时候即使服务器24小时开着，bot也会随着终端的关闭而停止，这时候需要想个法子让它在后台一直运行</p><p>面对这个问题，采用linux下的 nohup工具便可解决</p><pre><code>touch nohup.out #先创建一个nohup.outnohup python3 app.py &amp; tail -f nohup.out #让应用程序以后台方式运行，并将输出日志重定向到nohup.out文件中，同时使用tail -f命令来实时监控nohup.out文件的内容变化;# 当需要关闭后台时候ps -ef | grep app.py #查看进程kill -9 进程号</code></pre><p>到此，整个操作就完成了，可以实现微信机器人的功能了</p><h1 id="服务器代理设置"><a href="#服务器代理设置" class="headerlink" title="服务器代理设置"></a>服务器代理设置</h1><p>上面提到，用国内服务器的，需要配置相关的代理服务，在这篇里不做阐述； 大体的实现是在服务器上配置代理，方式有很多种，个人使用的是clash for linux，同样需要配置后台运行，这时候使用的则是配置systemd服务了，相对方便；配置代理文件等</p><p>综上，直接使用不需要配置代理的服务器会方便很多，只需按我上面提到的操作即可。</p>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
            <tag> chatgpt </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>共享无价：资源分享合集</title>
      <link href="/2023/06/09/gong-xiang-wu-jie-zi-yuan-fen-xiang-he-ji/"/>
      <url>/2023/06/09/gong-xiang-wu-jie-zi-yuan-fen-xiang-he-ji/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="共享无价：资源分享合集"><a href="#共享无价：资源分享合集" class="headerlink" title="共享无价：资源分享合集"></a>共享无价：资源分享合集</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>遇到某些问题，需要啥资源了，就来看此帖，主张一个   “你刚好需要，而我，刚好出现O(∩_∩)O”</p><p>当我们需要某些资源时，通常会选择购买或寻找其他来源来满足我们的需求。购买资源可能是一种常见的方式，但有时我们可能会遇到价格过高或难以获得的困境。这时，我们开始寻找替代方案，以满足我们的需求。互联网的急速发展，信息爆炸，寻找资源，找到好用免费的资源，有时候不是那么容易。为此我打算在平台和社区分享我的知识、技能、工具、内容和创意。</p><p>为什么做资源分享？</p><p>我个人认为：分享者获得满足感和建立社交网络，受益者获得免费和有价值的资源。</p><p>资源合集：<a href="https://flowus.cn/bevis23/share/416a6010-b2d6-4201-8937-b7a83099a65d" target="_blank" rel="noopener">Bevis_share</a></p><blockquote><p>详见“极客导航”栏</p></blockquote><p>我会将各种资源放在flowus社区，就是以上链接；此博客由hexo搭建，托管于github，对于零碎的资源分享链接放置于社区更加方便，博客则用于分享其中一些资源的使用方法与心得</p><h2 id="免费资源的种类"><a href="#免费资源的种类" class="headerlink" title="免费资源的种类"></a>免费资源的种类</h2><ul><li>网站资源 </li><li>AI合集</li><li>软件与app</li><li>浏览器增强-插件</li><li>实用工具</li><li>github汇总</li><li>阅读分享</li><li>问题收集</li><li>数据分析</li><li>安全见闻</li><li>编程</li></ul><h2 id="资源分享的好处"><a href="#资源分享的好处" class="headerlink" title="资源分享的好处"></a>资源分享的好处</h2><p>成功的资源分享者往往能够获得丰富的回报。他们与其他专业人士建立了有价值的合作关系，扩大了自己的网络和人脉。同时，他们也获得了更多的学习机会和个人成长的空间。通过分享资源，您将在知识交流、专业发展和个人成就方面获得无限的机遇和成就感。</p><p>所以，不要犹豫，成为资源分享者，积极贡献您的知识和资源。共享文化的重要性不可低估，而您的参与将为您和他人带来巨大的收益和影响力。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>赠人玫瑰，手留余香；我受益于互联网，同时也成为互联网的分享者，和万千分享者一样，不忘初心。</p><p>最后，还是这句：永远保持好奇心，去探索，去直面自己的感受，面对万物渐变，宓而待之，追翊于廖廓，终有所感，终有所得……</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=857896&auto=1&height=66"></iframe>]]></content>
      
      
      <categories>
          
          <category> 资源分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 资源分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dream</title>
      <link href="/2023/05/27/dream/"/>
      <url>/2023/05/27/dream/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>不是每个人都应该像我这样去建造一座水晶大教堂，但是每个人都应该拥有自己的梦想，设计自己的梦想，追求自己的梦想，实现自己的梦想。梦想是生命的灵魂，是心灵的灯塔，是引导人走向成功的信仰。有了崇高的梦想，只要矢志不渝地追求，梦想就会成为现实，奋斗就会变成壮举，生命就会创造奇迹。——罗伯·舒乐 </p><div align="middle">    <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=2048584480&auto=1&height=66"></iframe></div>]]></content>
      
      
      <categories>
          
          <category> 阅读分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活记录 </tag>
            
            <tag> 阅读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客的新开始</title>
      <link href="/2023/05/25/bo-ke-de-xin-kai-shi/"/>
      <url>/2023/05/25/bo-ke-de-xin-kai-shi/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="欢迎来到我的博客"><a href="#欢迎来到我的博客" class="headerlink" title="欢迎来到我的博客"></a>欢迎来到我的博客</h1><p>欢迎大家来到我的博客！我很高兴你们能在这个虚拟空间中找到我。</p><h2 id="博客的目标"><a href="#博客的目标" class="headerlink" title="博客的目标"></a>博客的目标</h2><p>这个博客的主要目标是分享和记录。我将在这里分享我的一些知识与资源、经验和想法，同时也将这个空间作为记录我个人成长和探索的地方。</p><p>我相信，学习是一个永无止境的过程，而分享和记录则是这个过程的重要组成部分。分享可以帮助我们更深入地理解我们所学的东西，同时也可以帮助其他人。记录则可以帮助我们反思，看看我们从哪里来，以及我们正在走向何方。</p><p>秉承极客文化，极客文化强调开源共享、创客精神和持续学习的重要性， 保持无尽好奇心和不断追求知识，记录于此。</p><h2 id="预期的内容"><a href="#预期的内容" class="headerlink" title="预期的内容"></a>预期的内容</h2><p>在接下来的日子里，我将在这个博客中发布各种各样的文章。可能是关于技术的，比如编程、人工智能或者是资源分享。可能是关于艺术的，比如阅读、绘画或音乐。也可能是关于生活的思考，比如健康、旅行或者是个人成长。</p><p>我也希望能够听到你们的声音。如果你有任何的问题、建议或者是想要分享的话题，欢迎在评论区留言。我会很高兴能和你们进行交流。</p><h2 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h2><p>在这个瞬息万变的世界里，有一件事是永恒的，那就是变化。我期待在这个变化中找到我自己，也期待和你们一起探索这个美好的世界。<br>最后的最后，永远保持好奇心，去探索，去直面自己的感受，面对万物渐变，宓而待之，追翊于廖廓，终有所感，终有所得……</p><p>感谢你的阅读，我们下次见！</p>]]></content>
      
      
      <categories>
          
          <category> 生活记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活记录 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
