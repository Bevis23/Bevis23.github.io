<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>网络攻击数据分析：揭示网络威胁的模式和趋势</title>
      <link href="/shu-fen-an-quan-gong-ji-fen-xi.html"/>
      <url>/shu-fen-an-quan-gong-ji-fen-xi.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在当今数字化时代，网络安全攻击已成为一个日益严重的问题。了解各种攻击类型和模式对于有效预防和应对网络威胁至关重要。在逛kaggle社区的时候，发现数据集：’cybersecurity_attacks.csv’，同过介绍和字段查看，发现它经过精心制作，真实地再现了网络安全攻击的历史，这个数据集为我们提供了一个理想的场所，进行各种分析任务和研究，了解网络安全攻击的特征和趋势。</p><p>通过使用这个网络安全攻击数据集，可进行多个层面的评估和分析。可以生成热图来可视化攻击活动的分布和强度，探索不同攻击特征和模式，以了解攻击者的策略和技术。可以对攻击类型进行分类和分析，以便更好地了解不同类型攻击的特点和威胁级别。</p><p>这篇博文将针对这个令人兴奋的数据集展开数据分析，探索网络安全攻击的潜在模式和趋势。希望通过对数据的深入挖掘，了解有关网络安全保护和防御的有用见解，并为构建更加安全的数字环境贡献一份力量。让我们一起开始这个令人兴奋的数据探险之旅吧！</p><blockquote><p>数据集来源：<a href="https://www.kaggle.com/datasets/teamincribo/cyber-security-attacks/data" target="_blank" rel="noopener">https://www.kaggle.com/datasets/teamincribo/cyber-security-attacks/data</a></p><p>以下过程使用 jupyter notebook实现，代码均无使用print输出， Jupyter具有交互式和文档化的特点 ， 即使您没有使用print函数，执行单元格时， Jupyter Notebook的默认行为，仍将在屏幕上打印每个变量的值以<strong>元组形式输出</strong>，使用其他实现方式的小伙伴需要使用print输出</p></blockquote><h1 id="数据信息获取"><a href="#数据信息获取" class="headerlink" title="数据信息获取"></a>数据信息获取</h1><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> pandas <span class="token keyword">as</span> pd<span class="token comment" spellcheck="true"># 加载数据集csv文件</span>file_path <span class="token operator">=</span> <span class="token string">'E:\data\cybersecurity_attacks.csv'</span>dataset <span class="token operator">=</span> pd<span class="token punctuation">.</span>read_csv<span class="token punctuation">(</span>file_path<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 通过查看前五行，查看数据字段有哪些</span>dataset<span class="token punctuation">.</span>head<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>读取csv内容有如下：</p><table><thead><tr><th>Timestamp</th><th>Source IP Address</th><th>Destination IP Address</th><th>Source Port</th><th>…</th></tr></thead><tbody><tr><td>0</td><td>2023/5/30 6:33</td><td>103.216.15.12</td><td>84.9.164.252</td><td>Qui natus odio asperiores nam. Optio nobis ius…</td></tr><tr><td>1</td><td>2020/8/26 7:08</td><td>78.199.217.198</td><td>66.191.137.154</td><td>Aperiam quos modi officiis veritatis rem. Omni…</td></tr><tr><td>2</td><td>2022/11/13 8:23</td><td>63.79.210.48</td><td>198.219.82.17</td><td>Perferendis sapiente vitae soluta. Hic delectu…</td></tr><tr><td>3</td><td>2023/7/2 10:38</td><td>163.42.196.10</td><td>101.228.192.255</td><td>Totam maxime beatae expedita explicabo porro l…</td></tr><tr><td>4</td><td>2023/7/16 13:11</td><td>71.166.185.76</td><td>189.243.174.238</td><td>Odit nesciunt dolorem nisi iste iusto. Animi v…</td></tr></tbody></table><p>字段还挺多的哈，25个</p><p>这个数据集包含了 40,000 条网络流量记录，每条记录有 25 个字段。这些字段包括时间戳、源 IP 地址、目的 IP 地址、源端口、目的端口、协议类型、数据包长度、数据包类型、流量类型、负载数据等。一些与安全相关的字段，如恶意软件指标、异常分数、警报/警告、攻击类型、采取的行动等。</p><p>针对此类数据，先分析以下三个方面：</p><ul><li>热图:可视化源和目的IP地址或端口的频率。 </li><li>攻击特征与类型:识别可能表明恶意活动的模式，例如短时间内多次尝试连接；分析攻击类型与严重级别；</li><li>流量类型:对流量类型(HTTP、DNS等)进行分类，了解使用模式。</li></ul><h1 id="数据清理"><a href="#数据清理" class="headerlink" title="数据清理"></a>数据清理</h1><p>老样子，开始数据分析前必做的事：确保数据集没有重复或不相关的条目。</p><h2 id="清理重复数据"><a href="#清理重复数据" class="headerlink" title="清理重复数据"></a>清理重复数据</h2><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 删除重复行</span>dataset_cleaned <span class="token operator">=</span> dataset<span class="token punctuation">.</span>drop_duplicates<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 查看删除行</span>original_shape <span class="token operator">=</span> dataset<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>cleaned_shape <span class="token operator">=</span> dataset_cleaned<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>rows_removed <span class="token operator">=</span> original_shape <span class="token operator">-</span> cleaned_shapeoriginal_shape<span class="token punctuation">,</span> cleaned_shape<span class="token punctuation">,</span> rows_removed <span class="token comment" spellcheck="true"># jupyter 输出 (40000, 40000, 0) 元组形式</span><span class="token keyword">print</span><span class="token punctuation">(</span>original_shape<span class="token punctuation">,</span>cleaned_shape<span class="token punctuation">,</span>rows_removed<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># print输出 40000 40000 0</span></code></pre><p>通过对删除重复行前后的行数对比，40000条数据无变化，看来数据集作者是已经清洗过的了^_^</p><h1 id="特征提取"><a href="#特征提取" class="headerlink" title="特征提取"></a>特征提取</h1><p>关注以下几个主要特征：</p><ol><li><strong>Source IP Address 和 Destination IP Address（源IP和目的IP）</strong>:  是网络通信中非常基本的信息，它们用于识别发送和接收方。通过将这些信息可视化为热图，可以更好地<strong>了解网络流量的分布情况</strong>。 </li><li><strong>Timestamp（时间戳）</strong>:  时间戳表示网络通信发生的时间点，可以帮助我们<strong>发现和识别攻击模式</strong>。例如，如果我们发现某个时间段内有大量的数据包发送，那么可能表示有人正在对系统进行攻击 </li><li><strong>Traffic Type（流量类型）</strong>:  用于了解<strong>网络通信的性质</strong>。不同类型的流量（例如HTTP、FTP等）有着不同的特征和限制条件。通过对流量类型的分类和分析，了解网络通信的本质，从而有针对性地采取措施来保护系统和数据的安全。 </li></ol><h1 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a>数据可视化</h1><h2 id="创建热图"><a href="#创建热图" class="headerlink" title="创建热图"></a>创建热图</h2><p>创建几个热图，分别表示“源 IP 地址”和“目的 IP 地址”的频率。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token keyword">import</span> seaborn <span class="token keyword">as</span> sns<span class="token comment" spellcheck="true"># 数据准备，将结果存储在两个不同的数据帧</span>source_ip_counts <span class="token operator">=</span> dataset_cleaned<span class="token punctuation">[</span><span class="token string">'Source IP Address'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>value_counts<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>reset_index<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>rename<span class="token punctuation">(</span>columns<span class="token operator">=</span><span class="token punctuation">{</span><span class="token string">'index'</span><span class="token punctuation">:</span> <span class="token string">'Source IP Address'</span><span class="token punctuation">,</span> <span class="token string">'Source IP Address'</span><span class="token punctuation">:</span> <span class="token string">'Count'</span><span class="token punctuation">}</span><span class="token punctuation">)</span>destination_ip_counts <span class="token operator">=</span> dataset_cleaned<span class="token punctuation">[</span><span class="token string">'Destination IP Address'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>value_counts<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>reset_index<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>rename<span class="token punctuation">(</span>columns<span class="token operator">=</span><span class="token punctuation">{</span><span class="token string">'index'</span><span class="token punctuation">:</span> <span class="token string">'Destination IP Address'</span><span class="token punctuation">,</span> <span class="token string">'Destination IP Address'</span><span class="token punctuation">:</span> <span class="token string">'Count'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 创建热力图</span>fig<span class="token punctuation">,</span> axs <span class="token operator">=</span> plt<span class="token punctuation">.</span>subplots<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> figsize<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 源ip热力图</span>sns<span class="token punctuation">.</span>heatmap<span class="token punctuation">(</span>source_ip_counts<span class="token punctuation">.</span>pivot<span class="token punctuation">(</span>columns<span class="token operator">=</span><span class="token string">'Source IP Address'</span><span class="token punctuation">,</span> values<span class="token operator">=</span><span class="token string">'Count'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>fillna<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> annot<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> cmap<span class="token operator">=</span><span class="token string">'coolwarm'</span><span class="token punctuation">,</span> ax<span class="token operator">=</span>axs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>axs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>set_title<span class="token punctuation">(</span><span class="token string">'Source IP Address Frequency'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 目的ip热力图</span>sns<span class="token punctuation">.</span>heatmap<span class="token punctuation">(</span>destination_ip_counts<span class="token punctuation">.</span>pivot<span class="token punctuation">(</span>columns<span class="token operator">=</span><span class="token string">'Destination IP Address'</span><span class="token punctuation">,</span> values<span class="token operator">=</span><span class="token string">'Count'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>fillna<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> annot<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> cmap<span class="token operator">=</span><span class="token string">'coolwarm'</span><span class="token punctuation">,</span> ax<span class="token operator">=</span>axs<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>axs<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>set_title<span class="token punctuation">(</span><span class="token string">'Destination IP Address Frequency'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 输出：MemoryError: Unable to allocate 11.9 GiB for an array with shape (40000, 40000) and data type float64 </span></code></pre><p>哦吼，有意思，MemoryError……，是的，没错，数据计算机无法为其分配足够的空间，导致内存溢出错误；</p><p>为了解决这个问题，我们可以采取以下几种方法：</p><ol><li><strong>缩小数据范围</strong>: 选择数据集的一个子集进行分析。</li><li><strong>聚合数据</strong>: 只考虑最频繁出现的 IP 地址。</li></ol><p>先尝试第二种方法，只考虑出现次数最多的 IP 地址。这样，就可以减少数据的规模，同时仍能获取有用的信息。</p><h2 id="创建简化版的热图"><a href="#创建简化版的热图" class="headerlink" title="创建简化版的热图"></a>创建简化版的热图</h2><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 前10个最常见的源IP地址和目的IP地址</span>top_10_source_ip <span class="token operator">=</span> source_ip_counts<span class="token punctuation">.</span>nlargest<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token string">'Count'</span><span class="token punctuation">)</span>top_10_destination_ip <span class="token operator">=</span> destination_ip_counts<span class="token punctuation">.</span>nlargest<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token string">'Count'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 创建简单热力图</span>fig<span class="token punctuation">,</span> axs <span class="token operator">=</span> plt<span class="token punctuation">.</span>subplots<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> figsize<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#  Top 10源IP地址热图</span>sns<span class="token punctuation">.</span>barplot<span class="token punctuation">(</span>x<span class="token operator">=</span><span class="token string">'Count'</span><span class="token punctuation">,</span> y<span class="token operator">=</span><span class="token string">'Source IP Address'</span><span class="token punctuation">,</span> data<span class="token operator">=</span>top_10_source_ip<span class="token punctuation">,</span> ax<span class="token operator">=</span>axs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> palette<span class="token operator">=</span><span class="token string">'coolwarm'</span><span class="token punctuation">)</span>axs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>set_title<span class="token punctuation">(</span><span class="token string">'Top 10 Source IP Address Frequency'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># top 10目的IP地址热图</span>sns<span class="token punctuation">.</span>barplot<span class="token punctuation">(</span>x<span class="token operator">=</span><span class="token string">'Count'</span><span class="token punctuation">,</span> y<span class="token operator">=</span><span class="token string">'Destination IP Address'</span><span class="token punctuation">,</span> data<span class="token operator">=</span>top_10_destination_ip<span class="token punctuation">,</span> ax<span class="token operator">=</span>axs<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> palette<span class="token operator">=</span><span class="token string">'coolwarm'</span><span class="token punctuation">)</span>axs<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>set_title<span class="token punctuation">(</span><span class="token string">'Top 10 Destination IP Address Frequency'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 正常输出热力图</span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/Bevis23/blog-pic/ip%E7%83%AD%E5%8A%9B%E5%9B%BE.jpg" alt></p><p>这出了两个简化版的热图，分别表示出现次数最多的前 10 个“源 IP 地址”和“目的 IP 地址”。</p><p>热力图中的颜色表示频率的大小，较深的颜色代表较高的频率。通过观察热力图，可以得出以下分析结果：</p><ol><li>前10个最常见的源IP地址：根据柱状图的高度，可以看出哪些IP地址是数据中最常见的来源。这可能有助于识别哪些IP地址发送了大量的网络流量或请求。</li><li>前10个最常见的目的IP地址：类似地，通过目的IP地址的频率，可以确定哪些IP地址是数据中最常见的目标。这可能有助于发现接收大量流量或请求的主机。</li></ol><p>通过分析这些数据，可以发现网络流量的热点区域，识别潜在的异常行为或攻击。此外，还可以帮助网络管理员优化网络结构、检测潜在的安全风险，以及进行其他网络运维和安全方面的决策。然而，具体的分析结果仍然需要根据实际情况和进一步的上下文来解读和应用。</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 此段代码是针对个人jupyter的背景主题而做的，为了更好看清可视化图像</span><span class="token comment" spellcheck="true"># 设置标题的颜色为白色</span>axs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>set_title<span class="token punctuation">(</span><span class="token string">'Top 10 Source IP Address Frequency'</span><span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token string">'white'</span><span class="token punctuation">)</span>axs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>set_xlabel<span class="token punctuation">(</span><span class="token string">'Count'</span><span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token string">'white'</span><span class="token punctuation">)</span>axs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>set_ylabel<span class="token punctuation">(</span><span class="token string">'Source IP Address'</span><span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token string">'white'</span><span class="token punctuation">)</span>axs<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>set_title<span class="token punctuation">(</span><span class="token string">'Top 10 Destination IP Address Frequency'</span><span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token string">'white'</span><span class="token punctuation">)</span>axs<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>set_xlabel<span class="token punctuation">(</span><span class="token string">'Count'</span><span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token string">'white'</span><span class="token punctuation">)</span>axs<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>set_ylabel<span class="token punctuation">(</span><span class="token string">'Destination IP Address'</span><span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token string">'white'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 设置坐标轴标签的颜色为白色</span>axs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>tick_params<span class="token punctuation">(</span>axis<span class="token operator">=</span><span class="token string">'x'</span><span class="token punctuation">,</span> colors<span class="token operator">=</span><span class="token string">'white'</span><span class="token punctuation">)</span>axs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>tick_params<span class="token punctuation">(</span>axis<span class="token operator">=</span><span class="token string">'y'</span><span class="token punctuation">,</span> colors<span class="token operator">=</span><span class="token string">'white'</span><span class="token punctuation">)</span>axs<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>tick_params<span class="token punctuation">(</span>axis<span class="token operator">=</span><span class="token string">'x'</span><span class="token punctuation">,</span> colors<span class="token operator">=</span><span class="token string">'white'</span><span class="token punctuation">)</span>axs<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>tick_params<span class="token punctuation">(</span>axis<span class="token operator">=</span><span class="token string">'y'</span><span class="token punctuation">,</span> colors<span class="token operator">=</span><span class="token string">'white'</span><span class="token punctuation">)</span></code></pre><h1 id="分析攻击特征与类型"><a href="#分析攻击特征与类型" class="headerlink" title="分析攻击特征与类型"></a>分析攻击特征与类型</h1><h2 id="攻击特征"><a href="#攻击特征" class="headerlink" title="攻击特征"></a>攻击特征</h2><p>为了分析可能的攻击特征，观察在短时间内是否有多次连接尝试。这通常是暴力破解或其他类型攻击的一个信号。</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Timestamp列转换为datetime格式</span>dataset_cleaned<span class="token punctuation">[</span><span class="token string">'Timestamp'</span><span class="token punctuation">]</span> <span class="token operator">=</span> pd<span class="token punctuation">.</span>to_datetime<span class="token punctuation">(</span>dataset_cleaned<span class="token punctuation">[</span><span class="token string">'Timestamp'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 按时间戳和源IP地址排序</span>dataset_cleaned<span class="token punctuation">.</span>sort_values<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'Source IP Address'</span><span class="token punctuation">,</span> <span class="token string">'Timestamp'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> inplace<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 计算同一源IP地址的每一行与前一行之间的时间差</span>dataset_cleaned<span class="token punctuation">[</span><span class="token string">'Time Difference'</span><span class="token punctuation">]</span> <span class="token operator">=</span> dataset_cleaned<span class="token punctuation">.</span>groupby<span class="token punctuation">(</span><span class="token string">'Source IP Address'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token string">'Timestamp'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>diff<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 将时差转换为秒，以便于分析</span>dataset_cleaned<span class="token punctuation">[</span><span class="token string">'Time Difference (s)'</span><span class="token punctuation">]</span> <span class="token operator">=</span> dataset_cleaned<span class="token punctuation">[</span><span class="token string">'Time Difference'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>dt<span class="token punctuation">.</span>total_seconds<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 过滤掉时间差小于某个阈值的行(10秒)</span>suspicious_activity <span class="token operator">=</span> dataset_cleaned<span class="token punctuation">[</span>dataset_cleaned<span class="token punctuation">[</span><span class="token string">'Time Difference (s)'</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 统计每个源IP地址的可疑活动数量</span>suspicious_counts <span class="token operator">=</span> suspicious_activity<span class="token punctuation">[</span><span class="token string">'Source IP Address'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>value_counts<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>reset_index<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>rename<span class="token punctuation">(</span>columns<span class="token operator">=</span><span class="token punctuation">{</span><span class="token string">'index'</span><span class="token punctuation">:</span> <span class="token string">'Source IP Address'</span><span class="token punctuation">,</span> <span class="token string">'Source IP Address'</span><span class="token punctuation">:</span> <span class="token string">'Count'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 显示10个最常见的可疑源IP地址</span>top_10_suspicious <span class="token operator">=</span> suspicious_counts<span class="token punctuation">.</span>nlargest<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token string">'Count'</span><span class="token punctuation">)</span>top_10_suspicious  <span class="token comment" spellcheck="true"># 输出Source IP Address    Count 仅仅出现字段名 无数据</span></code></pre><p>通过输出可以发现：在这个数据集中没有发现在短时间内重复出现的“源 IP 地址”，这意味着没有明显的恶意攻击活动。</p><h2 id="攻击类型"><a href="#攻击类型" class="headerlink" title="攻击类型"></a>攻击类型</h2><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 查看攻击类型</span>attack_types <span class="token operator">=</span> dataset<span class="token punctuation">[</span><span class="token string">'Attack Type'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>value_counts<span class="token punctuation">(</span><span class="token punctuation">)</span>attack_types<span class="token comment" spellcheck="true"># 输出，每种攻击类型的频率大致相当，都在13000多次事件左右</span>DDoS         <span class="token number">13428</span>Malware      <span class="token number">13307</span>Intrusion    <span class="token number">13265</span>Name<span class="token punctuation">:</span> Attack Type<span class="token punctuation">,</span> dtype<span class="token punctuation">:</span> int64</code></pre><p>由此得出，数据集中有三种主要的攻击类型：</p><ol><li><strong>DDoS（分布式拒绝服务攻击）</strong>: 这类攻击涉及多个系统联合攻击单一目标，导致目标系统的服务中断或崩溃。</li><li><strong>Malware（恶意软件）</strong>: 这涉及到恶意软件，例如病毒、蠕虫、特洛伊木马等，它们会侵入并可能损害系统。</li><li><strong>Intrusion（入侵）</strong>: 这涉及未经授权的访问，旨在窃取敏感数据或破坏系统。</li></ol><p>针对一下两点分析：</p><ol><li><strong>严重性级别</strong>：分析每种攻击类型的严重性级别分布。</li><li><strong>网络段影响</strong>：查看哪些网络段受到了最多的攻击。</li></ol><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 设置字体颜色为白色，个人的黑色背景只能调节颜色提高可视化效果，白色背景可不调，默认为黑色字体</span>plt<span class="token punctuation">.</span>rcParams<span class="token punctuation">.</span>update<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">'text.color'</span><span class="token punctuation">:</span> <span class="token string">'white'</span><span class="token punctuation">,</span> <span class="token string">'axes.labelcolor'</span><span class="token punctuation">:</span> <span class="token string">'white'</span><span class="token punctuation">,</span> <span class="token string">'xtick.color'</span><span class="token punctuation">:</span> <span class="token string">'white'</span><span class="token punctuation">,</span> <span class="token string">'ytick.color'</span><span class="token punctuation">:</span> <span class="token string">'white'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 绘制图表，分析每种攻击类型的严重性级别分布</span>plt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span>figsize<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">)</span>sns<span class="token punctuation">.</span>countplot<span class="token punctuation">(</span>x<span class="token operator">=</span><span class="token string">'Attack Type'</span><span class="token punctuation">,</span> hue<span class="token operator">=</span><span class="token string">'Severity Level'</span><span class="token punctuation">,</span> data<span class="token operator">=</span>dataset<span class="token punctuation">,</span> palette<span class="token operator">=</span><span class="token string">'muted'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token string">'Distribution of Severity Levels by Attack Type'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>xlabel<span class="token punctuation">(</span><span class="token string">'Attack Type'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>ylabel<span class="token punctuation">(</span><span class="token string">'Count'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 获取图例对象</span>legend <span class="token operator">=</span> plt<span class="token punctuation">.</span>legend<span class="token punctuation">(</span>title<span class="token operator">=</span><span class="token string">'Severity Level'</span><span class="token punctuation">,</span> title_fontsize<span class="token operator">=</span><span class="token string">'14'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 设置图例文字的颜色为黑色</span><span class="token keyword">for</span> text <span class="token keyword">in</span> legend<span class="token punctuation">.</span>get_texts<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    text<span class="token punctuation">.</span>set_color<span class="token punctuation">(</span><span class="token string">'black'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 设置标题的字体颜色</span>legend<span class="token punctuation">.</span>get_title<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>set_color<span class="token punctuation">(</span><span class="token string">'black'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>tight_layout<span class="token punctuation">(</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/Bevis23/blog-pic/%E6%94%BB%E5%87%BB%E7%B1%BB%E5%9E%8B%E4%B8%A5%E9%87%8D%E7%BA%A7.png" alt></p><p>从上图中，我们可以得出以下结论：</p><ol><li><strong>Malware 攻击</strong>：这类攻击主要是中等，低高级攻击较少。</li><li><strong>DDoS 攻击</strong>：这类攻击的严重性级别分布相对均匀，但高级攻击略多中低级攻击。</li><li><strong>Intrusion 攻击</strong>：这类攻击中高级较低级相对多一些</li></ol><p>柱形图没有特别起伏大的柱状，但是高低依旧清晰可见，如此结论足矣</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 分析哪些网络段受到了最多的攻击，绘制攻击在不同网段的分布</span>plt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span>figsize<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span>sns<span class="token punctuation">.</span>countplot<span class="token punctuation">(</span>x<span class="token operator">=</span><span class="token string">'Network Segment'</span><span class="token punctuation">,</span> hue<span class="token operator">=</span><span class="token string">'Attack Type'</span><span class="token punctuation">,</span> data<span class="token operator">=</span>dataset<span class="token punctuation">,</span> palette<span class="token operator">=</span><span class="token string">'pastel'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token string">'Distribution of Attack Types by Network Segment'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>xlabel<span class="token punctuation">(</span><span class="token string">'Network Segment'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>ylabel<span class="token punctuation">(</span><span class="token string">'Count'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 获取图例对象</span>legend <span class="token operator">=</span> plt<span class="token punctuation">.</span>legend<span class="token punctuation">(</span>title<span class="token operator">=</span><span class="token string">'Attack Type'</span><span class="token punctuation">,</span> title_fontsize<span class="token operator">=</span><span class="token string">'14'</span><span class="token punctuation">)</span>legend<span class="token punctuation">.</span>get_title<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>set_color<span class="token punctuation">(</span><span class="token string">'black'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 设置图例文字的颜色为黑色</span><span class="token keyword">for</span> text <span class="token keyword">in</span> legend<span class="token punctuation">.</span>get_texts<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    text<span class="token punctuation">.</span>set_color<span class="token punctuation">(</span><span class="token string">'black'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>tight_layout<span class="token punctuation">(</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/Bevis23/blog-pic/%E6%94%BB%E5%87%BB%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%BD%91%E6%AE%B5%E5%88%86%E5%B8%83.png" alt></p><p>从上图中，可分析各个网段，受哪种攻击较多</p><p>a类网段受malware攻击较多</p><p>b类网段受intrusion攻击较多</p><p>c类网段三种攻击接近持平</p><h1 id="流量类型分类"><a href="#流量类型分类" class="headerlink" title="流量类型分类"></a>流量类型分类</h1><p>分析不同类型的网络流量（如 HTTP, DNS 等）在数据集中的分布。</p><h2 id="流量类型分布"><a href="#流量类型分布" class="headerlink" title="流量类型分布"></a>流量类型分布</h2><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 统计每种流量类型的频率</span>traffic_type_counts <span class="token operator">=</span> dataset_cleaned<span class="token punctuation">[</span><span class="token string">'Traffic Type'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>value_counts<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>reset_index<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>rename<span class="token punctuation">(</span>columns<span class="token operator">=</span><span class="token punctuation">{</span><span class="token string">'index'</span><span class="token punctuation">:</span> <span class="token string">'Traffic Type'</span><span class="token punctuation">,</span> <span class="token string">'Traffic Type'</span><span class="token punctuation">:</span> <span class="token string">'Count'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 创建流量类型的条形图</span>plt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span>figsize<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span>sns<span class="token punctuation">.</span>barplot<span class="token punctuation">(</span>x<span class="token operator">=</span><span class="token string">'Traffic Type'</span><span class="token punctuation">,</span> y<span class="token operator">=</span><span class="token string">'Count'</span><span class="token punctuation">,</span> data<span class="token operator">=</span>traffic_type_counts<span class="token punctuation">,</span> palette<span class="token operator">=</span><span class="token string">'coolwarm'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token string">'Distribution of Traffic Types'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span> </code></pre><p><img src="https://cdn.jsdelivr.net/gh/Bevis23/blog-pic/%E6%B5%81%E9%87%8F%E7%B1%BB%E5%9E%8B.png" alt></p><p>额……出来的条形图怎么肉眼有点看不出区别呀￣□￣｜｜ 有点尴尬，</p><p>这时候，想到的就是三种类型的count差异不大，这时候就添加如下代码</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 添加具体数值标签</span><span class="token keyword">for</span> p <span class="token keyword">in</span> ax<span class="token punctuation">.</span>patches<span class="token punctuation">:</span>    ax<span class="token punctuation">.</span>annotate<span class="token punctuation">(</span>f<span class="token string">'{int(p.get_height())}'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>get_x<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> p<span class="token punctuation">.</span>get_width<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">.</span><span class="token punctuation">,</span> p<span class="token punctuation">.</span>get_height<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ha<span class="token operator">=</span><span class="token string">'center'</span><span class="token punctuation">,</span> va<span class="token operator">=</span><span class="token string">'baseline'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 代码解释</span><span class="token comment" spellcheck="true"># ax.patches 是一个包含所有图形元素的列表</span><span class="token comment" spellcheck="true"># ax.annotate内部参数</span><span class="token comment" spellcheck="true"># 参数1，使用f-string将条形的高度转换为整数，并将其作为文本显示。</span><span class="token comment" spellcheck="true"># 参数2，将文本标签放在条形的中间位置，高度为p.get_height()</span><span class="token comment" spellcheck="true"># 参数3，对齐方式 ha水平 va垂直</span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/Bevis23/blog-pic/%E6%B5%81%E9%87%8F%E7%B1%BB%E5%9E%8B2.png" alt></p><p>这时候，条形统计图，每个柱体上都有清晰的数值大小，从图和数值可以看出，DNS流量是最常见的，其次是 HTTP,最后便是ftp。</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 设置标题颜色为白色</span>plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token string">'Distribution of Traffic Types'</span><span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token string">'white'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 设置x轴标签和颜色</span>plt<span class="token punctuation">.</span>xlabel<span class="token punctuation">(</span><span class="token string">'Traffic Type'</span><span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token string">'white'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 设置y轴标签和颜色</span>plt<span class="token punctuation">.</span>ylabel<span class="token punctuation">(</span><span class="token string">'Count'</span><span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token string">'white'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 设置坐标轴刻度标签颜色为白色</span>plt<span class="token punctuation">.</span>tick_params<span class="token punctuation">(</span>axis<span class="token operator">=</span><span class="token string">'x'</span><span class="token punctuation">,</span> colors<span class="token operator">=</span><span class="token string">'white'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>tick_params<span class="token punctuation">(</span>axis<span class="token operator">=</span><span class="token string">'y'</span><span class="token punctuation">,</span> colors<span class="token operator">=</span><span class="token string">'white'</span><span class="token punctuation">)</span></code></pre><h1 id="前三特征总结"><a href="#前三特征总结" class="headerlink" title="前三特征总结"></a>前三特征总结</h1><p>通过分析，得出了以下几点：</p><ol><li><strong>热图分析</strong>: 识别了出现次数最多的前 10 个源和目的 IP 地址。</li><li><strong>攻击特征与类型</strong>: 受最多的类型攻击为ddos攻击，流量特征方面需持续监控。</li><li><strong>流量类型</strong>: DNS 是最常见的流量类型，这可能意味着大多数网络活动是 DNS 查询或域名解析。</li></ol><p>基于这些信息：</p><ul><li>关注高频 IP 地址：识别出现次数最多的前 10 个源和目的 IP 地址，并对这些 IP 地址进行进一步的监控或安全审查。这有助于提高对可能存在的潜在威胁的感知，并采取必要的行动。</li><li>持续监控数据以识别潜在的恶意活动：维持对网络流量的持续监控，使用威胁情报和异常检测系统来识别任何可能的恶意活动。通过实时监测和分析数据，可以及早发现和应对潜在的威胁，确保网络的安全性。</li><li>优化网络性能和安全措施，特别是针对 DNS 流量：基于对 DNS 流量的分析，对网络进行优化和强化安全措施。例如，确保 DNS 服务器的稳定性和高可用性，优化 DNS 解析速度，防止 DNS 劫持等。</li></ul><h1 id="其他特征分析"><a href="#其他特征分析" class="headerlink" title="其他特征分析"></a>其他特征分析</h1><h1 id="异常检测"><a href="#异常检测" class="headerlink" title="异常检测"></a>异常检测</h1><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 基于“异常分数”字段的异常检测，通常，离平均值3个标准差被认为是异常</span>anomaly_threshold <span class="token operator">=</span> dataset<span class="token punctuation">[</span><span class="token string">'Anomaly Scores'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>mean<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">3</span> <span class="token operator">*</span> dataset<span class="token punctuation">[</span><span class="token string">'Anomaly Scores'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>std<span class="token punctuation">(</span><span class="token punctuation">)</span> anomalies <span class="token operator">=</span> dataset<span class="token punctuation">[</span>dataset<span class="token punctuation">[</span><span class="token string">'Anomaly Scores'</span><span class="token punctuation">]</span> <span class="token operator">></span> anomaly_threshold<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 异常计数</span>anomaly_count <span class="token operator">=</span> anomalies<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 异常的基本细节</span>anomalies_details <span class="token operator">=</span> anomalies<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">'Timestamp'</span><span class="token punctuation">,</span> <span class="token string">'Source IP Address'</span><span class="token punctuation">,</span> <span class="token string">'Destination IP Address'</span><span class="token punctuation">,</span> <span class="token string">'Source Port'</span><span class="token punctuation">,</span> <span class="token string">'Destination Port'</span><span class="token punctuation">,</span> <span class="token string">'Protocol'</span><span class="token punctuation">,</span> <span class="token string">'Anomaly Scores'</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span>head<span class="token punctuation">(</span><span class="token punctuation">)</span>anomaly_count<span class="token punctuation">,</span> anomalies_details  </code></pre><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 输出</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> Empty DataFrame Columns<span class="token punctuation">:</span> <span class="token punctuation">[</span>Timestamp<span class="token punctuation">,</span> Source IP Address<span class="token punctuation">,</span> Destination IP Address<span class="token punctuation">,</span> Source Port<span class="token punctuation">,</span> Destination Port<span class="token punctuation">,</span> Protocol<span class="token punctuation">,</span> Anomaly Scores<span class="token punctuation">]</span> Index<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p>根据“异常分数”字段进行的异常检测的输出，没有检测到超过阈值的异常流量。这个阈值是基于异常分数的平均值加上三倍的标准偏差计算。</p><h1 id="协议分析"><a href="#协议分析" class="headerlink" title="协议分析"></a>协议分析</h1><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 协议分析:确定最常用的协议，并检查任何非标准协议</span><span class="token comment" spellcheck="true"># 计算每个协议的出现次数</span>protocol_counts <span class="token operator">=</span> data<span class="token punctuation">[</span><span class="token string">'Protocol'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>value_counts<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 计算每个协议的出现次数</span>standard_protocols <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'TCP'</span><span class="token punctuation">,</span> <span class="token string">'UDP'</span><span class="token punctuation">,</span> <span class="token string">'ICMP'</span><span class="token punctuation">,</span> <span class="token string">'HTTP'</span><span class="token punctuation">,</span> <span class="token string">'HTTPS'</span><span class="token punctuation">,</span> <span class="token string">'FTP'</span><span class="token punctuation">,</span> <span class="token string">'SSH'</span><span class="token punctuation">,</span> <span class="token string">'TELNET'</span><span class="token punctuation">,</span> <span class="token string">'SMTP'</span><span class="token punctuation">,</span> <span class="token string">'DNS'</span><span class="token punctuation">]</span>non_standard_protocols <span class="token operator">=</span> protocol_counts<span class="token punctuation">[</span><span class="token operator">~</span>protocol_counts<span class="token punctuation">.</span>index<span class="token punctuation">.</span>isin<span class="token punctuation">(</span>standard_protocols<span class="token punctuation">)</span><span class="token punctuation">]</span>protocol_counts<span class="token punctuation">,</span> non_standard_protocols</code></pre><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 输出</span><span class="token punctuation">(</span>ICMP    <span class="token number">13429</span> UDP     <span class="token number">13299</span> TCP     <span class="token number">13272</span> Name<span class="token punctuation">:</span> Protocol<span class="token punctuation">,</span> dtype<span class="token punctuation">:</span> int64<span class="token punctuation">,</span> Series<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> Name<span class="token punctuation">:</span> Protocol<span class="token punctuation">,</span> dtype<span class="token punctuation">:</span> int64<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>输出结果显示，此数据集中最常见的协议是 ICMP、UDP 和 TCP。没有检测到任何非标准协议。</p><h1 id="威胁情报对接分析"><a href="#威胁情报对接分析" class="headerlink" title="威胁情报对接分析"></a>威胁情报对接分析</h1><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 威胁情报匹配:检查来自已知恶意IP地址的流量，检查“恶意软件指示器”字段是否包含任何非空值</span>malware_indicators_exists <span class="token operator">=</span> dataset<span class="token punctuation">[</span><span class="token string">'Malware Indicators'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>notna<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>any<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 如果有恶意软件的迹象，我们过滤这些记录</span>malicious_traffic <span class="token operator">=</span> pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">if</span> malware_indicators_exists<span class="token punctuation">:</span>    malicious_traffic <span class="token operator">=</span> dataset<span class="token punctuation">[</span>dataset<span class="token punctuation">[</span><span class="token string">'Malware Indicators'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>notna<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 恶意流量记录计数</span>malicious_count <span class="token operator">=</span> malicious_traffic<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 恶意流量的基本细节，如果存在的话</span>malicious_details <span class="token operator">=</span> pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">if</span> <span class="token operator">not</span> malicious_traffic<span class="token punctuation">.</span>empty<span class="token punctuation">:</span>    malicious_details <span class="token operator">=</span> malicious_traffic<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">'Timestamp'</span><span class="token punctuation">,</span> <span class="token string">'Source IP Address'</span><span class="token punctuation">,</span> <span class="token string">'Malware Indicators'</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span>head<span class="token punctuation">(</span><span class="token punctuation">)</span>malware_indicators_exists<span class="token punctuation">,</span> malicious_count<span class="token punctuation">,</span> malicious_details</code></pre><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 输出</span><span class="token punctuation">(</span><span class="token boolean">True</span><span class="token punctuation">,</span> <span class="token number">20000</span><span class="token punctuation">,</span>              Timestamp Source IP Address Malware Indicators <span class="token number">0</span>  <span class="token number">2023</span><span class="token operator">-</span><span class="token number">05</span><span class="token operator">-</span><span class="token number">30</span> <span class="token number">06</span><span class="token punctuation">:</span><span class="token number">33</span><span class="token punctuation">:</span><span class="token number">58</span>     <span class="token number">103.216</span><span class="token punctuation">.</span><span class="token number">15.12</span>       IoC Detected <span class="token number">1</span>  <span class="token number">2020</span><span class="token operator">-</span><span class="token number">08</span><span class="token operator">-</span><span class="token number">26</span> <span class="token number">07</span><span class="token punctuation">:</span><span class="token number">08</span><span class="token punctuation">:</span><span class="token number">30</span>    <span class="token number">78.199</span><span class="token punctuation">.</span><span class="token number">217.198</span>       IoC Detected <span class="token number">2</span>  <span class="token number">2022</span><span class="token operator">-</span><span class="token number">11</span><span class="token operator">-</span><span class="token number">13</span> <span class="token number">08</span><span class="token punctuation">:</span><span class="token number">23</span><span class="token punctuation">:</span><span class="token number">25</span>      <span class="token number">63.79</span><span class="token punctuation">.</span><span class="token number">210.48</span>       IoC Detected <span class="token number">7</span>  <span class="token number">2023</span><span class="token operator">-</span><span class="token number">02</span><span class="token operator">-</span><span class="token number">12</span> <span class="token number">07</span><span class="token punctuation">:</span><span class="token number">13</span><span class="token punctuation">:</span><span class="token number">17</span>      <span class="token number">11.48</span><span class="token punctuation">.</span><span class="token number">99.245</span>       IoC Detected <span class="token number">8</span>  <span class="token number">2023</span><span class="token operator">-</span><span class="token number">06</span><span class="token operator">-</span><span class="token number">27</span> <span class="token number">11</span><span class="token punctuation">:</span><span class="token number">02</span><span class="token punctuation">:</span><span class="token number">56</span>     <span class="token number">49.32</span><span class="token punctuation">.</span><span class="token number">208.167</span>       IoC Detected<span class="token punctuation">)</span></code></pre><p>威胁情报对接分析显示，“恶意软件指标”字段中确实存在非空值。总共有 20,000 条记录显示了恶意活动的迹象（指标为 “IoC Detected”）</p><h1 id="端口使用分析"><a href="#端口使用分析" class="headerlink" title="端口使用分析"></a>端口使用分析</h1><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 分析“源端口”和“目的端口”，以了解最活跃的端口</span>source_port_counts <span class="token operator">=</span> dataset<span class="token punctuation">[</span><span class="token string">'Source Port'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>value_counts<span class="token punctuation">(</span><span class="token punctuation">)</span>destination_port_counts <span class="token operator">=</span> dataset<span class="token punctuation">[</span><span class="token string">'Destination Port'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>value_counts<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 结合计数进行全面概述</span>combined_port_counts <span class="token operator">=</span> source_port_counts<span class="token punctuation">.</span>add<span class="token punctuation">(</span>destination_port_counts<span class="token punctuation">,</span> fill_value<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 最活跃的5个端口</span>top_ports <span class="token operator">=</span> combined_port_counts<span class="token punctuation">.</span>nlargest<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 检查任何不常见但开放的端口(如果端口少于5条记录，则端口不常见)</span>uncommon_ports <span class="token operator">=</span> combined_port_counts<span class="token punctuation">[</span>combined_port_counts <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">]</span>top_ports<span class="token punctuation">,</span> uncommon_ports</code></pre><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 输出</span><span class="token punctuation">(</span><span class="token number">1547</span>     <span class="token number">7.0</span> <span class="token number">3120</span>     <span class="token number">7.0</span> <span class="token number">8653</span>     <span class="token number">7.0</span> <span class="token number">10530</span>    <span class="token number">7.0</span> <span class="token number">14155</span>    <span class="token number">7.0</span> dtype<span class="token punctuation">:</span> float64<span class="token punctuation">,</span> <span class="token number">1024</span>     <span class="token number">1.0</span> <span class="token number">1025</span>     <span class="token number">1.0</span> <span class="token number">1027</span>     <span class="token number">1.0</span> <span class="token number">1028</span>     <span class="token number">2.0</span> <span class="token number">1029</span>     <span class="token number">1.0</span>         <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token number">65529</span>    <span class="token number">1.0</span> <span class="token number">65530</span>    <span class="token number">2.0</span> <span class="token number">65532</span>    <span class="token number">1.0</span> <span class="token number">65534</span>    <span class="token number">2.0</span> <span class="token number">65535</span>    <span class="token number">2.0</span> Length<span class="token punctuation">:</span> <span class="token number">45321</span><span class="token punctuation">,</span> dtype<span class="token punctuation">:</span> float64<span class="token punctuation">)</span></code></pre><p>通过输出数据：</p><ul><li>最活跃的端口是 1547、3120、8653、10530 和 14155，每个端口都有 7 个条目（源端口和目的端口的组合）表明这些端口频繁用于网络通信。。</li><li>有大量不常用但开放的端口，每个端口的记录少于 5 条。这可能表明网络中有大量不常用的开放端口，这种情况可能会增加网络的安全风险，因为攻击者可能会利用这些少见的开放端口进行攻击。 </li></ul><h1 id="设备类型分析"><a href="#设备类型分析" class="headerlink" title="设备类型分析"></a>设备类型分析</h1><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> re<span class="token comment" spellcheck="true"># 从“设备信息”中提取设备类型</span>device_info <span class="token operator">=</span> dataset<span class="token punctuation">[</span><span class="token string">'Device Information'</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 根据用户代理字符串中的常见类型对设备进行分类</span>device_types <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token string">'Windows'</span><span class="token punctuation">:</span> device_info<span class="token punctuation">.</span>str<span class="token punctuation">.</span>contains<span class="token punctuation">(</span><span class="token string">'Windows'</span><span class="token punctuation">,</span> flags<span class="token operator">=</span>re<span class="token punctuation">.</span>IGNORECASE<span class="token punctuation">,</span> regex<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">.</span>sum<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token string">'Mac'</span><span class="token punctuation">:</span> device_info<span class="token punctuation">.</span>str<span class="token punctuation">.</span>contains<span class="token punctuation">(</span><span class="token string">'Mac'</span><span class="token punctuation">,</span> flags<span class="token operator">=</span>re<span class="token punctuation">.</span>IGNORECASE<span class="token punctuation">,</span> regex<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">.</span>sum<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token string">'Linux'</span><span class="token punctuation">:</span> device_info<span class="token punctuation">.</span>str<span class="token punctuation">.</span>contains<span class="token punctuation">(</span><span class="token string">'Linux'</span><span class="token punctuation">,</span> flags<span class="token operator">=</span>re<span class="token punctuation">.</span>IGNORECASE<span class="token punctuation">,</span> regex<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">.</span>sum<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token string">'Mobile'</span><span class="token punctuation">:</span> device_info<span class="token punctuation">.</span>str<span class="token punctuation">.</span>contains<span class="token punctuation">(</span><span class="token string">'Mobile|Android|iPhone|BlackBerry'</span><span class="token punctuation">,</span> flags<span class="token operator">=</span>re<span class="token punctuation">.</span>IGNORECASE<span class="token punctuation">,</span> regex<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">.</span>sum<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token string">'Other'</span><span class="token punctuation">:</span> device_info<span class="token punctuation">.</span>str<span class="token punctuation">.</span>contains<span class="token punctuation">(</span><span class="token string">'bot|crawler|spider|robot|cURL|python|java'</span><span class="token punctuation">,</span> flags<span class="token operator">=</span>re<span class="token punctuation">.</span>IGNORECASE<span class="token punctuation">,</span> regex<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">.</span>sum<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true"># 确定最常见的设备类型</span>most_common_device <span class="token operator">=</span> max<span class="token punctuation">(</span>device_types<span class="token punctuation">,</span> key<span class="token operator">=</span>device_types<span class="token punctuation">.</span>get<span class="token punctuation">)</span>most_common_device<span class="token punctuation">,</span> device_types</code></pre><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 输出</span><span class="token punctuation">(</span><span class="token string">'Windows'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token string">'Windows'</span><span class="token punctuation">:</span> <span class="token number">17953</span><span class="token punctuation">,</span> <span class="token string">'Mac'</span><span class="token punctuation">:</span> <span class="token number">11587</span><span class="token punctuation">,</span> <span class="token string">'Linux'</span><span class="token punctuation">:</span> <span class="token number">8840</span><span class="token punctuation">,</span> <span class="token string">'Mobile'</span><span class="token punctuation">:</span> <span class="token number">9063</span><span class="token punctuation">,</span> <span class="token string">'Other'</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>通过输出数据分析：</p><ul><li><p>“Windows” 设备是最常见的，共有 17,953 个条目。</p></li><li><p>其次是 “Mac” 设备，有 11,587 个条目。</p></li><li><p>“Mobile” 设备（包括 Android、iPhone 和 BlackBerry）有 9,063 个条目。</p></li><li><p>“Linux” 设备有 8,840 个条目。</p></li><li><p>没有检测到明显的爬虫或机器人流量（如 bot、crawler、spider、robot、cURL、python、java 等）。</p><p>Windows 设备在网络中最为常见，其次是 Mac 和移动设备，对于设备的差异， 可以分析不同设备类型的用户行为差异 </p></li></ul><blockquote><p>这些数据可能并不全面，鉴于设备类型是通过用户代理字符串中的关键词进行分类的，而这些字符串可以被修改或伪造。</p></blockquote><h1 id="用户-应用行为分析"><a href="#用户-应用行为分析" class="headerlink" title="用户-应用行为分析"></a>用户-应用行为分析</h1><p>数据集中没有直接关于应用类型的字段，可以根据其他相关字段（如 “设备信息”、”目的 IP 地址” 或 “协议”）进行推断。</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 提取应用程序数据</span>app_data_exists <span class="token operator">=</span> dataset<span class="token punctuation">[</span><span class="token string">'Device Information'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>str<span class="token punctuation">.</span>contains<span class="token punctuation">(</span><span class="token string">'MSIE|Firefox|Chrome|Safari|Edge|Opera'</span><span class="token punctuation">,</span> flags<span class="token operator">=</span>re<span class="token punctuation">.</span>IGNORECASE<span class="token punctuation">,</span> regex<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">.</span>any<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 如果应用数据存在，则对其进行分类</span>app_data <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">if</span> app_data_exists<span class="token punctuation">:</span>    app_data <span class="token operator">=</span> <span class="token punctuation">{</span>        <span class="token string">'MSIE'</span><span class="token punctuation">:</span> device_info<span class="token punctuation">.</span>str<span class="token punctuation">.</span>contains<span class="token punctuation">(</span><span class="token string">'MSIE'</span><span class="token punctuation">,</span> flags<span class="token operator">=</span>re<span class="token punctuation">.</span>IGNORECASE<span class="token punctuation">,</span> regex<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">.</span>sum<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token string">'Firefox'</span><span class="token punctuation">:</span> device_info<span class="token punctuation">.</span>str<span class="token punctuation">.</span>contains<span class="token punctuation">(</span><span class="token string">'Firefox'</span><span class="token punctuation">,</span> flags<span class="token operator">=</span>re<span class="token punctuation">.</span>IGNORECASE<span class="token punctuation">,</span> regex<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">.</span>sum<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token string">'Chrome'</span><span class="token punctuation">:</span> device_info<span class="token punctuation">.</span>str<span class="token punctuation">.</span>contains<span class="token punctuation">(</span><span class="token string">'Chrome'</span><span class="token punctuation">,</span> flags<span class="token operator">=</span>re<span class="token punctuation">.</span>IGNORECASE<span class="token punctuation">,</span> regex<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">.</span>sum<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token string">'Safari'</span><span class="token punctuation">:</span> device_info<span class="token punctuation">.</span>str<span class="token punctuation">.</span>contains<span class="token punctuation">(</span><span class="token string">'Safari'</span><span class="token punctuation">,</span> regex<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">.</span>sum<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">#  Safari字符串也是Chrome UA的一部分，区分大小写匹配</span>        <span class="token string">'Edge'</span><span class="token punctuation">:</span> device_info<span class="token punctuation">.</span>str<span class="token punctuation">.</span>contains<span class="token punctuation">(</span><span class="token string">'Edge'</span><span class="token punctuation">,</span> flags<span class="token operator">=</span>re<span class="token punctuation">.</span>IGNORECASE<span class="token punctuation">,</span> regex<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">.</span>sum<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token string">'Opera'</span><span class="token punctuation">:</span> device_info<span class="token punctuation">.</span>str<span class="token punctuation">.</span>contains<span class="token punctuation">(</span><span class="token string">'Opera'</span><span class="token punctuation">,</span> flags<span class="token operator">=</span>re<span class="token punctuation">.</span>IGNORECASE<span class="token punctuation">,</span> regex<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">.</span>sum<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true"># 检测是否可以继续进行用户应用程序行为分析</span>can_proceed_with_user_app_analysis <span class="token operator">=</span> <span class="token string">'User Information'</span> <span class="token keyword">in</span> dataset<span class="token punctuation">.</span>columns <span class="token operator">and</span> app_data_existsapp_data_exists<span class="token punctuation">,</span> app_data<span class="token punctuation">,</span> can_proceed_with_user_app_analysis</code></pre><p>从 “设备信息” 字段中提取应用数据，并且数据集中包含 “用户信息” 字段，由此可以进行用户-应用行为分析。分析哪些用户更倾向于使用哪种类型的浏览器。</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 根据应用程序数据添加一个新列'Browser'</span>browsers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'MSIE'</span><span class="token punctuation">,</span> <span class="token string">'Firefox'</span><span class="token punctuation">,</span> <span class="token string">'Chrome'</span><span class="token punctuation">,</span> <span class="token string">'Safari'</span><span class="token punctuation">,</span> <span class="token string">'Edge'</span><span class="token punctuation">,</span> <span class="token string">'Opera'</span><span class="token punctuation">]</span><span class="token keyword">for</span> browser <span class="token keyword">in</span> browsers<span class="token punctuation">:</span>    dataset<span class="token punctuation">.</span>loc<span class="token punctuation">[</span>dataset<span class="token punctuation">[</span><span class="token string">'Device Information'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>str<span class="token punctuation">.</span>contains<span class="token punctuation">(</span>browser<span class="token punctuation">,</span> case<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'Browser'</span><span class="token punctuation">]</span> <span class="token operator">=</span> browser<span class="token comment" spellcheck="true"># 因为'Safari'字符串也是'Chrome'用户代理的一部分，需要专门处理这种数据</span>dataset<span class="token punctuation">.</span>loc<span class="token punctuation">[</span>dataset<span class="token punctuation">[</span><span class="token string">'Device Information'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>str<span class="token punctuation">.</span>contains<span class="token punctuation">(</span><span class="token string">'Chrome'</span><span class="token punctuation">,</span> case<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>          <span class="token operator">~</span>dataset<span class="token punctuation">[</span><span class="token string">'Device Information'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>str<span class="token punctuation">.</span>contains<span class="token punctuation">(</span><span class="token string">'Edge'</span><span class="token punctuation">,</span> case<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'Browser'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'Chrome'</span>dataset<span class="token punctuation">.</span>loc<span class="token punctuation">[</span>dataset<span class="token punctuation">[</span><span class="token string">'Device Information'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>str<span class="token punctuation">.</span>contains<span class="token punctuation">(</span><span class="token string">'Safari'</span><span class="token punctuation">,</span> case<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>          <span class="token operator">~</span>dataset<span class="token punctuation">[</span><span class="token string">'Device Information'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>str<span class="token punctuation">.</span>contains<span class="token punctuation">(</span><span class="token string">'Chrome'</span><span class="token punctuation">,</span> case<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'Browser'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'Safari'</span><span class="token comment" spellcheck="true"># 分析哪些用户正在使用哪些浏览器</span>user_browser <span class="token operator">=</span> dataset<span class="token punctuation">.</span>groupby<span class="token punctuation">(</span><span class="token string">'User Information'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token string">'Browser'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>apply<span class="token punctuation">(</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span> x<span class="token punctuation">.</span>mode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>iloc<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token keyword">if</span> <span class="token operator">not</span> x<span class="token punctuation">.</span>mode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>empty <span class="token keyword">else</span> None<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 每种浏览器类型的前5名用户</span>top_users_per_browser <span class="token operator">=</span> user_browser<span class="token punctuation">.</span>value_counts<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>nlargest<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 准备最终结果</span>user_app_behavior <span class="token operator">=</span> user_browser<span class="token punctuation">.</span>reset_index<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>groupby<span class="token punctuation">(</span><span class="token string">'Browser'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token string">'User Information'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>apply<span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">.</span>to_dict<span class="token punctuation">(</span><span class="token punctuation">)</span>top_users <span class="token operator">=</span> top_users_per_browser<span class="token punctuation">.</span>to_dict<span class="token punctuation">(</span><span class="token punctuation">)</span>top_users<span class="token punctuation">,</span> <span class="token punctuation">{</span>k<span class="token punctuation">:</span> v<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token keyword">for</span> k<span class="token punctuation">,</span> v <span class="token keyword">in</span> user_app_behavior<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span>  <span class="token comment" spellcheck="true"># 由于空间限制，每个类别只显示前5个用户</span></code></pre><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 输出，该结果已进行每种浏览器类型的用户数量排序，并输出每种浏览器类型的前5名用户列表，对于可视化，看情况而定，这里再做个饼图分析占比</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">'Safari'</span><span class="token punctuation">:</span> <span class="token number">7725</span><span class="token punctuation">,</span>  <span class="token string">'MSIE'</span><span class="token punctuation">:</span> <span class="token number">6643</span><span class="token punctuation">,</span>  <span class="token string">'Opera'</span><span class="token punctuation">:</span> <span class="token number">6169</span><span class="token punctuation">,</span>  <span class="token string">'Chrome'</span><span class="token punctuation">:</span> <span class="token number">6159</span><span class="token punctuation">,</span>  <span class="token string">'Firefox'</span><span class="token punctuation">:</span> <span class="token number">5693</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token string">'Chrome'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'Aaina Babu'</span><span class="token punctuation">,</span>   <span class="token string">'Aaina Bala'</span><span class="token punctuation">,</span>   <span class="token string">'Aaina Bath'</span><span class="token punctuation">,</span>   <span class="token string">'Aaina Desai'</span><span class="token punctuation">,</span>   <span class="token string">'Aaina Deshpande'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token string">'Firefox'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'Aaina Bal'</span><span class="token punctuation">,</span>   <span class="token string">'Aaina Baria'</span><span class="token punctuation">,</span>   <span class="token string">'Aaina Bedi'</span><span class="token punctuation">,</span>   <span class="token string">'Aaina Behl'</span><span class="token punctuation">,</span>   <span class="token string">'Aaina Chana'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token string">'MSIE'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'Aaina Arya'</span><span class="token punctuation">,</span>   <span class="token string">'Aaina Balasubramanian'</span><span class="token punctuation">,</span>   <span class="token string">'Aaina Bansal'</span><span class="token punctuation">,</span>   <span class="token string">'Aaina Bhatia'</span><span class="token punctuation">,</span>   <span class="token string">'Aaina Biswas'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token string">'Opera'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'Aaina Ahluwalia'</span><span class="token punctuation">,</span>   <span class="token string">'Aaina Bahri'</span><span class="token punctuation">,</span>   <span class="token string">'Aaina Bakshi'</span><span class="token punctuation">,</span>   <span class="token string">'Aaina Batta'</span><span class="token punctuation">,</span>   <span class="token string">'Aaina Bhatti'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token string">'Safari'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'Aaina Bahl'</span><span class="token punctuation">,</span>   <span class="token string">'Aaina Balan'</span><span class="token punctuation">,</span>   <span class="token string">'Aaina Bhargava'</span><span class="token punctuation">,</span>   <span class="token string">'Aaina Choudhury'</span><span class="token punctuation">,</span>   <span class="token string">'Aaina Dada'</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token comment" spellcheck="true"># 浏览器类型及其用户数量数据</span>browser_data <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token string">'Safari'</span><span class="token punctuation">:</span> <span class="token number">7725</span><span class="token punctuation">,</span>    <span class="token string">'MSIE'</span><span class="token punctuation">:</span> <span class="token number">6643</span><span class="token punctuation">,</span>    <span class="token string">'Opera'</span><span class="token punctuation">:</span> <span class="token number">6169</span><span class="token punctuation">,</span>    <span class="token string">'Chrome'</span><span class="token punctuation">:</span> <span class="token number">6159</span><span class="token punctuation">,</span>    <span class="token string">'Firefox'</span><span class="token punctuation">:</span> <span class="token number">5693</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true"># 饼图标签（浏览器类型）</span>labels <span class="token operator">=</span> browser_data<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 饼图数据（用户数量）</span>sizes <span class="token operator">=</span> browser_data<span class="token punctuation">.</span>values<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 绘制饼图</span>plt<span class="token punctuation">.</span>pie<span class="token punctuation">(</span>sizes<span class="token punctuation">,</span> labels<span class="token operator">=</span>labels<span class="token punctuation">,</span> autopct<span class="token operator">=</span><span class="token string">'%1.1f%%'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 添加标题</span>plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token string">"Browser Users Distribution"</span><span class="token punctuation">,</span>color<span class="token operator">=</span><span class="token string">'white'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 显示图表</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/Bevis23/blog-pic/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%B1%BB%E5%9E%8B%E4%BD%BF%E7%94%A8%E9%A5%BC%E7%8A%B6%E5%9B%BE.png" alt></p><p>分析结果：</p><ul><li>这个样本中，Safari 浏览器拥有最多的用户数量，占总用户数量的 23.9%。</li><li>排名第二的是 MSIE 浏览器，占20.5%；并排第三的是 Opera、 Chrome浏览器，占 19.0%。</li><li>Firefox 浏览器的用户数量占比最低。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过该数据集，针对不同的特征，做对应的分析，深入了解网络安全威胁的特征和趋势，并从中获取有价值的见解。这样的分析有助于我们更好地理解攻击者的策略和技术，从而能够采取有效的预防和应对措施来保护我们的数字环境。 当然，针对数据的来源于具体的业务方向，可以更加深入，有针对性的分析，以发掘更好的价值。</p><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p>数据来源：kaggle社区公开数据集</p><p>文中代码与csv数据集：  <a href="https://bevis.lanzouq.com/i28Ci1c0eb9i" target="_blank" rel="noopener">https://bevis.lanzouq.com/i28Ci1c0eb9i</a> （文章代码与数据集放压缩包了）</p>]]></content>
      
      
      <categories>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
            <tag> 数据分析 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RFM思维模型与案例解析</title>
      <link href="/shu-fen-rfm-fen-xi-yu-an-li.html"/>
      <url>/shu-fen-rfm-fen-xi-yu-an-li.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>数据分析是当今信息时代的核心驱动力，通过深入挖掘数据，企业能够更好地了解其客户、市场和业务。在这篇博客中，我们将探讨一种强大的数据分析方法，即RFM分析，它是一种用于理解客户行为和价值的工具。我们将首先介绍数据分析的重要性，然后深入研究RFM分析，解释其核心概念，以及在哪些领域它可以发挥关键作用。</p><h1 id="什么是RFM分析？"><a href="#什么是RFM分析？" class="headerlink" title="什么是RFM分析？"></a>什么是RFM分析？</h1><p><strong>RFM分析是一种数据驱动的方法，用于分析和理解客户行为</strong>。它的名称来源于<strong>三个关键指标：Recency（最近一次交易时间）、Frequency（购买频率）和Monetary（购买金额）</strong>。这些指标被广泛应用于各种行业，从零售到电子商务，以帮助企业更好地理解客户，并制定相关的营销策略。</p><h1 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h1><ol><li><p><strong>Recency（最近一次交易时间）</strong>：Recency衡量客户最近一次交易或互动的时间。这是一个关键的指标，因为它反映了客户的活跃度。通常，较近期的交易代表客户更有可能再次购买。</p><p>举例：假设你是一家在线服装店的所有者，你想知道哪些客户最近购买了你的商品。Recency指标将告诉你谁在最近的一段时间内进行了购物。</p></li><li><p><strong>Frequency（购买频率）</strong>：Frequency测量客户在特定时间段内的购买次数。高频率的客户通常更忠诚，因为他们反复购买你的产品或服务。</p><p>举例：继续考虑在线服装店，Frequency指标将揭示哪些客户是经常购物的忠实顾客，哪些则较少购物。</p></li><li><p><strong>Monetary（购买金额）</strong>：Monetary度量客户在一段时间内的总购买金额。购买金额是一个关键的指标，因为它表明客户对你的产品或服务的实际价值。</p><p>举例：通过查看购买金额，你可以发现哪些客户每次购物都花费大量资金，这对于定价和促销策略的制定非常重要。</p></li></ol><p>RFM分析通过综合考虑这三个指标，可以帮助企业识别出不同类型的客户，如忠实客户、潜在客户和流失客户，从而制定有针对性的策略以提高客户满意度和营业额。</p><h1 id="RFM分析的步骤和原理"><a href="#RFM分析的步骤和原理" class="headerlink" title="RFM分析的步骤和原理"></a>RFM分析的步骤和原理</h1><p>RFM分析通常包括以下<strong>四个主要步骤：数据预处理、计算RFM指标、分段划分和用户特征分析</strong></p><h2 id="1-数据预处理"><a href="#1-数据预处理" class="headerlink" title="1. 数据预处理"></a>1. 数据预处理</h2><p>数据预处理是任何数据分析项目的首要任务。在RFM分析中，数据通常来自不同的交易记录，因此需要经过整理和清洗，以确保数据的质量和一致性。</p><ul><li><strong>数据收集</strong>：收集来自不同渠道的交易数据，包括购买日期、交易金额等。</li><li><strong>数据清洗</strong>：识别和处理缺失数据、异常值和重复记录，确保数据的准确性。</li><li><strong>数据筛选</strong>：根据分析的目标，筛选出需要的交易记录信息，通常包括客户ID、交易日期和金额。</li></ul><h2 id="2-计算RFM指标"><a href="#2-计算RFM指标" class="headerlink" title="2. 计算RFM指标"></a>2. 计算RFM指标</h2><p>一旦数据准备就绪，下一步是计算每个客户的RFM指标。这些指标将成为分析客户价值的基础。</p><h3 id="计算Recency（R）"><a href="#计算Recency（R）" class="headerlink" title="计算Recency（R）"></a>计算Recency（R）</h3><p>Recency指标衡量了客户最近一次交易的时间。通常，最近一次交易日期距离当前日期越近的客户，其Recency值越高。</p><h3 id="计算Frequency（F）"><a href="#计算Frequency（F）" class="headerlink" title="计算Frequency（F）"></a>计算Frequency（F）</h3><p>Frequency指标度量了客户在一段时间内的购买频率。高频率购买的客户将具有较高的Frequency值。</p><h3 id="计算Monetary（M）"><a href="#计算Monetary（M）" class="headerlink" title="计算Monetary（M）"></a>计算Monetary（M）</h3><p>Monetary指标代表客户在一段时间内的总购买金额。购买金额高的客户将具有较高的Monetary值。</p><h2 id="3-分段划分"><a href="#3-分段划分" class="headerlink" title="3. 分段划分"></a>3. 分段划分</h2><p>一旦计算出每个客户的RFM值，接下来的任务是将客户分成不同的群体，以便更好地理解他们的特征和行为。分段通常涉及到将每个指标分成若干组，如高、中、低，然后将这些组合起来形成不同的RFM组合。这将帮助我们识别出不同类型的客户，例如：</p><table><thead><tr><th>RFM群组</th><th>最近购买时间（Recency）</th><th>购买频率（Frequency）</th><th>消费金额（Monetary）</th></tr></thead><tbody><tr><td>忠实客户</td><td>高</td><td>高</td><td>高</td></tr><tr><td>潜在客户</td><td>低</td><td>中</td><td>中</td></tr><tr><td>流失客户</td><td>低</td><td>低</td><td>低</td></tr></tbody></table><p>根据上述表格，我们可以看到不同类型客户的RFM指标特征。忠实客户在最近购买时间、购买频率和消费金额方面都表现出较高水平；潜在客户在这些指标上的表现相对中等；而流失客户在这些指标上都表现较低。</p><h2 id="4-用户特征分析"><a href="#4-用户特征分析" class="headerlink" title="4. 用户特征分析"></a>4. 用户特征分析</h2><p>对每个RFM群体进行深入分析，以了解他们的特征和行为。这有利于制定有针对性的营销策略和服务改进措施。例如：</p><ul><li><strong>忠实客户</strong>：我们可以为他们提供专门的奖励计划，以激励他们继续购买。</li><li><strong>潜在客户</strong>：我们可以发送定制的促销信息，以吸引他们成为忠实客户。</li><li><strong>流失客户</strong>：我们可以尝试重新吸引他们通过特殊的优惠和个性化的沟通。</li></ul><h1 id="实战案例"><a href="#实战案例" class="headerlink" title="实战案例"></a>实战案例</h1><blockquote><p>本数据来自kaggle社区开放数据集”Tiktok E-Commerce Data”，鉴于数据集缺少 Recency 这个最近购买日期字段，以下均重点针对 Monetary与Frequency，并针对其他维度做分析 </p><p>数据集源链接：<a href="https://www.kaggle.com/datasets/hanshunfan/tiktok-ecommerce-data" target="_blank" rel="noopener">https://www.kaggle.com/datasets/hanshunfan/tiktok-ecommerce-data</a></p></blockquote><h2 id="步骤1：数据预处理"><a href="#步骤1：数据预处理" class="headerlink" title="步骤1：数据预处理"></a>步骤1：数据预处理</h2><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> pandas <span class="token keyword">as</span> pd<span class="token comment" spellcheck="true"># 读取csv数据集文件</span>file_path <span class="token operator">=</span> <span class="token string">'E:\data\douyin.csv'</span>df <span class="token operator">=</span> pd<span class="token punctuation">.</span>read_csv<span class="token punctuation">(</span>file_path<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 查看数据看字段，查看基本信息</span>df<span class="token punctuation">.</span>head<span class="token punctuation">(</span><span class="token punctuation">)</span>df<span class="token punctuation">.</span>info<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>为了进行RFM分析，主要关注以下几个字段：</p><ul><li><code>user_id</code>: 用户ID，用于标识不同的用户。</li><li><code>gmv</code>: 交易金额，用于计算Monetary值。</li><li><code>unit_sold</code>: 销售数量，可以用于辅助计算Frequency值。</li></ul><p>首先，对数据进行清洗，以便仅保留有用的信息。</p><ol><li>删除没有<code>user_id</code>的记录。</li><li>确保所有数值字段（如<code>gmv</code>和<code>unit_sold</code>）都是数值类型。</li></ol><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 数据清理</span><span class="token comment" spellcheck="true"># 删除'user_id'为NaN的行</span>df_cleaned <span class="token operator">=</span> df<span class="token punctuation">.</span>dropna<span class="token punctuation">(</span>subset<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'user_id'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 确保'gmv'和'unit_sold'是数字</span>df_cleaned<span class="token punctuation">.</span>loc<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token string">'gmv'</span><span class="token punctuation">]</span> <span class="token operator">=</span> pd<span class="token punctuation">.</span>to_numeric<span class="token punctuation">(</span>df_cleaned<span class="token punctuation">[</span><span class="token string">'gmv'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> errors<span class="token operator">=</span><span class="token string">'coerce'</span><span class="token punctuation">)</span>df_cleaned<span class="token punctuation">.</span>loc<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token string">'unit_sold'</span><span class="token punctuation">]</span> <span class="token operator">=</span> pd<span class="token punctuation">.</span>to_numeric<span class="token punctuation">(</span>df_cleaned<span class="token punctuation">[</span><span class="token string">'unit_sold'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> errors<span class="token operator">=</span><span class="token string">'coerce'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 删除以下字段包含NaN值的行</span>df_cleaned <span class="token operator">=</span> df_cleaned<span class="token punctuation">.</span>dropna<span class="token punctuation">(</span>subset<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'user_id'</span><span class="token punctuation">,</span> <span class="token string">'gmv'</span><span class="token punctuation">,</span> <span class="token string">'unit_sold'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 查看清洗后的前5行</span>df_cleaned<span class="token punctuation">.</span>head<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h2 id="步骤2：计算RFM指标"><a href="#步骤2：计算RFM指标" class="headerlink" title="步骤2：计算RFM指标"></a>步骤2：计算RFM指标</h2><p>在这一步，计算每个用户的Recency（最近一次购买）、Frequency（购买频率）和Monetary（消费金额）值。</p><p>由于提供的数据集没有具体的交易日期，无法计算Recency。不过Frequency和Monetary是可以计算的。</p><ul><li><strong>Frequency</strong>: 对每个用户，计算其总的购买次数。</li><li><strong>Monetary</strong>: 对每个用户，计算其总的消费金额（<code>gmv</code>字段）。</li></ul><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 计算每个用户的频率和消费值</span><span class="token comment" spellcheck="true"># frequency:统计每个用户的消费频率</span>frequency_df <span class="token operator">=</span> df_cleaned<span class="token punctuation">.</span>groupby<span class="token punctuation">(</span><span class="token string">'user_id'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token string">'spu_id'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>count<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>reset_index<span class="token punctuation">(</span><span class="token punctuation">)</span>frequency_df<span class="token punctuation">.</span>columns <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'user_id'</span><span class="token punctuation">,</span> <span class="token string">'Frequency'</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># Monetary:汇总每个用户的总GMV</span>monetary_df <span class="token operator">=</span> df_cleaned<span class="token punctuation">.</span>groupby<span class="token punctuation">(</span><span class="token string">'user_id'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token string">'gmv'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>sum<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>reset_index<span class="token punctuation">(</span><span class="token punctuation">)</span>monetary_df<span class="token punctuation">.</span>columns <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'user_id'</span><span class="token punctuation">,</span> <span class="token string">'Monetary'</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 合并频率和货币数据框架</span>rfm_df <span class="token operator">=</span> pd<span class="token punctuation">.</span>merge<span class="token punctuation">(</span>frequency_df<span class="token punctuation">,</span> monetary_df<span class="token punctuation">,</span> on<span class="token operator">=</span><span class="token string">'user_id'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 显示RFM DataFrame的前几行</span>rfm_df<span class="token punctuation">.</span>head<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><pre class=" language-python"><code class="language-python">    user_id    Frequency    Monetary<span class="token number">0</span>    <span class="token number">6.633285e+07</span>    <span class="token number">14</span>    <span class="token number">4608.959091</span><span class="token number">1</span>    <span class="token number">1.000428e+09</span>    <span class="token number">1</span>    <span class="token number">198.000000</span><span class="token number">2</span>    <span class="token number">2.595599e+09</span>    <span class="token number">5</span>    <span class="token number">3588.220000</span><span class="token number">3</span>    <span class="token number">2.613651e+09</span>    <span class="token number">3</span>    <span class="token number">191300.900000</span><span class="token number">4</span>    <span class="token number">2.748420e+09</span>    <span class="token number">2</span>    <span class="token number">164.000000</span></code></pre><h2 id="步骤3：分段划分"><a href="#步骤3：分段划分" class="headerlink" title="步骤3：分段划分"></a>步骤3：分段划分</h2><p>根据Frequency和Monetary值将用户分为不同的群体。通常，这一步使用分位数或自定义阈值来进行。</p><ul><li><strong>高频率、高消费（High Frequency, High Monetary）</strong></li><li><strong>高频率、低消费（High Frequency, Low Monetary）</strong></li><li><strong>低频率、高消费（Low Frequency, High Monetary）</strong></li><li><strong>低频率、低消费（Low Frequency, Low Monetary）</strong></li></ul><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 计算每个用户的消费频率和消费金额</span>frequency_quartiles <span class="token operator">=</span> rfm_df<span class="token punctuation">[</span><span class="token string">'Frequency'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>quantile<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token number">25</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token number">75</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to_dict<span class="token punctuation">(</span><span class="token punctuation">)</span>monetary_quartiles <span class="token operator">=</span> rfm_df<span class="token punctuation">[</span><span class="token string">'Monetary'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>quantile<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token number">25</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token number">75</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to_dict<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 创建一个Segment列，并将其初始化为空字符串</span>rfm_df<span class="token punctuation">[</span><span class="token string">'Segment'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">''</span><span class="token comment" spellcheck="true"># 高频率、高消费</span>rfm_df<span class="token punctuation">.</span>loc<span class="token punctuation">[</span><span class="token punctuation">(</span>rfm_df<span class="token punctuation">[</span><span class="token string">'Frequency'</span><span class="token punctuation">]</span> <span class="token operator">></span> frequency_quartiles<span class="token punctuation">[</span><span class="token number">0.75</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>rfm_df<span class="token punctuation">[</span><span class="token string">'Monetary'</span><span class="token punctuation">]</span> <span class="token operator">></span> monetary_quartiles<span class="token punctuation">[</span><span class="token number">0.75</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'Segment'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'High Frequency, High Monetary'</span><span class="token comment" spellcheck="true"># 高频率、低消费</span>rfm_df<span class="token punctuation">.</span>loc<span class="token punctuation">[</span><span class="token punctuation">(</span>rfm_df<span class="token punctuation">[</span><span class="token string">'Frequency'</span><span class="token punctuation">]</span> <span class="token operator">></span> frequency_quartiles<span class="token punctuation">[</span><span class="token number">0.75</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>rfm_df<span class="token punctuation">[</span><span class="token string">'Monetary'</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> monetary_quartiles<span class="token punctuation">[</span><span class="token number">0.25</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'Segment'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'High Frequency, Low Monetary'</span><span class="token comment" spellcheck="true"># 低频率、高消费</span>rfm_df<span class="token punctuation">.</span>loc<span class="token punctuation">[</span><span class="token punctuation">(</span>rfm_df<span class="token punctuation">[</span><span class="token string">'Frequency'</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> frequency_quartiles<span class="token punctuation">[</span><span class="token number">0.25</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>rfm_df<span class="token punctuation">[</span><span class="token string">'Monetary'</span><span class="token punctuation">]</span> <span class="token operator">></span> monetary_quartiles<span class="token punctuation">[</span><span class="token number">0.75</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'Segment'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'Low Frequency, High Monetary'</span><span class="token comment" spellcheck="true"># 低频率、低消费</span>rfm_df<span class="token punctuation">.</span>loc<span class="token punctuation">[</span><span class="token punctuation">(</span>rfm_df<span class="token punctuation">[</span><span class="token string">'Frequency'</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> frequency_quartiles<span class="token punctuation">[</span><span class="token number">0.25</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>rfm_df<span class="token punctuation">[</span><span class="token string">'Monetary'</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> monetary_quartiles<span class="token punctuation">[</span><span class="token number">0.25</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'Segment'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'Low Frequency, Low Monetary'</span>rfm_df<span class="token punctuation">.</span>head<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><pre class=" language-python"><code class="language-python">    user_id    Frequency    Monetary    Segment<span class="token number">0</span>    <span class="token number">6.633285e+07</span>    <span class="token number">14</span>    <span class="token number">4608.959091</span>    High Frequency<span class="token punctuation">,</span> High Monetary<span class="token number">1</span>    <span class="token number">1.000428e+09</span>    <span class="token number">1</span>    <span class="token number">198.000000</span>    <span class="token number">2</span>    <span class="token number">2.595599e+09</span>    <span class="token number">5</span>    <span class="token number">3588.220000</span>    High Frequency<span class="token punctuation">,</span> High Monetary<span class="token number">3</span>    <span class="token number">2.613651e+09</span>    <span class="token number">3</span>    <span class="token number">191300.900000</span>    <span class="token number">4</span>    <span class="token number">2.748420e+09</span>    <span class="token number">2</span>    <span class="token number">164.000000</span>    </code></pre><p>用户分段已经完成！现在，已经根据Frequency和Monetary值将用户分为了不同的群体。</p><h2 id="步骤4：分析用户特征"><a href="#步骤4：分析用户特征" class="headerlink" title="步骤4：分析用户特征"></a>步骤4：分析用户特征</h2><p>最后一步，将对这些不同的用户群体进行深入分析，以了解其特征和行为。</p><p>计算每个用户群体的平均Frequency和Monetary值。</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 通过计算平均频率和消费值来分析每个部分的特征</span>segment_analysis <span class="token operator">=</span> rfm_df<span class="token punctuation">.</span>groupby<span class="token punctuation">(</span><span class="token string">'Segment'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>agg<span class="token punctuation">(</span><span class="token punctuation">{</span>    <span class="token string">'Frequency'</span><span class="token punctuation">:</span> <span class="token string">'mean'</span><span class="token punctuation">,</span>    <span class="token string">'Monetary'</span><span class="token punctuation">:</span> <span class="token string">'mean'</span><span class="token punctuation">,</span>    <span class="token string">'user_id'</span><span class="token punctuation">:</span> <span class="token string">'count'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span>reset_index<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 重命名列</span>segment_analysis<span class="token punctuation">.</span>columns <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'Segment'</span><span class="token punctuation">,</span> <span class="token string">'Average Frequency'</span><span class="token punctuation">,</span> <span class="token string">'Average Monetary'</span><span class="token punctuation">,</span> <span class="token string">'Number of Users'</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 显示</span>segment_analysis</code></pre><pre class=" language-python"><code class="language-python">    Segment    Average Frequency    Average Monetary    Number of Users<span class="token number">0</span>        <span class="token number">2.031206</span>    <span class="token number">3811.007892</span>    <span class="token number">23265</span><span class="token number">1</span>    High Frequency<span class="token punctuation">,</span> High Monetary    <span class="token number">22.006266</span>    <span class="token number">235958.656175</span>    <span class="token number">5426</span><span class="token number">2</span>    High Frequency<span class="token punctuation">,</span> Low Monetary    <span class="token number">4.315789</span>    <span class="token number">71.264366</span>    <span class="token number">19</span><span class="token number">3</span>    Low Frequency<span class="token punctuation">,</span> High Monetary    <span class="token number">1.000000</span>    <span class="token number">75065.532261</span>    <span class="token number">2638</span><span class="token number">4</span>    Low Frequency<span class="token punctuation">,</span> Low Monetary    <span class="token number">1.000000</span>    <span class="token number">45.086967</span>    <span class="token number">9646</span></code></pre><p>不同用户群体的平均Frequency和Monetary值，以及每个群体中的用户数量：</p><ol><li><strong>高频率、高消费（High Frequency, High Monetary）</strong>: 平均购买次数为22次，平均消费金额约为235,958。有5,426名用户属于这一类。</li><li><strong>高频率、低消费（High Frequency, Low Monetary）</strong>: 平均购买次数为4次，平均消费金额约为71。仅有19名用户属于这一类。</li><li><strong>低频率、高消费（Low Frequency, High Monetary）</strong>: 平均购买次数为1次，平均消费金额约为75,065。有2,638名用户属于这一类。</li><li><strong>低频率、低消费（Low Frequency, Low Monetary）</strong>: 平均购买次数为1次，平均消费金额约为45。有9,646名用户属于这一类。</li></ol><h2 id="不同维度分析"><a href="#不同维度分析" class="headerlink" title="不同维度分析"></a>不同维度分析</h2><p> 以上针对数据按照rfm步骤进行分析，现在针对以下四个维度进行分析</p><ol><li><strong>购买频率（Frequency）</strong>: 展示不同购买频率的用户数量。</li><li><strong>购买金额（Monetary）</strong>: 展示用户的购买金额分布。</li><li><strong>平均交易价值</strong>: 展示用户的平均交易价值分布。</li><li><strong>用户分段（Segment）</strong>: 展示各个用户分段的数量。</li></ol><p>创建一个包含四个子图的可视化图形，每个子图都用于展示不同的RFM相关信息，包括购买频率、购买金额、平均交易价值和用户分组。展现不同用户群体的分布和行为。 </p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token keyword">import</span> seaborn <span class="token keyword">as</span> sns<span class="token comment" spellcheck="true"># 设置可视化样式为白色网格</span>sns<span class="token punctuation">.</span>set<span class="token punctuation">(</span>style<span class="token operator">=</span><span class="token string">"whitegrid"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 初始化图表</span>plt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span>figsize<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 创建2行2列的子图布局</span>plt<span class="token punctuation">.</span>subplots_adjust<span class="token punctuation">(</span>hspace<span class="token operator">=</span><span class="token number">0.5</span><span class="token punctuation">,</span> wspace<span class="token operator">=</span><span class="token number">0.3</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 子图1：频率（Frequency）的分布</span>plt<span class="token punctuation">.</span>subplot<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>sns<span class="token punctuation">.</span>distplot<span class="token punctuation">(</span>rfm_df<span class="token punctuation">[</span><span class="token string">'Frequency'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> bins<span class="token operator">=</span><span class="token number">50</span><span class="token punctuation">,</span> kde<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token string">'skyblue'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token string">'Frequency distribution'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>xlabel<span class="token punctuation">(</span><span class="token string">'Frequency'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>ylabel<span class="token punctuation">(</span><span class="token string">'Number of users'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 子图2：消费金额（Monetary）的分布</span>plt<span class="token punctuation">.</span>subplot<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>sns<span class="token punctuation">.</span>distplot<span class="token punctuation">(</span>rfm_df<span class="token punctuation">[</span><span class="token string">'Monetary'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> bins<span class="token operator">=</span><span class="token number">50</span><span class="token punctuation">,</span> kde<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token string">'skyblue'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token string">'Monetary distribution'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>xlabel<span class="token punctuation">(</span><span class="token string">'Monetary'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>ylabel<span class="token punctuation">(</span><span class="token string">'Number of users'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 平均交易金额</span>rfm_df<span class="token punctuation">[</span><span class="token string">'Average Transaction Value'</span><span class="token punctuation">]</span> <span class="token operator">=</span> rfm_df<span class="token punctuation">[</span><span class="token string">'Monetary'</span><span class="token punctuation">]</span> <span class="token operator">/</span> rfm_df<span class="token punctuation">[</span><span class="token string">'Frequency'</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 子图3：平均交易金额（Average Transaction Value）的分布</span>plt<span class="token punctuation">.</span>subplot<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>sns<span class="token punctuation">.</span>distplot<span class="token punctuation">(</span>rfm_df<span class="token punctuation">[</span><span class="token string">'Average Transaction Value'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> bins<span class="token operator">=</span><span class="token number">50</span><span class="token punctuation">,</span> kde<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token string">'skyblue'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token string">'Average Transaction Value distribution'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>xlabel<span class="token punctuation">(</span><span class="token string">'Average Transaction Value'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>ylabel<span class="token punctuation">(</span><span class="token string">'Number of users'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 子图4：用户群体（Segment）的数量统计</span>plt<span class="token punctuation">.</span>subplot<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span>sns<span class="token punctuation">.</span>countplot<span class="token punctuation">(</span>y<span class="token operator">=</span><span class="token string">'Segment'</span><span class="token punctuation">,</span> data<span class="token operator">=</span>rfm_df<span class="token punctuation">,</span> order<span class="token operator">=</span>rfm_df<span class="token punctuation">[</span><span class="token string">'Segment'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>value_counts<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>index<span class="token punctuation">,</span> palette<span class="token operator">=</span><span class="token string">'viridis'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token string">'Count of user segments'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>xlabel<span class="token punctuation">(</span><span class="token string">'Number of users'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>ylabel<span class="token punctuation">(</span><span class="token string">'User segments'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><img src="https://cdn.jsdelivr.net/gh/Bevis23/blog-pic/rfm4子图.png" style="zoom:50%;"><h3 id="分析和可视化结果"><a href="#分析和可视化结果" class="headerlink" title="分析和可视化结果"></a>分析和可视化结果</h3><ol><li><strong>购买频率（Frequency）</strong>: 大多数用户的购买频率较低，集中在10次以下。</li><li><strong>购买金额（Monetary）</strong>: 大多数用户的消费金额也相对较低，集中在10,000以下。</li><li><strong>平均交易价值</strong>: 大部分用户的平均交易价值在10,000以下，这可能意味着多数用户更倾向于小额频繁的交易。</li><li><strong>用户分段（Segment）</strong>: 最多的用户属于“高频率、高消费”和“低频率、低消费”的分类。</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li><strong>用户行为</strong>：现有的数据提供了关于用户购买频率和消费金额的有用信息，便于了解客户群体。</li><li><strong>目标设定</strong>：通过用户分段，更有效地针对不同类型的用户进行个性化的营销活动。</li><li><strong>价值识别</strong>：平均交易价值的计算用于识别哪些用户在单笔交易上可能带来更高的价值。</li></ol><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>RFM分析不仅适用于电商领域，还可以应用于零售、餐饮、金融等各行各业。无论是提升用户留存率、精确定位目标客户、优化产品推荐，还是改进客户服务，RFM分析都能够提供有力的支持和指导。</p><p>通过深入应用RFM分析，企业可以更好地洞察客户行为和价值，从而制定更有针对性的战略和决策，实现业务增长和持续竞争优势。数据分析的力量正在改变着各个行业，而RFM分析无疑是其中的一项强大工具，值得企业们深入探索和应用。</p><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p>代码与数据集： <a href="https://bevis.lanzouq.com/isNMl1c63v0j" target="_blank" rel="noopener">https://bevis.lanzouq.com/isNMl1c63v0j</a> </p>]]></content>
      
      
      <categories>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思维工具 </tag>
            
            <tag> 数据分析 </tag>
            
            <tag> RFM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python数据分析-plotly</title>
      <link href="/shu-fen-plotly.html"/>
      <url>/shu-fen-plotly.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在现代数据科学和数据分析中，可视化是一项至关重要的任务。可视化图表可以帮助我们更好地理解数据、发现趋势和模式，以及与他人分享我们的发现。Python作为一种强大的编程语言，拥有许多出色的库，用于创建各种类型的可视化图表。</p><p>在数据可视化领域，Matplotlib是最常用的库之一，它提供了广泛的绘图功能，但也存在一些其他可视化库，每个都具有独特的优点。除了Matplotlib，Seaborn和Plotly也是数据科学家和分析师常用的可视化工具。这三个库都为我们提供了强大的工具来可视化数据，但它们在某些方面各有卓越之处。</p><p>本文将着重介绍Plotly，Plotly是一个Python库，专注于创建交互式可视化图表。与Matplotlib和Seaborn相比，Plotly提供了更丰富的互动性和可定制性，使得数据探索和展示更加生动和引人入胜。</p><blockquote><p>本文提供了各种示例代码，图像就不提供出来了，简单示例可以通过运行获得图像，</p><p>原因：个人采用的是github图床，利用jsDelivr 提供的全球 CDN 加速 </p><p>github 和jsdelivr 都有大小限制： GitHub 图床仓库大小<strong>不能超过1G</strong>。 因为GitHub 原则上是反对仓库图床化的，当仓库超过1G 后会有人工审核仓库内容，如果发现用来做图床，轻则删库重则封号 </p><p>当然，主要还是简单图例我觉得太多，太麻烦……放重点图例吧哈哈</p><p><strong>附录提供ipny代码文件与导出的html文件</strong></p></blockquote><h1 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1. 基础知识"></a>1. 基础知识</h1><h2 id="1-1-Plotly简介和安装"><a href="#1-1-Plotly简介和安装" class="headerlink" title="1.1 Plotly简介和安装"></a>1.1 Plotly简介和安装</h2><p><strong>Plotly简介：</strong> Plotly是一个用于创建交互式数据可视化的Python库。它允许轻松地生成各种类型的图表，包括线图、散点图、柱状图、地图等。Plotly的交互性可以探索数据、触发工具提示、缩放和平移图表，以及与观众互动。</p><p><strong>安装Plotly：</strong> 要安装Plotly，可以使用pip命令。如尚未安装Plotly，可以运行以下命令：</p><pre class=" language-bash"><code class="language-bash">pip <span class="token function">install</span> plotly</code></pre><p>如果使用Jupyter Notebook，可以在Notebook中执行以下命令：</p><pre><code>!pip install plotly</code></pre><h2 id="1-2-Plotly图表对象和语法介绍"><a href="#1-2-Plotly图表对象和语法介绍" class="headerlink" title="1.2 Plotly图表对象和语法介绍"></a>1.2 Plotly图表对象和语法介绍</h2><h3 id="1-2-1-Plotly图表对象"><a href="#1-2-1-Plotly图表对象" class="headerlink" title="1.2.1 Plotly图表对象"></a>1.2.1 Plotly图表对象</h3><p>Plotly图表通常包括以下几个主要组成部分：</p><ol><li><strong>数据（Data）：</strong> 在图表中可视化的实际数据。数据通常以字典或数据框的形式传递，其中包含列名和数据点。例如：</li></ol><pre class=" language-python"><code class="language-python">data <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'x'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">'y'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">'name'</span><span class="token punctuation">:</span> <span class="token string">'数据集1'</span><span class="token punctuation">}</span></code></pre><ol start="2"><li><strong>布局（Layout）：</strong> 布局定义了图表的外观和样式，包括标题、轴标签、背景色等。布局以字典的形式传递，如：</li></ol><pre class=" language-python"><code class="language-python">layout <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'title'</span><span class="token punctuation">:</span> <span class="token string">'我的图表'</span><span class="token punctuation">,</span> <span class="token string">'xaxis'</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token string">'title'</span><span class="token punctuation">:</span> <span class="token string">'X轴标签'</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ol start="3"><li><strong>图表类型（Trace）：</strong> 图表类型定义了数据的可视化方式，包括线图、散点图、柱状图等。不同的图表类型有不同的属性和参数，用于定义数据的呈现方式。</li></ol><h3 id="1-2-2-创建Plotly图表"><a href="#1-2-2-创建Plotly图表" class="headerlink" title="1.2.2 创建Plotly图表"></a>1.2.2 创建Plotly图表</h3><p>要创建Plotly图表，通常可以使用<code>plotly.graph_objs</code>模块或<code>plotly.express</code>模块。下面是两种常用的方法：</p><p><strong>使用<code>plotly.graph_objs</code>：</strong></p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> plotly<span class="token punctuation">.</span>graph_objs <span class="token keyword">as</span> go<span class="token comment" spellcheck="true"># 创建数据对象</span>trace <span class="token operator">=</span> go<span class="token punctuation">.</span>Scatter<span class="token punctuation">(</span>x<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> y<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">]</span><span class="token punctuation">,</span> mode<span class="token operator">=</span><span class="token string">'lines'</span><span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">'数据集1'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 创建布局对象</span>layout <span class="token operator">=</span> go<span class="token punctuation">.</span>Layout<span class="token punctuation">(</span>title<span class="token operator">=</span><span class="token string">'我的图表'</span><span class="token punctuation">,</span> xaxis<span class="token operator">=</span>dict<span class="token punctuation">(</span>title<span class="token operator">=</span><span class="token string">'X轴标签'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 创建图表对象</span>fig <span class="token operator">=</span> go<span class="token punctuation">.</span>Figure<span class="token punctuation">(</span>data<span class="token operator">=</span><span class="token punctuation">[</span>trace<span class="token punctuation">]</span><span class="token punctuation">,</span> layout<span class="token operator">=</span>layout<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 显示图表</span>fig<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p><strong>使用<code>plotly.express</code>：</strong></p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> plotly<span class="token punctuation">.</span>express <span class="token keyword">as</span> px<span class="token comment" spellcheck="true"># 创建数据框</span>df <span class="token operator">=</span> pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">'x'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">'y'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 使用Plotly Express创建图表</span>fig <span class="token operator">=</span> px<span class="token punctuation">.</span>line<span class="token punctuation">(</span>df<span class="token punctuation">,</span> x<span class="token operator">=</span><span class="token string">'x'</span><span class="token punctuation">,</span> y<span class="token operator">=</span><span class="token string">'y'</span><span class="token punctuation">,</span> title<span class="token operator">=</span><span class="token string">'我的图表'</span><span class="token punctuation">,</span> labels<span class="token operator">=</span><span class="token punctuation">{</span><span class="token string">'x'</span><span class="token punctuation">:</span> <span class="token string">'X轴标签'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 显示图表</span>fig<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>这些方法都可以用来创建基本的Plotly图表对象。<strong>使用<code>plotly.express</code>通常更简洁，适用于快速绘制常见类型的图表</strong>。</p><h3 id="1-2-3-图表语法和属性"><a href="#1-2-3-图表语法和属性" class="headerlink" title="1.2.3 图表语法和属性"></a>1.2.3 图表语法和属性</h3><p>Plotly图表对象的属性和参数允许自定义图表的外观和行为。可以设置线的颜色、轴的范围、标记的大小等。以下是一些示例：</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 设置线的颜色</span>trace<span class="token punctuation">.</span>line <span class="token operator">=</span> dict<span class="token punctuation">(</span>color<span class="token operator">=</span><span class="token string">'blue'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 设置轴的范围</span>layout<span class="token punctuation">.</span>xaxis <span class="token operator">=</span> dict<span class="token punctuation">(</span>range<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 设置标记的大小</span>trace<span class="token punctuation">.</span>marker <span class="token operator">=</span> dict<span class="token punctuation">(</span>size<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">)</span></code></pre><p>通过了解这些基本图表对象的构建和语法，更好地掌握如何使用Plotly创建自定义的可视化图表，以展示和解释数据。</p><p>当深入讲解每个小节时，我将提供更详细的信息，示例代码和解释，以确保读者能够全面了解每个主题。现在，让我们进一步扩展每个小节的内容。</p><h2 id="1-3-基本图表绘制"><a href="#1-3-基本图表绘制" class="headerlink" title="1.3 基本图表绘制"></a>1.3 基本图表绘制</h2><blockquote><p>以下提供了简单示例，运行代码便可以看可视化图像，自己运行感受下，这里就不放图片啦^_^</p></blockquote><h3 id="1-3-1-折线图"><a href="#1-3-1-折线图" class="headerlink" title="1.3.1 折线图"></a>1.3.1 折线图</h3><p>折线图是一种常见的图表类型，用于可视化数据随时间或其他连续变量的趋势。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> plotly<span class="token punctuation">.</span>express <span class="token keyword">as</span> px<span class="token keyword">import</span> pandas <span class="token keyword">as</span> pd<span class="token comment" spellcheck="true"># 创建示例数据集</span>data <span class="token operator">=</span> pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">'时间'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'2023-01-01'</span><span class="token punctuation">,</span> <span class="token string">'2023-01-02'</span><span class="token punctuation">,</span> <span class="token string">'2023-01-03'</span><span class="token punctuation">,</span> <span class="token string">'2023-01-04'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                     <span class="token string">'值'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 使用Plotly Express创建折线图</span>fig <span class="token operator">=</span> px<span class="token punctuation">.</span>line<span class="token punctuation">(</span>data_frame<span class="token operator">=</span>data<span class="token punctuation">,</span> x<span class="token operator">=</span><span class="token string">'时间'</span><span class="token punctuation">,</span> y<span class="token operator">=</span><span class="token string">'值'</span><span class="token punctuation">,</span> title<span class="token operator">=</span><span class="token string">'折线图'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 显示图表    </span>fig<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h3 id="1-3-2-散点图"><a href="#1-3-2-散点图" class="headerlink" title="1.3.2 散点图"></a>1.3.2 散点图</h3><p>散点图用于观察数据点的分布和关联性</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> pandas <span class="token keyword">as</span> pd<span class="token keyword">import</span> plotly<span class="token punctuation">.</span>express <span class="token keyword">as</span> px<span class="token comment" spellcheck="true"># 创建示例数据集</span>data <span class="token operator">=</span> pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">'x'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                     <span class="token string">'y'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 使用Plotly Express创建散点图</span>fig <span class="token operator">=</span> px<span class="token punctuation">.</span>scatter<span class="token punctuation">(</span>data_frame<span class="token operator">=</span>data<span class="token punctuation">,</span> x<span class="token operator">=</span><span class="token string">'x'</span><span class="token punctuation">,</span> y<span class="token operator">=</span><span class="token string">'y'</span><span class="token punctuation">,</span> title<span class="token operator">=</span><span class="token string">'散点图'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 显示图表</span>fig<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h3 id="1-3-3-柱状图"><a href="#1-3-3-柱状图" class="headerlink" title="1.3.3 柱状图"></a>1.3.3 柱状图</h3><p>柱状图是用于比较不同类别或组之间数据的有力工具。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> pandas <span class="token keyword">as</span> pd<span class="token keyword">import</span> plotly<span class="token punctuation">.</span>express <span class="token keyword">as</span> px<span class="token comment" spellcheck="true"># 创建示例数据集</span>data <span class="token operator">=</span> pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">'类别'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token string">'B'</span><span class="token punctuation">,</span> <span class="token string">'C'</span><span class="token punctuation">,</span> <span class="token string">'D'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                     <span class="token string">'值'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 使用Plotly Express创建柱状图</span>fig <span class="token operator">=</span> px<span class="token punctuation">.</span>bar<span class="token punctuation">(</span>data_frame<span class="token operator">=</span>data<span class="token punctuation">,</span> x<span class="token operator">=</span><span class="token string">'类别'</span><span class="token punctuation">,</span> y<span class="token operator">=</span><span class="token string">'值'</span><span class="token punctuation">,</span> title<span class="token operator">=</span><span class="token string">'柱状图'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 显示图表</span>fig<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h2 id="1-4-图表样式和布局定制"><a href="#1-4-图表样式和布局定制" class="headerlink" title="1.4 图表样式和布局定制"></a>1.4 图表样式和布局定制</h2><h3 id="1-4-1-颜色和样式"><a href="#1-4-1-颜色和样式" class="headerlink" title="1.4.1 颜色和样式"></a>1.4.1 颜色和样式</h3><p>Plotly允许自定义图表元素的颜色、线型和标记。可以使用<code>color</code>参数来指定颜色，<code>mode</code>参数来指定线型，以及其他自定义选项。例如：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> pandas <span class="token keyword">as</span> pd<span class="token keyword">import</span> plotly<span class="token punctuation">.</span>express <span class="token keyword">as</span> px<span class="token comment" spellcheck="true"># 创建示例数据集</span>data <span class="token operator">=</span> pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">'x'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                     <span class="token string">'y'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 使用Plotly Express创建散点图</span>fig <span class="token operator">=</span> px<span class="token punctuation">.</span>scatter<span class="token punctuation">(</span>data_frame<span class="token operator">=</span>data<span class="token punctuation">,</span> x<span class="token operator">=</span><span class="token string">'x'</span><span class="token punctuation">,</span> y<span class="token operator">=</span><span class="token string">'y'</span><span class="token punctuation">,</span> title<span class="token operator">=</span><span class="token string">'散点图'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 自定义散点图元素颜色和线型</span>fig<span class="token punctuation">.</span>update_traces<span class="token punctuation">(</span>marker<span class="token operator">=</span>dict<span class="token punctuation">(</span>size<span class="token operator">=</span><span class="token number">8</span><span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token string">'red'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> line<span class="token operator">=</span>dict<span class="token punctuation">(</span>color<span class="token operator">=</span><span class="token string">'blue'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 显示图表</span>fig<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>这将设置散点图的标记颜色为红色，线型颜色为蓝色。</p><h3 id="1-4-2-布局调整"><a href="#1-4-2-布局调整" class="headerlink" title="1.4.2 布局调整"></a>1.4.2 布局调整</h3><p>Plotly还允许调整图表的布局，包括标题、轴标签和图例的位置。可以使用<code>update_layout</code>来进行这些调整：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> pandas <span class="token keyword">as</span> pd<span class="token keyword">import</span> plotly<span class="token punctuation">.</span>express <span class="token keyword">as</span> px<span class="token comment" spellcheck="true"># 创建示例数据集</span>data <span class="token operator">=</span> pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">'x'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                     <span class="token string">'y'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 使用Plotly Express创建散点图</span>fig <span class="token operator">=</span> px<span class="token punctuation">.</span>scatter<span class="token punctuation">(</span>data_frame<span class="token operator">=</span>data<span class="token punctuation">,</span> x<span class="token operator">=</span><span class="token string">'x'</span><span class="token punctuation">,</span> y<span class="token operator">=</span><span class="token string">'y'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 自定义图表布局</span>fig<span class="token punctuation">.</span>update_layout<span class="token punctuation">(</span>    title<span class="token operator">=</span><span class="token string">'自定义标题'</span><span class="token punctuation">,</span>    xaxis_title<span class="token operator">=</span><span class="token string">'X轴标签'</span><span class="token punctuation">,</span>    yaxis_title<span class="token operator">=</span><span class="token string">'Y轴标签'</span><span class="token punctuation">,</span>    legend<span class="token operator">=</span>dict<span class="token punctuation">(</span>x<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> y<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 显示图表</span>fig<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>这将设置图表的标题、轴标签和图例的位置。</p><h3 id="1-4-3-标题和注释"><a href="#1-4-3-标题和注释" class="headerlink" title="1.4.3 标题和注释"></a>1.4.3 标题和注释</h3><p>使用Plotly添加标题和注释，以提供更多信息和上下文。例如，要添加图表标题：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> pandas <span class="token keyword">as</span> pd<span class="token keyword">import</span> plotly<span class="token punctuation">.</span>graph_objects <span class="token keyword">as</span> go<span class="token comment" spellcheck="true"># 创建示例数据集</span>data <span class="token operator">=</span> pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">'x'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                     <span class="token string">'y'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 使用Plotly创建散点图</span>fig <span class="token operator">=</span> go<span class="token punctuation">.</span>Figure<span class="token punctuation">(</span>data<span class="token operator">=</span>go<span class="token punctuation">.</span>Scatter<span class="token punctuation">(</span>x<span class="token operator">=</span>data<span class="token punctuation">[</span><span class="token string">'x'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> y<span class="token operator">=</span>data<span class="token punctuation">[</span><span class="token string">'y'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> mode<span class="token operator">=</span><span class="token string">'markers'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 添加图表标题</span>fig<span class="token punctuation">.</span>update_layout<span class="token punctuation">(</span>title_text<span class="token operator">=</span><span class="token string">'我的图表标题'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 添加注释</span>fig<span class="token punctuation">.</span>add_annotation<span class="token punctuation">(</span>x<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> y<span class="token operator">=</span><span class="token number">6</span><span class="token punctuation">,</span> text<span class="token operator">=</span><span class="token string">'这是一个注释'</span><span class="token punctuation">,</span> showarrow<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> arrowhead<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 显示图表</span>fig<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>可以使用<code>add_annotation</code>方法添加注释，指定位置和文本。</p><h2 id="1-5-数据导入和处理"><a href="#1-5-数据导入和处理" class="headerlink" title="1.5 数据导入和处理"></a>1.5 数据导入和处理</h2><h3 id="1-5-1-数据导入"><a href="#1-5-1-数据导入" class="headerlink" title="1.5.1 数据导入"></a>1.5.1 数据导入</h3><p>要从不同数据源导入数据，如CSV文件或数据框，可以使用Pandas库。例如，要从CSV文件导入数据：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> pandas <span class="token keyword">as</span> pddata <span class="token operator">=</span> pd<span class="token punctuation">.</span>read_csv<span class="token punctuation">(</span><span class="token string">'data.csv'</span><span class="token punctuation">)</span></code></pre><h3 id="1-5-2-数据处理"><a href="#1-5-2-数据处理" class="headerlink" title="1.5.2 数据处理"></a>1.5.2 数据处理</h3><p>数据处理是数据可视化的关键步骤。可使用Pandas来进行数据筛选、清洗和转换，以满足可视化需求。例如，要筛选特定条件下的数据：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> pandas <span class="token keyword">as</span> pd<span class="token comment" spellcheck="true"># 创建示例数据集</span>data <span class="token operator">=</span> pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">'x'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                     <span class="token string">'y'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                     <span class="token string">'条件'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token string">'B'</span><span class="token punctuation">,</span> <span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token string">'B'</span><span class="token punctuation">,</span> <span class="token string">'A'</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 筛选特定条件下的数据</span>filtered_data <span class="token operator">=</span> data<span class="token punctuation">[</span>data<span class="token punctuation">[</span><span class="token string">'条件'</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'A'</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 打印筛选后的结果</span><span class="token keyword">print</span><span class="token punctuation">(</span>filtered_data<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 输出</span>   x   y 条件<span class="token number">0</span>  <span class="token number">1</span>   <span class="token number">2</span>  A<span class="token number">2</span>  <span class="token number">3</span>   <span class="token number">6</span>  A<span class="token number">4</span>  <span class="token number">5</span>  <span class="token number">10</span>  A</code></pre><p>理解的需求，下面我将提供更具体的内容来详细介绍每个小节。</p><h1 id="2-交互式图表"><a href="#2-交互式图表" class="headerlink" title="2.交互式图表"></a>2.交互式图表</h1><h2 id="2-1-配置和操作交互性"><a href="#2-1-配置和操作交互性" class="headerlink" title="2.1 配置和操作交互性"></a>2.1 配置和操作交互性</h2><p>Plotly图表的交互性非常重要，可以通过以下方式配置和操作：</p><h3 id="2-1-1-鼠标交互"><a href="#2-1-1-鼠标交互" class="headerlink" title="2.1.1 鼠标交互"></a>2.1.1 鼠标交互</h3><p>鼠标交互使用户能够与图表进行互动，包括：</p><ul><li><p><strong>缩放：</strong> 用户可以使用鼠标滚轮缩放图表，以查看数据的不同部分。这对于查看大规模数据集非常有用。</p></li><li><p><strong>拖动：</strong> 用户可以通过拖动鼠标来平移图表，从而查看隐藏在屏幕外的数据。</p></li><li><p><strong>点击：</strong> 可以配置图表，使得用户在点击数据点时可以执行自定义操作，例如显示更多详细信息。</p></li></ul><h3 id="2-1-2-滚动和缩放"><a href="#2-1-2-滚动和缩放" class="headerlink" title="2.1.2 滚动和缩放"></a>2.1.2 滚动和缩放</h3><p>Plotly允许用户使用鼠标滚轮来缩放图表。这可以通过简单的滚动鼠标滚轮来实现，用户可以放大或缩小图表，以查看特定数据的细节或整体趋势。</p><h3 id="2-1-3-选择和高亮"><a href="#2-1-3-选择和高亮" class="headerlink" title="2.1.3 选择和高亮"></a>2.1.3 选择和高亮</h3><p>用户可以选择数据点并将其高亮显示，以便更深入地研究感兴趣的数据。这通常通过鼠标点击或拖动来实现，用户可以选择数据点并查看相关信息。</p><h3 id="2-1-4-交互式控件"><a href="#2-1-4-交互式控件" class="headerlink" title="2.1.4 交互式控件"></a>2.1.4 交互式控件</h3><p>Plotly允许添加各种交互式控件，如滑块、按钮和下拉菜单。这些控件使用户可以动态调整图表内容，例如过滤数据、更改图表类型或调整参数。</p><h2 id="2-2-悬停标签和工具提示"><a href="#2-2-悬停标签和工具提示" class="headerlink" title="2.2 悬停标签和工具提示"></a>2.2 悬停标签和工具提示</h2><p>悬停标签和工具提示是交互式图表中的关键元素，提供了附加信息以增强用户体验：</p><h3 id="2-2-1-配置悬停标签"><a href="#2-2-1-配置悬停标签" class="headerlink" title="2.2.1 配置悬停标签"></a>2.2.1 配置悬停标签</h3><p>可以配置悬停标签以在鼠标悬停在数据点上时显示特定信息。这通常包括数据值、标签和其他相关信息，让用户能够轻松获取数据的背景信息。</p><h3 id="2-2-2-自定义工具提示"><a href="#2-2-2-自定义工具提示" class="headerlink" title="2.2.2 自定义工具提示"></a>2.2.2 自定义工具提示</h3><p>如果需要更详细的信息，可以通过自定义HTML内容来创建复杂的工具提示。这允许显示图表的详细信息、自定义格式和样式。</p><h3 id="2-2-3-鼠标悬停交互"><a href="#2-2-3-鼠标悬停交互" class="headerlink" title="2.2.3 鼠标悬停交互"></a>2.2.3 鼠标悬停交互</h3><p>Plotly允许配置鼠标悬停时的交互效果，例如更改标记的颜色、大小或显示额外的信息。这使得用户可以通过悬停来探索数据点。</p><h2 id="2-3-缩放和平移功能"><a href="#2-3-缩放和平移功能" class="headerlink" title="2.3 缩放和平移功能"></a>2.3 缩放和平移功能</h2><p>为了更好地查看数据，Plotly提供了缩放和平移功能：</p><h3 id="2-3-1-缩放图表"><a href="#2-3-1-缩放图表" class="headerlink" title="2.3.1 缩放图表"></a>2.3.1 缩放图表</h3><p>用户可以使用鼠标滚轮来放大或缩小图表，以查看数据的不同部分。这非常有用，尤其是对于具有大量数据点的图表。</p><h3 id="2-3-2-平移图表"><a href="#2-3-2-平移图表" class="headerlink" title="2.3.2 平移图表"></a>2.3.2 平移图表</h3><p>通过拖动图表，用户可以移动可视化区域，以查看隐藏在屏幕外的数据。这有助于用户浏览整个数据集。</p><h3 id="2-3-3-自动缩放"><a href="#2-3-3-自动缩放" class="headerlink" title="2.3.3 自动缩放"></a>2.3.3 自动缩放</h3><p>Plotly还支持自动缩放功能，这意味着图表可以根据数据的范围自动调整，以确保数据点不会被截断。这使得用户无需手动缩放图表，数据会自动适应显示。</p><h2 id="2-4-响应式布局和自适应设计"><a href="#2-4-响应式布局和自适应设计" class="headerlink" title="2.4 响应式布局和自适应设计"></a>2.4 响应式布局和自适应设计</h2><p>在不同设备和屏幕尺寸上呈现图表是重要的，Plotly提供了方法来实现响应式布局和自适应设计：</p><h3 id="2-4-1-自适应大小"><a href="#2-4-1-自适应大小" class="headerlink" title="2.4.1 自适应大小"></a>2.4.1 自适应大小</h3><p>可以配置图表以自适应不同屏幕尺寸，以确保用户在移动设备上获得</p><p>出色的体验。这意味着图表会自动调整大小，以适应不同的显示器。</p><h3 id="2-4-2-媒体查询"><a href="#2-4-2-媒体查询" class="headerlink" title="2.4.2 媒体查询"></a>2.4.2 媒体查询</h3><p>使用媒体查询，可以根据设备的特性来调整图表的布局和样式。这允许根据设备的屏幕大小、方向和分辨率来定制图表的外观。</p><h3 id="2-4-3-响应式控制"><a href="#2-4-3-响应式控制" class="headerlink" title="2.4.3 响应式控制"></a>2.4.3 响应式控制</h3><p>Plotly允许根据用户的操作来控制图表的响应性。例如，可以配置图表，在用户旋转设备或更改屏幕尺寸时重新布局图表，以确保用户获得最佳的交互体验。</p><h1 id="3-高级图表绘制"><a href="#3-高级图表绘制" class="headerlink" title="3. 高级图表绘制"></a>3. 高级图表绘制</h1><p>深入探讨高级的Plotly图表绘制，包括3D图表、地理数据可视化、统计图表以及统计模型图表。</p><h2 id="3-1-绘制3D图表"><a href="#3-1-绘制3D图表" class="headerlink" title="3.1 绘制3D图表"></a>3.1 绘制3D图表</h2><p>Plotly允许绘制各种类型的3D图表，包括散点图和线型图。下面是一些示例：</p><h3 id="3-1-1-3D散点图"><a href="#3-1-1-3D散点图" class="headerlink" title="3.1.1 3D散点图"></a>3.1.1 3D散点图</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> plotly<span class="token punctuation">.</span>graph_objs <span class="token keyword">as</span> go<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token comment" spellcheck="true"># 创建数据</span>x <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>rand<span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span>y <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>rand<span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span>z <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>rand<span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 创建3D散点图</span>fig <span class="token operator">=</span> go<span class="token punctuation">.</span>Figure<span class="token punctuation">(</span>data<span class="token operator">=</span><span class="token punctuation">[</span>go<span class="token punctuation">.</span>Scatter3d<span class="token punctuation">(</span>x<span class="token operator">=</span>x<span class="token punctuation">,</span> y<span class="token operator">=</span>y<span class="token punctuation">,</span> z<span class="token operator">=</span>z<span class="token punctuation">,</span> mode<span class="token operator">=</span><span class="token string">'markers'</span><span class="token punctuation">,</span> marker<span class="token operator">=</span>dict<span class="token punctuation">(</span>size<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 设置布局</span>fig<span class="token punctuation">.</span>update_layout<span class="token punctuation">(</span>scene<span class="token operator">=</span>dict<span class="token punctuation">(</span>xaxis_title<span class="token operator">=</span><span class="token string">'X轴'</span><span class="token punctuation">,</span> yaxis_title<span class="token operator">=</span><span class="token string">'Y轴'</span><span class="token punctuation">,</span> zaxis_title<span class="token operator">=</span><span class="token string">'Z轴'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 显示图表</span>fig<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h3 id="3-1-2-3D线型图"><a href="#3-1-2-3D线型图" class="headerlink" title="3.1.2 3D线型图"></a>3.1.2 3D线型图</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> plotly<span class="token punctuation">.</span>graph_objs <span class="token keyword">as</span> go<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token comment" spellcheck="true"># 创建数据</span>t <span class="token operator">=</span> np<span class="token punctuation">.</span>linspace<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span>x <span class="token operator">=</span> np<span class="token punctuation">.</span>sin<span class="token punctuation">(</span>t<span class="token punctuation">)</span>y <span class="token operator">=</span> np<span class="token punctuation">.</span>cos<span class="token punctuation">(</span>t<span class="token punctuation">)</span>z <span class="token operator">=</span> t<span class="token comment" spellcheck="true"># 创建3D线型图</span>fig <span class="token operator">=</span> go<span class="token punctuation">.</span>Figure<span class="token punctuation">(</span>data<span class="token operator">=</span><span class="token punctuation">[</span>go<span class="token punctuation">.</span>Scatter3d<span class="token punctuation">(</span>x<span class="token operator">=</span>x<span class="token punctuation">,</span> y<span class="token operator">=</span>y<span class="token punctuation">,</span> z<span class="token operator">=</span>z<span class="token punctuation">,</span> mode<span class="token operator">=</span><span class="token string">'lines'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 设置布局</span>fig<span class="token punctuation">.</span>update_layout<span class="token punctuation">(</span>scene<span class="token operator">=</span>dict<span class="token punctuation">(</span>xaxis_title<span class="token operator">=</span><span class="token string">'X轴'</span><span class="token punctuation">,</span> yaxis_title<span class="token operator">=</span><span class="token string">'Y轴'</span><span class="token punctuation">,</span> zaxis_title<span class="token operator">=</span><span class="token string">'Z轴'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 显示图表</span>fig<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h3 id="3-2-绘制地理数据可视化图表"><a href="#3-2-绘制地理数据可视化图表" class="headerlink" title="3.2 绘制地理数据可视化图表"></a>3.2 绘制地理数据可视化图表</h3><p>Plotly支持绘制地理数据可视化图表，这对于地图数据非常有用。下面是一个简单的地图绘制示例：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> plotly<span class="token punctuation">.</span>express <span class="token keyword">as</span> px<span class="token comment" spellcheck="true"># 创建地理数据框</span>df <span class="token operator">=</span> px<span class="token punctuation">.</span>data<span class="token punctuation">.</span>gapminder<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 创建地图</span>fig <span class="token operator">=</span> px<span class="token punctuation">.</span>scatter_geo<span class="token punctuation">(</span>df<span class="token punctuation">,</span> locations<span class="token operator">=</span><span class="token string">"iso_alpha"</span><span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token string">"continent"</span><span class="token punctuation">,</span> hover_name<span class="token operator">=</span><span class="token string">"country"</span><span class="token punctuation">,</span> size<span class="token operator">=</span><span class="token string">"pop"</span><span class="token punctuation">,</span> projection<span class="token operator">=</span><span class="token string">"natural earth"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 显示地图</span>fig<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h2 id="3-3-绘制统计图表"><a href="#3-3-绘制统计图表" class="headerlink" title="3.3 绘制统计图表"></a>3.3 绘制统计图表</h2><p>Plotly还支持绘制各种统计图表，包括箱线图和热力图。以下是示例：</p><h3 id="3-3-1-箱线图"><a href="#3-3-1-箱线图" class="headerlink" title="3.3.1 箱线图"></a>3.3.1 箱线图</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> plotly<span class="token punctuation">.</span>express <span class="token keyword">as</span> px<span class="token comment" spellcheck="true"># 创建数据</span>df <span class="token operator">=</span> px<span class="token punctuation">.</span>data<span class="token punctuation">.</span>tips<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 创建箱线图</span>fig <span class="token operator">=</span> px<span class="token punctuation">.</span>box<span class="token punctuation">(</span>df<span class="token punctuation">,</span> x<span class="token operator">=</span><span class="token string">"day"</span><span class="token punctuation">,</span> y<span class="token operator">=</span><span class="token string">"total_bill"</span><span class="token punctuation">,</span> points<span class="token operator">=</span><span class="token string">"all"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 显示箱线图</span>fig<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h3 id="3-3-2-热力图"><a href="#3-3-2-热力图" class="headerlink" title="3.3.2 热力图"></a>3.3.2 热力图</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> plotly<span class="token punctuation">.</span>express <span class="token keyword">as</span> px<span class="token comment" spellcheck="true"># 创建数据</span>df <span class="token operator">=</span> px<span class="token punctuation">.</span>data<span class="token punctuation">.</span>iris<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 创建热力图</span>fig <span class="token operator">=</span> px<span class="token punctuation">.</span>density_heatmap<span class="token punctuation">(</span>df<span class="token punctuation">,</span> x<span class="token operator">=</span><span class="token string">"sepal_width"</span><span class="token punctuation">,</span> y<span class="token operator">=</span><span class="token string">"sepal_length"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 显示热力图</span>fig<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h2 id="3-4-绘制统计模型图表"><a href="#3-4-绘制统计模型图表" class="headerlink" title="3.4 绘制统计模型图表"></a>3.4 绘制统计模型图表</h2><p>Plotly可以用来可视化统计模型的结果，包括线性回归图和残差图。以下是示例：</p><h3 id="3-4-1-线性回归图"><a href="#3-4-1-线性回归图" class="headerlink" title="3.4.1 线性回归图"></a>3.4.1 线性回归图</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> plotly<span class="token punctuation">.</span>express <span class="token keyword">as</span> px<span class="token comment" spellcheck="true"># 创建数据</span>df <span class="token operator">=</span> px<span class="token punctuation">.</span>data<span class="token punctuation">.</span>tips<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 创建线性回归图</span>fig <span class="token operator">=</span> px<span class="token punctuation">.</span>scatter<span class="token punctuation">(</span>df<span class="token punctuation">,</span> x<span class="token operator">=</span><span class="token string">"total_bill"</span><span class="token punctuation">,</span> y<span class="token operator">=</span><span class="token string">"tip"</span><span class="token punctuation">,</span> trendline<span class="token operator">=</span><span class="token string">"ols"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 显示线性回归图</span>fig<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h3 id="3-4-2-残差图"><a href="#3-4-2-残差图" class="headerlink" title="3.4.2 残差图"></a>3.4.2 残差图</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> plotly<span class="token punctuation">.</span>express <span class="token keyword">as</span> px<span class="token comment" spellcheck="true"># 创建数据</span>df <span class="token operator">=</span> px<span class="token punctuation">.</span>data<span class="token punctuation">.</span>tips<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 创建残差图</span>fig <span class="token operator">=</span> px<span class="token punctuation">.</span>scatter<span class="token punctuation">(</span>df<span class="token punctuation">,</span> x<span class="token operator">=</span><span class="token string">"total_bill"</span><span class="token punctuation">,</span> y<span class="token operator">=</span><span class="token string">"tip"</span><span class="token punctuation">,</span> trendline<span class="token operator">=</span><span class="token string">"ols"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 显示残差图</span>fig<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>通过这些示例，了解如何使用Plotly创建高级图表，包括3D图表、地理数据可视化、统计图表和统计模型图表。这些图表可以用于更深入的数据分析和可视化。</p><h1 id="4-多图合并和子图布局"><a href="#4-多图合并和子图布局" class="headerlink" title="4. 多图合并和子图布局"></a>4. 多图合并和子图布局</h1><p>在Plotly中创建多图合并和子图布局。这包括创建子图和网格布局、组合多个图表到一个画布、自定义子图之间的排列和间距，以及添加标题和图例。</p><h2 id="4-1-创建子图和网格布局"><a href="#4-1-创建子图和网格布局" class="headerlink" title="4.1 创建子图和网格布局"></a>4.1 创建子图和网格布局</h2><h3 id="4-1-1-创建子图"><a href="#4-1-1-创建子图" class="headerlink" title="4.1.1 创建子图"></a>4.1.1 创建子图</h3><p>在Plotly中，可以创建多个子图，并将它们组合成一个画布。下面是一个示例，演示如何创建两个子图并将它们排列在一行：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> plotly<span class="token punctuation">.</span>graph_objs <span class="token keyword">as</span> go<span class="token comment" spellcheck="true"># 创建子图1</span>fig1 <span class="token operator">=</span> go<span class="token punctuation">.</span>Figure<span class="token punctuation">(</span>data<span class="token operator">=</span>go<span class="token punctuation">.</span>Scatter<span class="token punctuation">(</span>x<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> y<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> mode<span class="token operator">=</span><span class="token string">'markers'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 创建子图2</span>fig2 <span class="token operator">=</span> go<span class="token punctuation">.</span>Figure<span class="token punctuation">(</span>data<span class="token operator">=</span>go<span class="token punctuation">.</span>Bar<span class="token punctuation">(</span>x<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> y<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 显示子图</span>fig1<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span>fig2<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h3 id="4-1-2-网格布局"><a href="#4-1-2-网格布局" class="headerlink" title="4.1.2 网格布局"></a>4.1.2 网格布局</h3><p>Plotly还支持在一个画布上创建多个子图，并将它们排列在网格布局中。下面是一个示例，演示如何创建一个包含多个子图的网格布局：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> plotly<span class="token punctuation">.</span>graph_objs <span class="token keyword">as</span> go<span class="token keyword">from</span> plotly<span class="token punctuation">.</span>subplots <span class="token keyword">import</span> make_subplots<span class="token comment" spellcheck="true"># 创建子图</span>fig <span class="token operator">=</span> make_subplots<span class="token punctuation">(</span>rows<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> cols<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> subplot_titles<span class="token operator">=</span><span class="token punctuation">(</span><span class="token string">'子图1'</span><span class="token punctuation">,</span> <span class="token string">'子图2'</span><span class="token punctuation">,</span> <span class="token string">'子图3'</span><span class="token punctuation">,</span> <span class="token string">'子图4'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 添加子图1</span>fig<span class="token punctuation">.</span>add_trace<span class="token punctuation">(</span>go<span class="token punctuation">.</span>Scatter<span class="token punctuation">(</span>x<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> y<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> mode<span class="token operator">=</span><span class="token string">'markers'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> row<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> col<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 添加子图2</span>fig<span class="token punctuation">.</span>add_trace<span class="token punctuation">(</span>go<span class="token punctuation">.</span>Bar<span class="token punctuation">(</span>x<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> y<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> row<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> col<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 添加子图3</span>fig<span class="token punctuation">.</span>add_trace<span class="token punctuation">(</span>go<span class="token punctuation">.</span>Scatter<span class="token punctuation">(</span>x<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> y<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> mode<span class="token operator">=</span><span class="token string">'markers'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> row<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> col<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 添加子图4</span>fig<span class="token punctuation">.</span>add_trace<span class="token punctuation">(</span>go<span class="token punctuation">.</span>Bar<span class="token punctuation">(</span>x<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> y<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> row<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> col<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 显示网格布局</span>fig<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h2 id="4-2-组合多个图表到一个画布"><a href="#4-2-组合多个图表到一个画布" class="headerlink" title="4.2 组合多个图表到一个画布"></a>4.2 组合多个图表到一个画布</h2><p>Plotly允许将多个图表组合到一个画布上，以创建一个多图合并的可视化。下面是一个示例，演示如何将两个图表组合到一个画布上：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> plotly<span class="token punctuation">.</span>graph_objs <span class="token keyword">as</span> go<span class="token comment" spellcheck="true"># 创建图表1</span>fig1 <span class="token operator">=</span> go<span class="token punctuation">.</span>Figure<span class="token punctuation">(</span>data<span class="token operator">=</span>go<span class="token punctuation">.</span>Scatter<span class="token punctuation">(</span>x<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> y<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> mode<span class="token operator">=</span><span class="token string">'markers'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 创建图表2</span>fig2 <span class="token operator">=</span> go<span class="token punctuation">.</span>Figure<span class="token punctuation">(</span>data<span class="token operator">=</span>go<span class="token punctuation">.</span>Bar<span class="token punctuation">(</span>x<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> y<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 合并图表到一个画布</span>fig1<span class="token punctuation">.</span>add_traces<span class="token punctuation">(</span>fig2<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 显示合并后的图表</span>fig1<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h2 id="4-3-自定义子图之间的排列和间距"><a href="#4-3-自定义子图之间的排列和间距" class="headerlink" title="4.3 自定义子图之间的排列和间距"></a>4.3 自定义子图之间的排列和间距</h2><p>在Plotly中，自定义子图之间的排列和间距，以满足特定的布局需求。下面是一个示例，演示如何自定义子图之间的排列和间距：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> plotly<span class="token punctuation">.</span>graph_objs <span class="token keyword">as</span> go<span class="token comment" spellcheck="true"># 创建子图1</span>fig1 <span class="token operator">=</span> go<span class="token punctuation">.</span>Figure<span class="token punctuation">(</span>data<span class="token operator">=</span>go<span class="token punctuation">.</span>Scatter<span class="token punctuation">(</span>x<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> y<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> mode<span class="token operator">=</span><span class="token string">'markers'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 创建子图2</span>fig2 <span class="token operator">=</span> go<span class="token punctuation">.</span>Figure<span class="token punctuation">(</span>data<span class="token operator">=</span>go<span class="token punctuation">.</span>Bar<span class="token punctuation">(</span>x<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> y<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 自定义子图之间的排列和间距</span>fig1<span class="token punctuation">.</span>update_layout<span class="token punctuation">(</span>    xaxis<span class="token operator">=</span>dict<span class="token punctuation">(</span>domain<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0.4</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    yaxis<span class="token operator">=</span>dict<span class="token punctuation">(</span>domain<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">)</span>fig2<span class="token punctuation">.</span>update_layout<span class="token punctuation">(</span>    xaxis<span class="token operator">=</span>dict<span class="token punctuation">(</span>domain<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0.6</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    yaxis<span class="token operator">=</span>dict<span class="token punctuation">(</span>domain<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 显示自定义排列的图表</span>fig1</code></pre><h1 id="5-高级主题定制"><a href="#5-高级主题定制" class="headerlink" title="5. 高级主题定制"></a>5. 高级主题定制</h1><p>如何进行高级主题定制，以满足特定的可视化需求。这包括使用自定义主题样式、配置颜色和字体样式、添加背景图和水印，以及如何导出和分享图表。</p><h2 id="5-1-使用自定义主题样式"><a href="#5-1-使用自定义主题样式" class="headerlink" title="5.1 使用自定义主题样式"></a>5.1 使用自定义主题样式</h2><p>Plotly允许使用自定义主题样式来改变图表的整体外观和风格。下面是一个示例，演示如何应用自定义主题样式：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> plotly<span class="token punctuation">.</span>graph_objs <span class="token keyword">as</span> go<span class="token comment" spellcheck="true"># 创建图表</span>fig <span class="token operator">=</span> go<span class="token punctuation">.</span>Figure<span class="token punctuation">(</span>data<span class="token operator">=</span>go<span class="token punctuation">.</span>Scatter<span class="token punctuation">(</span>x<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> y<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> mode<span class="token operator">=</span><span class="token string">'markers'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 应用自定义主题样式</span>fig<span class="token punctuation">.</span>update_layout<span class="token punctuation">(</span>    template<span class="token operator">=</span><span class="token string">"plotly_dark"</span>  <span class="token comment" spellcheck="true"># 使用“plotly_dark”主题</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 显示图表</span>fig<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h2 id="5-2-配置颜色和字体样式"><a href="#5-2-配置颜色和字体样式" class="headerlink" title="5.2 配置颜色和字体样式"></a>5.2 配置颜色和字体样式</h2><p>可以配置图表的颜色和字体样式，以满足特定的设计需求。下面是一个示例，演示如何配置颜色和字体样式：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> plotly<span class="token punctuation">.</span>graph_objs <span class="token keyword">as</span> go<span class="token comment" spellcheck="true"># 创建图表</span>fig <span class="token operator">=</span> go<span class="token punctuation">.</span>Figure<span class="token punctuation">(</span>data<span class="token operator">=</span>go<span class="token punctuation">.</span>Scatter<span class="token punctuation">(</span>x<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> y<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> mode<span class="token operator">=</span><span class="token string">'markers'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 配置颜色和字体样式</span>fig<span class="token punctuation">.</span>update_layout<span class="token punctuation">(</span>    font<span class="token operator">=</span>dict<span class="token punctuation">(</span>family<span class="token operator">=</span><span class="token string">"Arial"</span><span class="token punctuation">,</span> size<span class="token operator">=</span><span class="token number">14</span><span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token string">"red"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true"># 配置字体样式</span>    plot_bgcolor<span class="token operator">=</span><span class="token string">"lightgray"</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true"># 设置图表背景颜色</span>    paper_bgcolor<span class="token operator">=</span><span class="token string">"white"</span>  <span class="token comment" spellcheck="true"># 设置绘图区域背景颜色</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 显示图表</span>fig<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h2 id="5-3-添加背景图和水印"><a href="#5-3-添加背景图和水印" class="headerlink" title="5.3 添加背景图和水印"></a>5.3 添加背景图和水印</h2><p>Plotly允许在图表上添加背景图和水印，以提供更多的信息或品牌标识。下面是一个示例，演示如何添加背景图和水印：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> plotly<span class="token punctuation">.</span>graph_objs <span class="token keyword">as</span> go<span class="token comment" spellcheck="true"># 创建图表</span>fig <span class="token operator">=</span> go<span class="token punctuation">.</span>Figure<span class="token punctuation">(</span>data<span class="token operator">=</span>go<span class="token punctuation">.</span>Scatter<span class="token punctuation">(</span>x<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> y<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> mode<span class="token operator">=</span><span class="token string">'markers'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 添加背景图</span>fig<span class="token punctuation">.</span>add_layout_image<span class="token punctuation">(</span>    source<span class="token operator">=</span><span class="token string">"your_background_image.jpg"</span><span class="token punctuation">,</span>    x<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>    y<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>    xref<span class="token operator">=</span><span class="token string">"paper"</span><span class="token punctuation">,</span>    yref<span class="token operator">=</span><span class="token string">"paper"</span><span class="token punctuation">,</span>    sizex<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>    sizey<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>    opacity<span class="token operator">=</span><span class="token number">0.5</span><span class="token punctuation">,</span>    layer<span class="token operator">=</span><span class="token string">"below"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 添加水印</span>fig<span class="token punctuation">.</span>add_annotation<span class="token punctuation">(</span>    text<span class="token operator">=</span><span class="token string">"Your Watermark"</span><span class="token punctuation">,</span>    x<span class="token operator">=</span><span class="token number">0.5</span><span class="token punctuation">,</span>    y<span class="token operator">=</span><span class="token number">0.5</span><span class="token punctuation">,</span>    xref<span class="token operator">=</span><span class="token string">"paper"</span><span class="token punctuation">,</span>    yref<span class="token operator">=</span><span class="token string">"paper"</span><span class="token punctuation">,</span>    showarrow<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span>    font<span class="token operator">=</span>dict<span class="token punctuation">(</span>size<span class="token operator">=</span><span class="token number">30</span><span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token string">"gray"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 显示图表</span>fig<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h2 id="5-4-导出和分享图表"><a href="#5-4-导出和分享图表" class="headerlink" title="5.4 导出和分享图表"></a>5.4 导出和分享图表</h2><p>一旦完成了图表的创建和定制，可以导出图表以分享或嵌入到网页中。下面是一个示例，演示如何导出图表为静态图像文件：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> plotly<span class="token punctuation">.</span>graph_objs <span class="token keyword">as</span> go<span class="token comment" spellcheck="true"># 创建图表</span>fig <span class="token operator">=</span> go<span class="token punctuation">.</span>Figure<span class="token punctuation">(</span>data<span class="token operator">=</span>go<span class="token punctuation">.</span>Scatter<span class="token punctuation">(</span>x<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> y<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> mode<span class="token operator">=</span><span class="token string">'markers'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 导出图表为静态图像文件（PNG格式）</span>fig<span class="token punctuation">.</span>write_image<span class="token punctuation">(</span><span class="token string">"my_plot.png"</span><span class="token punctuation">)</span></code></pre><p>通过这些示例，可以了解如何进行高级主题定制，包括自定义主题样式、颜色和字体样式的配置，以及如何添加背景图和水印。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>Plotly是一个功能强大且灵活的工具，适用于各种数据可视化需求。通过学习和掌握这些技巧，您将能够创建引人入胜的交互式可视化，使您的数据更具吸引力和可用性。希望本篇博客对您的数据分析和可视化工作有所帮助，激发您的创造力和探索精神。</p><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p>代码与html文件： <a href="https://bevis.lanzouq.com/iZtSl1c62utg" target="_blank" rel="noopener">https://bevis.lanzouq.com/iZtSl1c62utg</a> </p>]]></content>
      
      
      <categories>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据分析 </tag>
            
            <tag> python </tag>
            
            <tag> plotly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python数据分析-seaborn</title>
      <link href="/shu-fen-seaborn.html"/>
      <url>/shu-fen-seaborn.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在现代数据科学和数据分析中，可视化是一项至关重要的任务。可视化图表可以帮助我们更好地理解数据、发现趋势和模式，以及与他人分享我们的发现。Python作为一种强大的编程语言，拥有许多出色的库，用于创建各种类型的可视化图表。</p><p>在数据可视化领域，Matplotlib是最常用的库之一，它提供了广泛的绘图功能，但也存在一些其他可视化库，每个都具有独特的优点。除了Matplotlib，Seaborn和Plotly也是数据科学家和分析师常用的可视化工具。这三个库都为我们提供了强大的工具来可视化数据，但它们在某些方面各有卓越之处。</p><p> 本文将着重介绍Seaborn，Seaborn是一个Python可视化库，专注于统计数据可视化。与Matplotlib和Plotly相比，Seaborn提供了更多样的数据可视化效果和美观的默认样式，使得数据的探索和展示更加简单和直观。 </p><blockquote><p>本文提供了各种示例代码，图像就不提供出来了，简单示例可以通过运行获得图像</p><p>原因：个人采用的是github图床，利用jsDelivr 提供的全球 CDN 加速 </p><p>github 和jsdelivr 都有大小限制： GitHub 图床仓库大小<strong>不能超过1G</strong>。 因为GitHub 原则上是反对仓库图床化的，当仓库超过1G 后会有人工审核仓库内容，如果发现用来做图床，轻则删库重则封号 </p><p>​    当然，主要还是简单图例我觉得太多，太麻烦……放重点图例吧哈哈</p></blockquote><h1 id="Seaborn简介"><a href="#Seaborn简介" class="headerlink" title="Seaborn简介"></a>Seaborn简介</h1><p>Seaborn是一个强大的Python数据可视化库，<strong>专注于统计图形</strong>。它建立在Matplotlib之上，提供了一种更高级的接口，使数据可视化变得更加简单和美观。</p><h2 id="Seaborn特点和优势："><a href="#Seaborn特点和优势：" class="headerlink" title="Seaborn特点和优势："></a>Seaborn特点和优势：</h2><ol><li><p><strong>美观性</strong>: Seaborn内置了各种吸引人的颜色主题和样式，使图表看起来更专业和美观。</p></li><li><p><strong>简单的API</strong>: Seaborn的API设计非常直观，容易上手，允许创建复杂的图形，而无需大量代码。</p></li><li><p><strong>统计分析</strong>: Seaborn专注于统计可视化，提供了丰富的图表类型，用于探索数据集的统计关系。</p></li><li><p><strong>内置数据集</strong>: Seaborn附带了一些示例数据集，方便快速进行实验和练习。</p></li><li><p><strong>适用性广泛</strong>: Seaborn适用于各种数据类型，包括分类数据、时间序列和多维数据。</p></li><li><p><strong>美化默认设置</strong>: Seaborn自动设置了Matplotlib的默认参数，使得生成漂亮的图表变得更加容易。</p></li></ol><h1 id="安装Seaborn"><a href="#安装Seaborn" class="headerlink" title="安装Seaborn"></a>安装Seaborn</h1><ol><li><p>打开命令行终端或Anaconda终端（如果你使用Anaconda）。</p></li><li><p>使用pip安装Seaborn，运行以下命令：</p><pre class=" language-cmd"><code class="language-cmd">pip install seaborn</code></pre><p>这将下载并安装Seaborn包。</p></li><li><p>确认安装是否成功。你可以在Python中启动一个交互式会话，并输入以下命令：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> seaborn <span class="token keyword">as</span> sns</code></pre></li></ol><h2 id="常见安装问题及解决方案"><a href="#常见安装问题及解决方案" class="headerlink" title="常见安装问题及解决方案"></a><strong>常见安装问题及解决方案</strong></h2><p>在安装Seaborn时，有时候可能会遇到一些常见的问题，解决方案如下：</p><ol><li><p><strong>版本不匹配问题</strong>: 如果你遇到与其他库版本不匹配的问题，可以尝试更新pip和setuptools：</p><pre><code>pip install --upgrade pippip install --upgrade setuptools</code></pre></li><li><p><strong>依赖项问题</strong>: Seaborn依赖于其他库，如果缺少这些依赖项，可以使用以下命令安装：</p><pre><code>pip install numpy scipy matplotlib pandas</code></pre></li><li><p><strong>Python环境问题</strong>: 确保正在使用正确的Python环境。有时候，安装可能会出现在不正确的Python版本上。</p></li></ol><h1 id="数据可视化基础"><a href="#数据可视化基础" class="headerlink" title="数据可视化基础"></a>数据可视化基础</h1><p>Seaborn提供了多种用于数据可视化的函数和工具，使得创建各种类型的图表变得相对容易。以下将介绍Seaborn中的一些最常用的数据可视化工具，并为每个工具提供代码示例，以便更好地理解其参数和用途。</p><h2 id="散点图（Scatter-Plots）"><a href="#散点图（Scatter-Plots）" class="headerlink" title="散点图（Scatter Plots）"></a>散点图（Scatter Plots）</h2><p>散点图是一种用于展示两个变量之间关系的基本图表类型。Seaborn提供了<code>scatterplot</code>函数，用于创建散点图。示例代码如下：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> seaborn <span class="token keyword">as</span> sns<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token comment" spellcheck="true"># 创建散点图</span>sns<span class="token punctuation">.</span>scatterplot<span class="token punctuation">(</span>x<span class="token operator">=</span><span class="token string">"x_variable"</span><span class="token punctuation">,</span> y<span class="token operator">=</span><span class="token string">"y_variable"</span><span class="token punctuation">,</span> data<span class="token operator">=</span>data<span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>参数解释：</p><ul><li><code>x_variable</code>和<code>y_variable</code>：要显示的变量。</li><li><code>data</code>：数据集。</li></ul><h2 id="柱状图（Bar-Plots）"><a href="#柱状图（Bar-Plots）" class="headerlink" title="柱状图（Bar Plots）"></a>柱状图（Bar Plots）</h2><p>柱状图用于比较不同类别之间的数据。Seaborn的<code>barplot</code>函数可用于创建柱状图。示例代码如下：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> seaborn <span class="token keyword">as</span> sns<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token comment" spellcheck="true"># 创建柱状图</span>sns<span class="token punctuation">.</span>barplot<span class="token punctuation">(</span>x<span class="token operator">=</span><span class="token string">"category"</span><span class="token punctuation">,</span> y<span class="token operator">=</span><span class="token string">"value"</span><span class="token punctuation">,</span> data<span class="token operator">=</span>data<span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>参数解释：</p><ul><li><code>category</code>：类别变量。</li><li><code>value</code>：对应的数值。</li><li><code>data</code>：数据集。</li></ul><h2 id="折线图（Line-Plots）"><a href="#折线图（Line-Plots）" class="headerlink" title="折线图（Line Plots）"></a>折线图（Line Plots）</h2><p>折线图用于显示变量随时间变化的趋势。Seaborn的<code>lineplot</code>函数可用于创建折线图。示例代码如下：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> seaborn <span class="token keyword">as</span> sns<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token comment" spellcheck="true"># 创建折线图</span>sns<span class="token punctuation">.</span>lineplot<span class="token punctuation">(</span>x<span class="token operator">=</span><span class="token string">"time"</span><span class="token punctuation">,</span> y<span class="token operator">=</span><span class="token string">"value"</span><span class="token punctuation">,</span> data<span class="token operator">=</span>data<span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>参数解释：</p><ul><li><code>time</code>：时间变量。</li><li><code>value</code>：对应的数值。</li><li><code>data</code>：数据集。</li></ul><h2 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h2><p>在可视化之前做的数据准备,确保数据适合可视化：</p><ol><li><p><strong>数据清理</strong>：删除缺失值，处理异常值，确保数据质量。</p></li><li><p><strong>数据格式转换</strong>：确保数据类型正确，例如，将日期时间转换为日期时间类型，将分类数据转换为分类类型。</p></li><li><p><strong>数据筛选</strong>：选择感兴趣的子集数据以便于可视化，以避免过多的信息混淆。</p></li><li><p><strong>数据聚合</strong>：在需要时对数据进行聚合，以便进行汇总统计或时间序列分析。</p></li><li><p><strong>数据排序</strong>：根据需要对数据进行排序，以确保图表的顺序符合预期。</p></li></ol><h1 id="分布类图表"><a href="#分布类图表" class="headerlink" title="分布类图表"></a>分布类图表</h1><p>分布类图表是用于了解数据分布的强大工具。Seaborn提供了多种图表类型来可视化数据的分布，包括直方图和核密度估计图。</p><h2 id="直方图（Histograms）"><a href="#直方图（Histograms）" class="headerlink" title="直方图（Histograms）"></a>直方图（Histograms）</h2><p>直方图是用于显示数值数据分布的常用工具。Seaborn的<code>histplot</code>函数用于创建直方图。示例代码如下：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> seaborn <span class="token keyword">as</span> sns<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token comment" spellcheck="true"># 创建直方图</span>sns<span class="token punctuation">.</span>histplot<span class="token punctuation">(</span>data<span class="token operator">=</span>data<span class="token punctuation">,</span> x<span class="token operator">=</span><span class="token string">"variable"</span><span class="token punctuation">,</span> kde<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>参数解释：</p><ul><li><code>data</code>：数据集。</li><li><code>variable</code>：要绘制直方图的变量。</li><li><code>kde=True</code>：可选择添加核密度估计曲线。</li></ul><p>直方图适用于单一变量的分布分析，以了解其分布形状和集中趋势。</p><h2 id="核密度估计图（Kernel-Density-Estimation-KDE）"><a href="#核密度估计图（Kernel-Density-Estimation-KDE）" class="headerlink" title="核密度估计图（Kernel Density Estimation, KDE）"></a>核密度估计图（Kernel Density Estimation, KDE）</h2><p>核密度估计图是用于平滑显示数据分布的工具。Seaborn的<code>kdeplot</code>函数用于创建核密度估计图。示例代码如下：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> seaborn <span class="token keyword">as</span> sns<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token comment" spellcheck="true"># 创建核密度估计图</span>sns<span class="token punctuation">.</span>kdeplot<span class="token punctuation">(</span>data<span class="token operator">=</span>data<span class="token punctuation">,</span> x<span class="token operator">=</span><span class="token string">"variable"</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>核密度估计图适用于对数据分布的平滑展示，有助于发现潜在的分布模式。</p><p><strong>分析数据分布和变量关系</strong></p><ul><li><p>直方图用于探索单一变量的分布。你可以观察数据集中数据的集中趋势、分散程度以及是否存在多个峰值。</p></li><li><p>核密度估计图有助于了解数据的平滑分布情况，以便更好地理解数据的密度和概率分布。</p></li><li><p>这些图表可用于比较不同变量的分布，以识别变量之间的模式和关系。</p></li><li><p>可以将直方图和核密度估计图与其他变量组合，例如，创建不同组之间的直方图，以进一步探索变量之间的关系。</p></li></ul><h1 id="线性关系图表"><a href="#线性关系图表" class="headerlink" title="线性关系图表"></a>线性关系图表</h1><p>线性关系图表有助于研究不同变量之间的线性关系和相关性</p><h2 id="散点图矩阵（Pair-Plots）"><a href="#散点图矩阵（Pair-Plots）" class="headerlink" title="散点图矩阵（Pair Plots）"></a>散点图矩阵（Pair Plots）</h2><p>散点图矩阵用于可视化多个数值变量之间的散点图。Seaborn的<code>pairplot</code>函数可以创建散点图矩阵。示例代码如下：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> seaborn <span class="token keyword">as</span> sns<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token comment" spellcheck="true"># 创建散点图矩阵</span>sns<span class="token punctuation">.</span>pairplot<span class="token punctuation">(</span>data<span class="token operator">=</span>data<span class="token punctuation">,</span> hue<span class="token operator">=</span><span class="token string">"category"</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>散点图矩阵对于了解多个变量之间的线性和非线性关系非常有用。颜色编码可用于区分不同类别。</p><h2 id="回归分析图（Regression-Plots）"><a href="#回归分析图（Regression-Plots）" class="headerlink" title="回归分析图（Regression Plots）"></a>回归分析图（Regression Plots）</h2><p>回归分析图用于可视化两个数值变量之间的线性关系。Seaborn的<code>regplot</code>函数可以创建回归分析图。示例代码如下：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> seaborn <span class="token keyword">as</span> sns<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token comment" spellcheck="true"># 创建回归分析图</span>sns<span class="token punctuation">.</span>regplot<span class="token punctuation">(</span>x<span class="token operator">=</span><span class="token string">"x_variable"</span><span class="token punctuation">,</span> y<span class="token operator">=</span><span class="token string">"y_variable"</span><span class="token punctuation">,</span> data<span class="token operator">=</span>data<span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>回归分析图有助于识别变量之间的线性关系，包括相关性和回归线。</p><h2 id="分类散点图（Categorical-Scatter-Plots）"><a href="#分类散点图（Categorical-Scatter-Plots）" class="headerlink" title="分类散点图（Categorical Scatter Plots）"></a>分类散点图（Categorical Scatter Plots）</h2><p>分类散点图用于可视化分类变量和数值变量之间的关系。Seaborn的<code>stripplot</code>和<code>swarmplot</code>函数可用于创建分类散点图。示例代码如下：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> seaborn <span class="token keyword">as</span> sns<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token comment" spellcheck="true"># 创建分类散点图</span>sns<span class="token punctuation">.</span>stripplot<span class="token punctuation">(</span>x<span class="token operator">=</span><span class="token string">"category"</span><span class="token punctuation">,</span> y<span class="token operator">=</span><span class="token string">"value"</span><span class="token punctuation">,</span> data<span class="token operator">=</span>data<span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>分类散点图有助于了解不同类别中数值变量的分布，以及它们与分类变量之间的关系。</p><h2 id="识别变量之间的线性关系和相关性"><a href="#识别变量之间的线性关系和相关性" class="headerlink" title="识别变量之间的线性关系和相关性"></a>识别变量之间的线性关系和相关性</h2><ul><li><p>散点图矩阵是用于可视化多个数值变量之间的关系，通过观察图表中的散点分布，可以初步了解变量之间是否存在线性相关性。</p></li><li><p>回归分析图有助于识别两个数值变量之间的线性关系，包括相关性的强度和方向。回归线的趋势可用于预测变量之间的关系。</p></li><li><p>分类散点图用于将分类变量与数值变量关联，有助于观察不同类别之间的分布和可能的差异，从而探索变量之间的相关性。</p></li></ul><h1 id="分类图表"><a href="#分类图表" class="headerlink" title="分类图表"></a>分类图表</h1><p>分类图表是用于比较不同类别之间的数据的强大工具，它可以帮助揭示数据的分布和关系。Seaborn提供了多种分类图表类型。</p><h2 id="条形图（Bar-Plots）"><a href="#条形图（Bar-Plots）" class="headerlink" title="条形图（Bar Plots）"></a>条形图（Bar Plots）</h2><p>条形图是用于比较不同类别之间的数据的经典图表类型。Seaborn的<code>barplot</code>函数用于创建条形图。示例代码如下：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> seaborn <span class="token keyword">as</span> sns<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token comment" spellcheck="true"># 创建条形图</span>sns<span class="token punctuation">.</span>barplot<span class="token punctuation">(</span>x<span class="token operator">=</span><span class="token string">"category"</span><span class="token punctuation">,</span> y<span class="token operator">=</span><span class="token string">"value"</span><span class="token punctuation">,</span> data<span class="token operator">=</span>data<span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>何时使用：条形图适用于显示不同类别的数据的平均值或总和，以比较它们之间的差异。</p><h2 id="箱线图（Box-Plots）"><a href="#箱线图（Box-Plots）" class="headerlink" title="箱线图（Box Plots）"></a>箱线图（Box Plots）</h2><p>箱线图用于可视化数据的分布和离群值。Seaborn的<code>boxplot</code>函数用于创建箱线图。示例代码如下：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> seaborn <span class="token keyword">as</span> sns<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token comment" spellcheck="true"># 创建箱线图</span>sns<span class="token punctuation">.</span>boxplot<span class="token punctuation">(</span>x<span class="token operator">=</span><span class="token string">"category"</span><span class="token punctuation">,</span> y<span class="token operator">=</span><span class="token string">"value"</span><span class="token punctuation">,</span> data<span class="token operator">=</span>data<span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>何时使用：箱线图适用于比较不同类别的数据的分布、中位数和离群值，以识别数据的离散程度。</p><h2 id="小提琴图（Violin-Plots）"><a href="#小提琴图（Violin-Plots）" class="headerlink" title="小提琴图（Violin Plots）"></a>小提琴图（Violin Plots）</h2><p>小提琴图结合了箱线图和核密度估计图的优点，用于可视化数据的分布。Seaborn的<code>violinplot</code>函数用于创建小提琴图。示例代码如下：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> seaborn <span class="token keyword">as</span> sns<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token comment" spellcheck="true"># 创建小提琴图</span>sns<span class="token punctuation">.</span>violinplot<span class="token punctuation">(</span>x<span class="token operator">=</span><span class="token string">"category"</span><span class="token punctuation">,</span> y<span class="token operator">=</span><span class="token string">"value"</span><span class="token punctuation">,</span> data<span class="token operator">=</span>data<span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>何时使用：小提琴图适用于比较不同类别的数据的分布形状，以及它们的分布密度。</p><h2 id="使用分类图表进行数据分析"><a href="#使用分类图表进行数据分析" class="headerlink" title="使用分类图表进行数据分析"></a>使用分类图表进行数据分析</h2><ul><li><p>条形图适用于比较不同类别的数据的中心趋势，例如均值或总和，特别适用于分类数据。</p></li><li><p>箱线图有助于比较不同类别的数据的分布形状，包括中位数、上下四分位数和离群值。</p></li><li><p>小提琴图在比较不同类别的数据的分布形状和密度时非常有用，可用于探索数据的多样性。</p></li><li><p>这些分类图表可以帮助分析不同类别之间的数据差异，从而更好地理解数据集的性质。</p></li></ul><h1 id="网格图表"><a href="#网格图表" class="headerlink" title="网格图表"></a>网格图表</h1><p>Seaborn的网格图表工具能够创建复杂的多维数据可视化图形，用于探索多个变量之间的关系。这些工具包括<code>FacetGrid</code>和<code>PairGrid</code>。</p><h2 id="FacetGrid"><a href="#FacetGrid" class="headerlink" title="FacetGrid"></a>FacetGrid</h2><p><code>FacetGrid</code>是Seaborn中用于创建多个子图的工具，允许在同一图表中探索多个变量之间的关系。使用<code>FacetGrid</code>来创建多个子图，每个子图显示数据在不同条件下的分布。示例代码如下：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> seaborn <span class="token keyword">as</span> sns<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token comment" spellcheck="true"># 创建FacetGrid</span>g <span class="token operator">=</span> sns<span class="token punctuation">.</span>FacetGrid<span class="token punctuation">(</span>data<span class="token punctuation">,</span> col<span class="token operator">=</span><span class="token string">"category"</span><span class="token punctuation">,</span> hue<span class="token operator">=</span><span class="token string">"group"</span><span class="token punctuation">)</span>g<span class="token punctuation">.</span>map<span class="token punctuation">(</span>sns<span class="token punctuation">.</span>scatterplot<span class="token punctuation">,</span> <span class="token string">"x_variable"</span><span class="token punctuation">,</span> <span class="token string">"y_variable"</span><span class="token punctuation">)</span>g<span class="token punctuation">.</span>add_legend<span class="token punctuation">(</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p><code>FacetGrid</code>允许在不同的列或行中显示数据，以比较不同条件下的关系。</p><h2 id="PairGrid"><a href="#PairGrid" class="headerlink" title="PairGrid"></a>PairGrid</h2><p><code>PairGrid</code>是用于创建散点图矩阵的工具，有助于在多个变量之间查看关系。使用<code>PairGrid</code>来创建多个子图，每个子图显示数据中不同变量的组合。示例代码如下：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> seaborn <span class="token keyword">as</span> sns<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token comment" spellcheck="true"># 创建PairGrid</span>g <span class="token operator">=</span> sns<span class="token punctuation">.</span>PairGrid<span class="token punctuation">(</span>data<span class="token punctuation">,</span> hue<span class="token operator">=</span><span class="token string">"category"</span><span class="token punctuation">)</span>g<span class="token punctuation">.</span>map_upper<span class="token punctuation">(</span>sns<span class="token punctuation">.</span>scatterplot<span class="token punctuation">)</span>g<span class="token punctuation">.</span>map_lower<span class="token punctuation">(</span>sns<span class="token punctuation">.</span>kdeplot<span class="token punctuation">)</span>g<span class="token punctuation">.</span>map_diag<span class="token punctuation">(</span>sns<span class="token punctuation">.</span>histplot<span class="token punctuation">)</span>g<span class="token punctuation">.</span>add_legend<span class="token punctuation">(</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p><code>PairGrid</code>用于比较不同变量之间的关系，包括散点图、核密度估计图和直方图。</p><h2 id="创建复杂多维数据可视化"><a href="#创建复杂多维数据可视化" class="headerlink" title="创建复杂多维数据可视化"></a>创建复杂多维数据可视化</h2><ul><li><p><code>FacetGrid</code>允许你根据不同条件分隔数据，以在不同子图中探索多个变量之间的关系。</p></li><li><p><code>PairGrid</code>用于创建多个子图，每个子图显示数据中不同变量的组合，有助于比较多个变量之间的关系。</p></li><li><p>这些网格图表工具非常适合在一个图表中查看多个变量之间的复杂关系，帮助你深入分析数据。</p></li></ul><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>Seaborn作为Python数据分析的利器，为数据科学家和分析师提供了丰富的工具来更好地理解数据、发现趋势和模式，并将洞察力转化为有力的决策。它的美观性和易用性使得数据可视化变得更加吸引人。在实际工作中，选择合适的可视化工具对于成功的数据分析至关重要，而Seaborn无疑是一个不可或缺的伙伴。</p>]]></content>
      
      
      <categories>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据分析 </tag>
            
            <tag> python </tag>
            
            <tag> seaborn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python数据分析-matplotlib</title>
      <link href="/shu-fen-matplotlib.html"/>
      <url>/shu-fen-matplotlib.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>当谈论数据分析和数据可视化时，Matplotlib是一个强大的工具，它不仅提供了丰富的功能，还允许用户创建高质量的图形和图表。本篇博客旨在帮助你掌握Matplotlib的基础知识和高级技巧，以便你能够有效地利用它来展示数据、解释趋势和传达信息。</p><p>在这篇博客中，我们将深入探讨Matplotlib的各个方面，从数据可视化的基础开始，包括折线图、散点图、条形图、直方图和饼图等，一直到更高级的图形元素，如图形注释、箭头、图例高级用法、区域填充和阴影效果。我们还将学习如何创建三维数据可视化、动画和交互式控件，以及如何导出图形文件、设置图形风格和自定义色彩和配色方案。</p><blockquote><p>本文提供了各种示例代码，图像就不提供出来了，简单示例可以通过复制代码运行获得图像</p><p>原因：个人采用的是github图床，利用jsDelivr 提供的全球 CDN 加速 </p><p>github 和jsdelivr 都有大小限制： GitHub 图床仓库大小<strong>不能超过1G</strong>。 因为GitHub 原则上是反对仓库图床化的，当仓库超过1G 后会有人工审核仓库内容，如果发现用来做图床，轻则删库重则封号 </p><p>​    当然，主要还是简单图例我觉得太多，太麻烦……放重点图例吧哈哈</p></blockquote><h1 id="1-Matplotlib-简介和安装"><a href="#1-Matplotlib-简介和安装" class="headerlink" title="1. Matplotlib 简介和安装"></a>1. Matplotlib 简介和安装</h1><ul><li><p><strong>Matplotlib简介</strong>：Matplotlib是Python中最常用的数据可视化库之一，用于创建静态、动态、交互式图表。</p></li><li><p><strong>安装Matplotlib</strong>：使用<code>pip</code>或<code>conda</code>可以轻松安装Matplotlib。</p><p>示例代码：</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 安装Matplotlib</span>!pip install matplotlib</code></pre></li></ul><h1 id="2-Matplotlib-绘图原理"><a href="#2-Matplotlib-绘图原理" class="headerlink" title="2. Matplotlib 绘图原理"></a>2. Matplotlib 绘图原理</h1><ul><li><strong>绘图原理</strong>：Matplotlib采用面向对象的方式来创建图表。所有图表元素都是对象，从<code>Figure</code>对象到<code>Axes</code>对象，都是构建图表的关键部分。</li></ul><h1 id="3-Matplotlib-常用模块和函数"><a href="#3-Matplotlib-常用模块和函数" class="headerlink" title="3. Matplotlib 常用模块和函数"></a>3. Matplotlib 常用模块和函数</h1><h2 id="pyplot-模块"><a href="#pyplot-模块" class="headerlink" title="pyplot 模块"></a><code>pyplot</code> 模块</h2><ul><li><p><strong><code>pyplot</code>简介</strong>：<code>pyplot</code>是Matplotlib的一个子模块，提供了一种类似于MATLAB的界面，用于绘制图表。</p><p>示例代码：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt</code></pre><h2 id="Figure-对象和子图"><a href="#Figure-对象和子图" class="headerlink" title="Figure 对象和子图"></a><code>Figure</code> 对象和子图</h2></li><li><p><strong><code>Figure</code>对象</strong>：<code>Figure</code>对象是图表的顶层容器，用于容纳图表中的所有元素。</p></li><li><p><strong>子图</strong>：子图是<code>Axes</code>对象的容器，用于在一个<code>Figure</code>对象中容纳多个图表。</p><p>示例代码：</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 创建一个Figure对象</span>fig <span class="token operator">=</span> plt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 创建一个子图</span>ax <span class="token operator">=</span> fig<span class="token punctuation">.</span>add_subplot<span class="token punctuation">(</span><span class="token number">111</span><span class="token punctuation">)</span></code></pre><h2 id="Axes-对象和坐标系"><a href="#Axes-对象和坐标系" class="headerlink" title="Axes 对象和坐标系"></a><code>Axes</code> 对象和坐标系</h2></li><li><p><strong><code>Axes</code>对象</strong>：<code>Axes</code>对象是图表的主要绘图区域，用于绘制数据点、线条、文本等。</p></li><li><p><strong>坐标系</strong>：<code>Axes</code>对象具有X和Y坐标轴，你可以在坐标轴上绘制数据。</p><p>示例代码：</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 绘制一条线</span>ax<span class="token punctuation">.</span>plot<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><h2 id="图形属性设置"><a href="#图形属性设置" class="headerlink" title="图形属性设置"></a>图形属性设置</h2></li><li><p><strong>线条样式</strong>：通过<code>linestyle</code>参数设置线条样式。</p></li><li><p><strong>颜色</strong>：通过<code>color</code>参数设置线条颜色。</p></li><li><p><strong>标记点</strong>：通过<code>marker</code>参数设置标记点样式。</p><p>示例代码：</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 自定义线条样式、颜色和标记点</span>ax<span class="token punctuation">.</span>plot<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> linestyle<span class="token operator">=</span><span class="token string">'--'</span><span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token string">'red'</span><span class="token punctuation">,</span> marker<span class="token operator">=</span><span class="token string">'o'</span><span class="token punctuation">)</span></code></pre><h2 id="文本标注和注释"><a href="#文本标注和注释" class="headerlink" title="文本标注和注释"></a>文本标注和注释</h2></li><li><p><strong>添加文本标注</strong>：使用<code>text()</code>函数在图表中添加文本标注。</p></li><li><p><strong>添加注释</strong>：使用<code>annotate()</code>函数添加带箭头的注释。</p><p>示例代码：</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 添加文本标注</span>ax<span class="token punctuation">.</span>text<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'Data Point (1, 3)'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 添加注释</span>ax<span class="token punctuation">.</span>annotate<span class="token punctuation">(</span><span class="token string">'Max Value'</span><span class="token punctuation">,</span> xy<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span> xytext<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">1.5</span><span class="token punctuation">,</span> <span class="token number">3.5</span><span class="token punctuation">)</span><span class="token punctuation">,</span>          arrowprops<span class="token operator">=</span>dict<span class="token punctuation">(</span>arrowstyle<span class="token operator">=</span><span class="token string">'->'</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre></li></ul><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token comment" spellcheck="true"># 创建一个Figure对象</span>fig <span class="token operator">=</span> plt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 创建一个子图</span>ax <span class="token operator">=</span> fig<span class="token punctuation">.</span>add_subplot<span class="token punctuation">(</span><span class="token number">111</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 调整坐标轴刻度线和标签的颜色为白色——我的jupyter notebook的背景色是黑色，改与自己主题颜色适应的坐标轴颜色</span>ax<span class="token punctuation">.</span>tick_params<span class="token punctuation">(</span>axis<span class="token operator">=</span><span class="token string">'both'</span><span class="token punctuation">,</span> colors<span class="token operator">=</span><span class="token string">'white'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 绘制一条线</span>ax<span class="token punctuation">.</span>plot<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 自定义线条样式、颜色和标记点</span>ax<span class="token punctuation">.</span>plot<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> linestyle<span class="token operator">=</span><span class="token string">'--'</span><span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token string">'red'</span><span class="token punctuation">,</span> marker<span class="token operator">=</span><span class="token string">'o'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 添加文本标注</span>ax<span class="token punctuation">.</span>text<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'Data Point (1, 3)'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 添加注释</span>ax<span class="token punctuation">.</span>annotate<span class="token punctuation">(</span><span class="token string">'Max Value'</span><span class="token punctuation">,</span> xy<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span> xytext<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">1.5</span><span class="token punctuation">,</span> <span class="token number">3.5</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            arrowprops<span class="token operator">=</span>dict<span class="token punctuation">(</span>arrowstyle<span class="token operator">=</span><span class="token string">'->'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h1 id="4-折线图绘制"><a href="#4-折线图绘制" class="headerlink" title="4.折线图绘制"></a>4.折线图绘制</h1><h2 id="单条折线图"><a href="#单条折线图" class="headerlink" title="单条折线图"></a>单条折线图</h2><p>绘制一个简单的单条折线图。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token comment" spellcheck="true"># 创建示例数据</span>x <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span>y <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 绘制折线图</span>plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> label<span class="token operator">=</span><span class="token string">'Line 1'</span><span class="token punctuation">,</span> marker<span class="token operator">=</span><span class="token string">'o'</span><span class="token punctuation">,</span> linestyle<span class="token operator">=</span><span class="token string">'-'</span><span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token string">'blue'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 添加标题和标签</span>plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token string">'单条折线图'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>xlabel<span class="token punctuation">(</span><span class="token string">'X轴'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>ylabel<span class="token punctuation">(</span><span class="token string">'Y轴'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 显示图例</span>plt<span class="token punctuation">.</span>legend<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 显示图表</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><ul><li><code>plt.plot(x, y, label=&#39;Line 1&#39;, marker=&#39;o&#39;, linestyle=&#39;-&#39;, color=&#39;blue&#39;)</code>：这行代码绘制了折线图。<code>x</code>和<code>y</code>分别是X轴和Y轴的数据，<code>label</code>用于设置图例标签，<code>marker</code>指定标记点的样式，<code>linestyle</code>设置线条样式，<code>color</code>设置线条颜色。</li><li><code>plt.title(&#39;单条折线图&#39;)</code>：添加标题。</li><li><code>plt.xlabel(&#39;X轴&#39;)</code> 和 <code>plt.ylabel(&#39;Y轴&#39;)</code>：添加X轴和Y轴的标签。</li><li><code>plt.legend()</code>：显示图例。</li><li><code>plt.show()</code>：显示图表。</li></ul><h2 id="多条折线图"><a href="#多条折线图" class="headerlink" title="多条折线图"></a>多条折线图</h2><p>绘制多条折线图。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token comment" spellcheck="true"># 创建示例数据</span>x <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span>y1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">]</span>y2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 绘制多条折线图</span>plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>x<span class="token punctuation">,</span> y1<span class="token punctuation">,</span> label<span class="token operator">=</span><span class="token string">'Line 1'</span><span class="token punctuation">,</span> marker<span class="token operator">=</span><span class="token string">'o'</span><span class="token punctuation">,</span> linestyle<span class="token operator">=</span><span class="token string">'-'</span><span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token string">'blue'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>x<span class="token punctuation">,</span> y2<span class="token punctuation">,</span> label<span class="token operator">=</span><span class="token string">'Line 2'</span><span class="token punctuation">,</span> marker<span class="token operator">=</span><span class="token string">'x'</span><span class="token punctuation">,</span> linestyle<span class="token operator">=</span><span class="token string">'--'</span><span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token string">'red'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 添加标题和标签</span>plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token string">'多条折线图'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>xlabel<span class="token punctuation">(</span><span class="token string">'X轴'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>ylabel<span class="token punctuation">(</span><span class="token string">'Y轴'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 显示图例</span>plt<span class="token punctuation">.</span>legend<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 显示图表</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h1 id="5-散点图绘制"><a href="#5-散点图绘制" class="headerlink" title="5.散点图绘制"></a>5.散点图绘制</h1><h2 id="散点图基本绘制"><a href="#散点图基本绘制" class="headerlink" title="散点图基本绘制"></a>散点图基本绘制</h2><p>绘制一个基本的散点图。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token comment" spellcheck="true"># 创建示例数据</span>x <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span>y <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 绘制散点图</span>plt<span class="token punctuation">.</span>scatter<span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> label<span class="token operator">=</span><span class="token string">'Data Points'</span><span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token string">'blue'</span><span class="token punctuation">,</span> marker<span class="token operator">=</span><span class="token string">'o'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 添加标题和标签</span>plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token string">'基本散点图'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>xlabel<span class="token punctuation">(</span><span class="token string">'X轴'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>ylabel<span class="token punctuation">(</span><span class="token string">'Y轴'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 显示图例</span>plt<span class="token punctuation">.</span>legend<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 显示图表</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><ul><li><code>plt.scatter(x, y, label=&#39;Data Points&#39;, color=&#39;blue&#39;, marker=&#39;o&#39;)</code>：这行代码绘制了散点图。<code>x</code>和<code>y</code>分别是X轴和Y轴的数据，<code>label</code>用于设置图例标签，<code>color</code>设置散点的颜色，<code>marker</code>指定散点的样式。</li></ul><h2 id="散点图颜色映射"><a href="#散点图颜色映射" class="headerlink" title="散点图颜色映射"></a>散点图颜色映射</h2><p>使用颜色映射来为散点图中的数据点添加颜色。下面是一个带有颜色映射的散点图示例：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token comment" spellcheck="true"># 创建示例数据</span>x <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>rand<span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span>y <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>rand<span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span>colors <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>rand<span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 随机生成颜色数据</span><span class="token comment" spellcheck="true"># 绘制散点图，使用颜色映射</span>plt<span class="token punctuation">.</span>scatter<span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> c<span class="token operator">=</span>colors<span class="token punctuation">,</span> cmap<span class="token operator">=</span><span class="token string">'viridis'</span><span class="token punctuation">,</span> label<span class="token operator">=</span><span class="token string">'Data Points'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 添加标题和标签</span>plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token string">'散点图颜色映射'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>xlabel<span class="token punctuation">(</span><span class="token string">'X轴'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>ylabel<span class="token punctuation">(</span><span class="token string">'Y轴'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 添加颜色映射条</span>plt<span class="token punctuation">.</span>colorbar<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 显示图例</span>plt<span class="token punctuation">.</span>legend<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 显示图表</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><ul><li><code>c=colors</code>：通过<code>c</code>参数指定颜色数据。</li><li><code>cmap=&#39;viridis&#39;</code>：通过<code>cmap</code>参数指定颜色映射。</li></ul><h2 id="散点图大小映射"><a href="#散点图大小映射" class="headerlink" title="散点图大小映射"></a>散点图大小映射</h2><p>根据数据的大小来映射散点的大小。下面是一个带有大小映射的散点图示例：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token comment" spellcheck="true"># 创建示例数据</span>x <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>rand<span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span>y <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>rand<span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span>sizes <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>rand<span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">100</span>  <span class="token comment" spellcheck="true"># 随机生成大小数据</span><span class="token comment" spellcheck="true"># 绘制散点图，使用大小映射</span>plt<span class="token punctuation">.</span>scatter<span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> s<span class="token operator">=</span>sizes<span class="token punctuation">,</span> label<span class="token operator">=</span><span class="token string">'Data Points'</span><span class="token punctuation">,</span> alpha<span class="token operator">=</span><span class="token number">0.7</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 添加标题和标签</span>plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token string">'散点图大小映射'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>xlabel<span class="token punctuation">(</span><span class="token string">'X轴'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>ylabel<span class="token punctuation">(</span><span class="token string">'Y轴'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 显示图例</span>plt<span class="token punctuation">.</span>legend<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 显示图表</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><ul><li><code>s=sizes</code>：通过<code>s</code>参数指定大小数据。</li><li><code>alpha=0.7</code>：通过<code>alpha</code>参数设置散点的透明度。</li></ul><h1 id="6-条形图绘制"><a href="#6-条形图绘制" class="headerlink" title="6.条形图绘制"></a>6.条形图绘制</h1><h2 id="水平条形图"><a href="#水平条形图" class="headerlink" title="水平条形图"></a>水平条形图</h2><p>绘制一个水平条形图。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token comment" spellcheck="true"># 创建示例数据</span>categories <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'Category A'</span><span class="token punctuation">,</span> <span class="token string">'Category B'</span><span class="token punctuation">,</span> <span class="token string">'Category C'</span><span class="token punctuation">,</span> <span class="token string">'Category D'</span><span class="token punctuation">]</span>values <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">,</span> <span class="token number">60</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 绘制水平条形图</span>plt<span class="token punctuation">.</span>barh<span class="token punctuation">(</span>categories<span class="token punctuation">,</span> values<span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token string">'skyblue'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 添加标题和标签</span>plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token string">'水平条形图'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>xlabel<span class="token punctuation">(</span><span class="token string">'值'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>ylabel<span class="token punctuation">(</span><span class="token string">'类别'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 显示图表</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><ul><li><code>plt.barh(categories, values, color=&#39;skyblue&#39;)</code>：这行代码绘制了水平条形图。<code>categories</code>是类别标签，<code>values</code>是条形的值，<code>color</code>设置条形的颜色。</li></ul><h2 id="垂直条形图"><a href="#垂直条形图" class="headerlink" title="垂直条形图"></a>垂直条形图</h2><p>绘制一个垂直条形图。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token comment" spellcheck="true"># 创建示例数据</span>categories <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'Category A'</span><span class="token punctuation">,</span> <span class="token string">'Category B'</span><span class="token punctuation">,</span> <span class="token string">'Category C'</span><span class="token punctuation">,</span> <span class="token string">'Category D'</span><span class="token punctuation">]</span>values <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">,</span> <span class="token number">60</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 绘制垂直条形图</span>plt<span class="token punctuation">.</span>bar<span class="token punctuation">(</span>categories<span class="token punctuation">,</span> values<span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token string">'salmon'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 添加标题和标签</span>plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token string">'垂直条形图'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>xlabel<span class="token punctuation">(</span><span class="token string">'类别'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>ylabel<span class="token punctuation">(</span><span class="token string">'值'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 显示图表</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><ul><li><code>plt.bar(categories, values, color=&#39;salmon&#39;)</code>：这行代码绘制了垂直条形图，参数设置与水平条形图类似。</li></ul><h2 id="分组条形图和堆积条形图"><a href="#分组条形图和堆积条形图" class="headerlink" title="分组条形图和堆积条形图"></a>分组条形图和堆积条形图</h2><p>分组条形图和堆积条形图可以通过调整数据和条形的宽度来创建。以下是一个示例：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token comment" spellcheck="true"># 创建示例数据</span>categories <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'Category A'</span><span class="token punctuation">,</span> <span class="token string">'Category B'</span><span class="token punctuation">,</span> <span class="token string">'Category C'</span><span class="token punctuation">,</span> <span class="token string">'Category D'</span><span class="token punctuation">]</span>values1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">,</span> <span class="token number">60</span><span class="token punctuation">]</span>values2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">,</span> <span class="token number">60</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">]</span>width <span class="token operator">=</span> <span class="token number">0.35</span>  <span class="token comment" spellcheck="true"># 条形的宽度</span><span class="token comment" spellcheck="true"># 计算每个类别的中心位置</span>x <span class="token operator">=</span> np<span class="token punctuation">.</span>arange<span class="token punctuation">(</span>len<span class="token punctuation">(</span>categories<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 绘制分组条形图</span>plt<span class="token punctuation">.</span>bar<span class="token punctuation">(</span>x <span class="token operator">-</span> width<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">,</span> values1<span class="token punctuation">,</span> width<span class="token punctuation">,</span> label<span class="token operator">=</span><span class="token string">'Group 1'</span><span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token string">'skyblue'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>bar<span class="token punctuation">(</span>x <span class="token operator">+</span> width<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">,</span> values2<span class="token punctuation">,</span> width<span class="token punctuation">,</span> label<span class="token operator">=</span><span class="token string">'Group 2'</span><span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token string">'salmon'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 添加标题和标签</span>plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token string">'分组条形图'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>xlabel<span class="token punctuation">(</span><span class="token string">'类别'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>ylabel<span class="token punctuation">(</span><span class="token string">'值'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 显示图例</span>plt<span class="token punctuation">.</span>legend<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 显示图表</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><ul><li><code>plt.bar(x - width/2, values1, width, label=&#39;Group 1&#39;, color=&#39;skyblue&#39;)</code>：这行代码绘制了两组分组条形图。<code>x - width/2</code>用于确定第一组的位置，<code>x + width/2</code>用于确定第二组的位置。</li></ul><h1 id="7-直方图绘制"><a href="#7-直方图绘制" class="headerlink" title="7.直方图绘制"></a>7.直方图绘制</h1><h2 id="单变量直方图"><a href="#单变量直方图" class="headerlink" title="单变量直方图"></a>单变量直方图</h2><p>绘制一个单变量直方图，以探索单个变量的分布。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token comment" spellcheck="true"># 创建示例数据（单变量）</span>data <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>randn<span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 绘制单变量直方图</span>plt<span class="token punctuation">.</span>hist<span class="token punctuation">(</span>data<span class="token punctuation">,</span> bins<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token string">'skyblue'</span><span class="token punctuation">,</span> edgecolor<span class="token operator">=</span><span class="token string">'black'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 添加标题和标签</span>plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token string">'单变量直方图'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>xlabel<span class="token punctuation">(</span><span class="token string">'值'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>ylabel<span class="token punctuation">(</span><span class="token string">'频率'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 显示图表</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><ul><li><code>plt.hist(data, bins=20, color=&#39;skyblue&#39;, edgecolor=&#39;black&#39;)</code>：这行代码绘制了单变量直方图。<code>data</code>是要分析的数据，<code>bins</code>参数指定了直方图的箱数，<code>color</code>设置直方图的颜色，<code>edgecolor</code>设置边界颜色。</li></ul><h2 id="双变量直方图"><a href="#双变量直方图" class="headerlink" title="双变量直方图"></a>双变量直方图</h2><p>绘制一个双变量直方图，用于探索两个变量之间的关系。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token comment" spellcheck="true"># 创建示例数据（双变量）</span>x <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>randn<span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span>y <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> x <span class="token operator">+</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>randn<span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 绘制双变量直方图</span>plt<span class="token punctuation">.</span>hist2d<span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> bins<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">,</span> cmap<span class="token operator">=</span><span class="token string">'viridis'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 添加标题和标签</span>plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token string">'双变量直方图'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>xlabel<span class="token punctuation">(</span><span class="token string">'X轴'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>ylabel<span class="token punctuation">(</span><span class="token string">'Y轴'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 添加颜色条</span>plt<span class="token punctuation">.</span>colorbar<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 显示图表</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><ul><li><code>plt.hist2d(x, y, bins=20, cmap=&#39;viridis&#39;)</code>：这行代码绘制了双变量直方图。<code>x</code>和<code>y</code>是两个变量，<code>bins</code>参数指定了直方图的箱数，<code>cmap</code>参数设置颜色映射。</li></ul><h2 id="直方图密度曲线"><a href="#直方图密度曲线" class="headerlink" title="直方图密度曲线"></a>直方图密度曲线</h2><p>直方图密度曲线也被称为核密度估计，它可用于估计数据的连续概率密度。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">from</span> scipy<span class="token punctuation">.</span>stats <span class="token keyword">import</span> norm<span class="token comment" spellcheck="true"># 创建示例数据</span>data <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>randn<span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 绘制直方图</span>plt<span class="token punctuation">.</span>hist<span class="token punctuation">(</span>data<span class="token punctuation">,</span> bins<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">,</span> density<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token string">'skyblue'</span><span class="token punctuation">,</span> alpha<span class="token operator">=</span><span class="token number">0.7</span><span class="token punctuation">,</span> edgecolor<span class="token operator">=</span><span class="token string">'black'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 绘制密度曲线</span>mu<span class="token punctuation">,</span> std <span class="token operator">=</span> norm<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>data<span class="token punctuation">)</span>xmin<span class="token punctuation">,</span> xmax <span class="token operator">=</span> plt<span class="token punctuation">.</span>xlim<span class="token punctuation">(</span><span class="token punctuation">)</span>x <span class="token operator">=</span> np<span class="token punctuation">.</span>linspace<span class="token punctuation">(</span>xmin<span class="token punctuation">,</span> xmax<span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span>p <span class="token operator">=</span> norm<span class="token punctuation">.</span>pdf<span class="token punctuation">(</span>x<span class="token punctuation">,</span> mu<span class="token punctuation">,</span> std<span class="token punctuation">)</span>plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>x<span class="token punctuation">,</span> p<span class="token punctuation">,</span> <span class="token string">'k'</span><span class="token punctuation">,</span> linewidth<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 添加标题和标签</span>plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token string">'直方图和密度曲线'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>xlabel<span class="token punctuation">(</span><span class="token string">'值'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>ylabel<span class="token punctuation">(</span><span class="token string">'密度'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 显示图表</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><ul><li><code>plt.hist(data, bins=20, density=True, color=&#39;skyblue&#39;, alpha=0.7, edgecolor=&#39;black&#39;)</code>：这行代码绘制了直方图，<code>density=True</code>参数将频率转换为密度。</li><li><code>norm.fit(data)</code>：使用正态分布拟合数据以绘制密度曲线。</li><li><code>norm.pdf(x, mu, std)</code>：使用正态分布的概率密度函数绘制密度曲线。</li></ul><h1 id="8-饼图绘制"><a href="#8-饼图绘制" class="headerlink" title="8.饼图绘制"></a>8.饼图绘制</h1><h2 id="基本饼图"><a href="#基本饼图" class="headerlink" title="基本饼图"></a>基本饼图</h2><p>绘制一个基本的饼图，以表示数据占比。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token comment" spellcheck="true"># 创建示例数据</span>labels <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token string">'B'</span><span class="token punctuation">,</span> <span class="token string">'C'</span><span class="token punctuation">,</span> <span class="token string">'D'</span><span class="token punctuation">]</span>sizes <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">45</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">]</span>colors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'skyblue'</span><span class="token punctuation">,</span> <span class="token string">'salmon'</span><span class="token punctuation">,</span> <span class="token string">'lightgreen'</span><span class="token punctuation">,</span> <span class="token string">'lightcoral'</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 绘制基本饼图</span>plt<span class="token punctuation">.</span>pie<span class="token punctuation">(</span>sizes<span class="token punctuation">,</span> labels<span class="token operator">=</span>labels<span class="token punctuation">,</span> colors<span class="token operator">=</span>colors<span class="token punctuation">,</span> autopct<span class="token operator">=</span><span class="token string">'%1.1f%%'</span><span class="token punctuation">,</span> startangle<span class="token operator">=</span><span class="token number">90</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 添加标题</span>plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token string">'基本饼图'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 显示图表</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><ul><li><code>plt.pie(sizes, labels=labels, colors=colors, autopct=&#39;%1.1f%%&#39;, startangle=90)</code>：这行代码绘制了基本饼图。<code>sizes</code>是数据占比，<code>labels</code>是每个切片的标签，<code>colors</code>是切片颜色，<code>autopct</code>用于在饼图中显示百分比，<code>startangle</code>指定饼图的起始角度。</li></ul><h2 id="饼图切片突出和排序"><a href="#饼图切片突出和排序" class="headerlink" title="饼图切片突出和排序"></a>饼图切片突出和排序</h2><p>可以通过突出某个切片来强调数据，也可以通过排序来改变切片的顺序。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token comment" spellcheck="true"># 创建示例数据</span>labels <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token string">'B'</span><span class="token punctuation">,</span> <span class="token string">'C'</span><span class="token punctuation">,</span> <span class="token string">'D'</span><span class="token punctuation">]</span>sizes <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">45</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">]</span>colors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'skyblue'</span><span class="token punctuation">,</span> <span class="token string">'salmon'</span><span class="token punctuation">,</span> <span class="token string">'lightgreen'</span><span class="token punctuation">,</span> <span class="token string">'lightcoral'</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 突出切片 B</span>explode <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0.1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 绘制突出切片的饼图并排序</span>plt<span class="token punctuation">.</span>pie<span class="token punctuation">(</span>sizes<span class="token punctuation">,</span> labels<span class="token operator">=</span>labels<span class="token punctuation">,</span> colors<span class="token operator">=</span>colors<span class="token punctuation">,</span> autopct<span class="token operator">=</span><span class="token string">'%1.1f%%'</span><span class="token punctuation">,</span> startangle<span class="token operator">=</span><span class="token number">90</span><span class="token punctuation">,</span> explode<span class="token operator">=</span>explode<span class="token punctuation">,</span> shadow<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 添加标题</span>plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token string">'突出切片和排序的饼图'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 显示图表</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><ul><li><code>explode = (0, 0.1, 0, 0)</code>：通过<code>explode</code>参数，我们突出了切片 B。</li><li><code>shadow=True</code>：为饼图添加阴影效果。</li></ul><h2 id="饼图标签和百分比"><a href="#饼图标签和百分比" class="headerlink" title="饼图标签和百分比"></a>饼图标签和百分比</h2><p>可以在饼图上添加标签和百分比。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token comment" spellcheck="true"># 创建示例数据</span>labels <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token string">'B'</span><span class="token punctuation">,</span> <span class="token string">'C'</span><span class="token punctuation">,</span> <span class="token string">'D'</span><span class="token punctuation">]</span>sizes <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">45</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">]</span>colors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'skyblue'</span><span class="token punctuation">,</span> <span class="token string">'salmon'</span><span class="token punctuation">,</span> <span class="token string">'lightgreen'</span><span class="token punctuation">,</span> <span class="token string">'lightcoral'</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 绘制饼图并添加标签和百分比</span>plt<span class="token punctuation">.</span>pie<span class="token punctuation">(</span>sizes<span class="token punctuation">,</span> labels<span class="token operator">=</span>labels<span class="token punctuation">,</span> colors<span class="token operator">=</span>colors<span class="token punctuation">,</span> autopct<span class="token operator">=</span><span class="token string">'%1.1f%%'</span><span class="token punctuation">,</span> startangle<span class="token operator">=</span><span class="token number">90</span><span class="token punctuation">,</span> pctdistance<span class="token operator">=</span><span class="token number">0.85</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 添加标题</span>plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token string">'带标签和百分比的饼图'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 显示图表</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><ul><li><code>autopct=&#39;%1.1f%%&#39;</code>：通过<code>autopct</code>参数，我们在饼图中显示百分比。</li><li><code>pctdistance=0.85</code>：通过<code>pctdistance</code>参数，我们调整了百分比标签的位置。</li></ul><h1 id="9-坐标系"><a href="#9-坐标系" class="headerlink" title="9.坐标系"></a>9.坐标系</h1><h2 id="轴范围和刻度设置"><a href="#轴范围和刻度设置" class="headerlink" title="轴范围和刻度设置"></a>轴范围和刻度设置</h2><p>可以使用<code>plt.xlim()</code>和<code>plt.ylim()</code>函数设置X轴和Y轴的范围，并使用<code>plt.xticks()</code>和<code>plt.yticks()</code>函数设置刻度。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token comment" spellcheck="true"># 创建示例数据</span>x <span class="token operator">=</span> np<span class="token punctuation">.</span>linspace<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span>y <span class="token operator">=</span> np<span class="token punctuation">.</span>sin<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 绘制图表</span>plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> label<span class="token operator">=</span><span class="token string">'sin(x)'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 设置X轴和Y轴范围</span>plt<span class="token punctuation">.</span>xlim<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>ylim<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 设置X轴和Y轴刻度</span>plt<span class="token punctuation">.</span>xticks<span class="token punctuation">(</span>np<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>yticks<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 添加标题</span>plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token string">'坐标系范围和刻度设置'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 显示图例</span>plt<span class="token punctuation">.</span>legend<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 显示图表</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><ul><li><code>plt.xlim(0, 10)</code>：通过<code>plt.xlim()</code>函数，我们设置了X轴范围为0到10。</li><li><code>plt.ylim(-1, 1)</code>：通过<code>plt.ylim()</code>函数，我们设置了Y轴范围为-1到1。</li><li><code>plt.xticks(np.arange(0, 11, 2))</code>：通过<code>plt.xticks()</code>函数，我们设置了X轴的刻度为0到10，步长为2。</li><li><code>plt.yticks([-1, -0.5, 0, 0.5, 1])</code>：通过<code>plt.yticks()</code>函数，我们设置了Y轴的刻度为指定的值。</li></ul><h2 id="轴标签和标题"><a href="#轴标签和标题" class="headerlink" title="轴标签和标题"></a>轴标签和标题</h2><p>可以使用<code>plt.xlabel()</code>和<code>plt.ylabel()</code>函数设置X轴和Y轴的标签，使用<code>plt.title()</code>函数设置标题。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token comment" spellcheck="true"># 创建示例数据</span>x <span class="token operator">=</span> np<span class="token punctuation">.</span>linspace<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span>y <span class="token operator">=</span> np<span class="token punctuation">.</span>sin<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 绘制图表</span>plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> label<span class="token operator">=</span><span class="token string">'sin(x)'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 设置X轴和Y轴标签</span>plt<span class="token punctuation">.</span>xlabel<span class="token punctuation">(</span><span class="token string">'X轴'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>ylabel<span class="token punctuation">(</span><span class="token string">'Y轴'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 添加标题</span>plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token string">'坐标系标签和标题设置'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 显示图例</span>plt<span class="token punctuation">.</span>legend<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 显示图表</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><ul><li><code>plt.xlabel(&#39;X轴&#39;)</code>：通过<code>plt.xlabel()</code>函数，我们设置了X轴的标签。</li><li><code>plt.ylabel(&#39;Y轴&#39;)</code>：通过<code>plt.ylabel()</code>函数，我们设置了Y轴的标签。</li><li><code>plt.title(&#39;坐标系标签和标题设置&#39;)</code>：通过<code>plt.title()</code>函数，我们设置了图表的标题。</li></ul><h2 id="网格线设置"><a href="#网格线设置" class="headerlink" title="网格线设置"></a>网格线设置</h2><p>可以使用<code>plt.grid()</code>函数来设置网格线的显示和样式。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token comment" spellcheck="true"># 创建示例数据</span>x <span class="token operator">=</span> np<span class="token punctuation">.</span>linspace<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span>y <span class="token operator">=</span> np<span class="token punctuation">.</span>sin<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 绘制图表</span>plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> label<span class="token operator">=</span><span class="token string">'sin(x)'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 启用网格线</span>plt<span class="token punctuation">.</span>grid<span class="token punctuation">(</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 添加标题</span>plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token string">'网格线设置'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 显示图例</span>plt<span class="token punctuation">.</span>legend<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 显示图表</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><ul><li><code>plt.grid(True)</code>：通过<code>plt.grid()</code>函数，我们启用了网格线。</li></ul><h1 id="10-图形布局"><a href="#10-图形布局" class="headerlink" title="10.图形布局"></a>10.图形布局</h1><h2 id="子图分割和排列"><a href="#子图分割和排列" class="headerlink" title="子图分割和排列"></a>子图分割和排列</h2><p>使用<code>plt.subplot()</code>函数来创建和排列子图。此函数的参数包括行数、列数和子图的索引。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token comment" spellcheck="true"># 创建一个2x2的子图布局，选择第一个子图</span>plt<span class="token punctuation">.</span>subplot<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token string">'子图1'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 选择第二个子图</span>plt<span class="token punctuation">.</span>subplot<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token string">'子图2'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 选择第三个子图</span>plt<span class="token punctuation">.</span>subplot<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token string">'子图3'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 选择第四个子图</span>plt<span class="token punctuation">.</span>subplot<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token string">'子图4'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 调整子图间距</span>plt<span class="token punctuation">.</span>tight_layout<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 显示图表</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>在这个示例中，创建了一个2x2的子图布局，并在每个子图中绘制了不同的数据。<code>plt.subplot()</code>函数用于选择要绘制的子图，使用<code>plt.title()</code>函数为每个子图添加标题。plt.tight_layout()用于自动调整子图的间距，以确保它们适合图表。</p><h2 id="坐标系网格布局"><a href="#坐标系网格布局" class="headerlink" title="坐标系网格布局"></a>坐标系网格布局</h2><p>Matplotlib还允许在单个图形中创建多个坐标系，以更复杂的方式排列它们。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token comment" spellcheck="true"># 创建一个包含2x2坐标系的图形</span>fig<span class="token punctuation">,</span> axes <span class="token operator">=</span> plt<span class="token punctuation">.</span>subplots<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 在每个坐标系中绘制数据</span>axes<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>plot<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span>axes<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>set_title<span class="token punctuation">(</span><span class="token string">'坐标系1'</span><span class="token punctuation">)</span>axes<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>plot<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>axes<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>set_title<span class="token punctuation">(</span><span class="token string">'坐标系2'</span><span class="token punctuation">)</span>axes<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>plot<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>axes<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>set_title<span class="token punctuation">(</span><span class="token string">'坐标系3'</span><span class="token punctuation">)</span>axes<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>plot<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>axes<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>set_title<span class="token punctuation">(</span><span class="token string">'坐标系4'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 调整子图间距</span>plt<span class="token punctuation">.</span>tight_layout<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 显示图表</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>在这个示例中，使用<code>plt.subplots()</code>创建了一个包含2x2坐标系的图形，然后在每个坐标系中绘制了不同的数据。最后，<code>plt.tight_layout()</code>用于自动调整坐标系之间的间距。</p><h1 id="11-多轴图绘制"><a href="#11-多轴图绘制" class="headerlink" title="11.多轴图绘制"></a>11.多轴图绘制</h1><h2 id="共享轴和独立轴"><a href="#共享轴和独立轴" class="headerlink" title="共享轴和独立轴"></a>共享轴和独立轴</h2><p>使用<code>plt.subplots()</code>函数创建具有共享或独立轴的多轴图。</p><h3 id="共享轴"><a href="#共享轴" class="headerlink" title="共享轴"></a>共享轴</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token comment" spellcheck="true"># 创建一个具有共享X轴的多轴图</span>fig<span class="token punctuation">,</span> axes <span class="token operator">=</span> plt<span class="token punctuation">.</span>subplots<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> sharex<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 绘制数据到不同子图</span>x <span class="token operator">=</span> np<span class="token punctuation">.</span>linspace<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span>y1 <span class="token operator">=</span> np<span class="token punctuation">.</span>sin<span class="token punctuation">(</span>x<span class="token punctuation">)</span>y2 <span class="token operator">=</span> np<span class="token punctuation">.</span>cos<span class="token punctuation">(</span>x<span class="token punctuation">)</span>axes<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>plot<span class="token punctuation">(</span>x<span class="token punctuation">,</span> y1<span class="token punctuation">)</span>axes<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>set_title<span class="token punctuation">(</span><span class="token string">'共享X轴的子图1'</span><span class="token punctuation">)</span>axes<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>plot<span class="token punctuation">(</span>x<span class="token punctuation">,</span> y2<span class="token punctuation">)</span>axes<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>set_title<span class="token punctuation">(</span><span class="token string">'共享X轴的子图2'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 显示图表</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>在这个示例中，创建了一个具有共享X轴的多轴图，两个子图共享相同的X轴。</p><h3 id="独立轴"><a href="#独立轴" class="headerlink" title="独立轴"></a>独立轴</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token comment" spellcheck="true"># 创建具有独立轴的多轴图</span>fig<span class="token punctuation">,</span> axes <span class="token operator">=</span> plt<span class="token punctuation">.</span>subplots<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> sharey<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 绘制数据到不同子图</span>data1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span>data2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span>axes<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>plot<span class="token punctuation">(</span>data1<span class="token punctuation">)</span>axes<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>set_title<span class="token punctuation">(</span><span class="token string">'独立Y轴的子图1'</span><span class="token punctuation">)</span>axes<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>plot<span class="token punctuation">(</span>data2<span class="token punctuation">)</span>axes<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>set_title<span class="token punctuation">(</span><span class="token string">'独立Y轴的子图2'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 显示图表</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>在这个示例中，创建了一个具有独立Y轴的多轴图，两个子图具有不同的Y轴。</p><h2 id="双坐标系图和次坐标轴"><a href="#双坐标系图和次坐标轴" class="headerlink" title="双坐标系图和次坐标轴"></a>双坐标系图和次坐标轴</h2><p>使用<code>twinx()</code>函数创建双坐标系图，允许在同一图中绘制具有不同Y轴的数据。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token comment" spellcheck="true"># 创建双坐标系图</span>fig<span class="token punctuation">,</span> ax1 <span class="token operator">=</span> plt<span class="token punctuation">.</span>subplots<span class="token punctuation">(</span><span class="token punctuation">)</span>data1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span>data2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 绘制第一个数据集</span>ax1<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>data1<span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token string">'skyblue'</span><span class="token punctuation">,</span> label<span class="token operator">=</span><span class="token string">'数据集1'</span><span class="token punctuation">)</span>ax1<span class="token punctuation">.</span>set_xlabel<span class="token punctuation">(</span><span class="token string">'X轴'</span><span class="token punctuation">)</span>ax1<span class="token punctuation">.</span>set_ylabel<span class="token punctuation">(</span><span class="token string">'Y轴1'</span><span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token string">'skyblue'</span><span class="token punctuation">)</span>ax1<span class="token punctuation">.</span>legend<span class="token punctuation">(</span>loc<span class="token operator">=</span><span class="token string">'upper left'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 创建第二个Y轴</span>ax2 <span class="token operator">=</span> ax1<span class="token punctuation">.</span>twinx<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 绘制第二个数据集</span>ax2<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>data2<span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token string">'salmon'</span><span class="token punctuation">,</span> label<span class="token operator">=</span><span class="token string">'数据集2'</span><span class="token punctuation">)</span>ax2<span class="token punctuation">.</span>set_ylabel<span class="token punctuation">(</span><span class="token string">'Y轴2'</span><span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token string">'salmon'</span><span class="token punctuation">)</span>ax2<span class="token punctuation">.</span>legend<span class="token punctuation">(</span>loc<span class="token operator">=</span><span class="token string">'upper right'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 添加标题</span>plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token string">'双坐标系图'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 显示图表</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>在这个示例中，创建了一个双坐标系图，同时绘制了两个数据集，每个数据集具有不同的Y轴。使用<code>ax1.twinx()</code>来创建第二个Y轴，并在同一图中绘制两个数据集。</p><h2 id="次坐标轴"><a href="#次坐标轴" class="headerlink" title="次坐标轴"></a>次坐标轴</h2><p>使用<code>secondary_xaxis()</code>和<code>secondary_yaxis()</code>函数来创建次坐标轴，以表示不同尺度的数据。这通常用于在同一图中显示不同单位的数据。</p><h1 id="12-高级图形元素"><a href="#12-高级图形元素" class="headerlink" title="12.高级图形元素"></a>12.高级图形元素</h1><h2 id="图形注释和箭头"><a href="#图形注释和箭头" class="headerlink" title="图形注释和箭头"></a>图形注释和箭头</h2><p>使用<code>plt.annotate()</code>函数添加图形注释和箭头。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token comment" spellcheck="true"># 创建示例数据</span>x <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>y <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 绘制数据</span>plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 添加图形注释和箭头</span>plt<span class="token punctuation">.</span>annotate<span class="token punctuation">(</span><span class="token string">'重要点'</span><span class="token punctuation">,</span> xy<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span> xytext<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">2.5</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span>             arrowprops<span class="token operator">=</span>dict<span class="token punctuation">(</span>arrowstyle<span class="token operator">=</span><span class="token string">'->'</span><span class="token punctuation">,</span> lw<span class="token operator">=</span><span class="token number">1.5</span><span class="token punctuation">)</span><span class="token punctuation">,</span>             fontsize<span class="token operator">=</span><span class="token number">12</span><span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token string">'red'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 显示图表</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>在这个示例中，我们使用<code>plt.annotate()</code>函数在数据点 <code>(2, 4)</code> 处添加了一个注释文本，并使用箭头指向 <code>(2.5, 5)</code> 处。</p><h2 id="图例高级用法"><a href="#图例高级用法" class="headerlink" title="图例高级用法"></a>图例高级用法</h2><p>Matplotlib的图例允许自定义图例的位置、标签、颜色等属性。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token comment" spellcheck="true"># 创建示例数据</span>x <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>y1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span>y2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 绘制数据</span>plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>x<span class="token punctuation">,</span> y1<span class="token punctuation">,</span> label<span class="token operator">=</span><span class="token string">'数据集1'</span><span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token string">'skyblue'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>x<span class="token punctuation">,</span> y2<span class="token punctuation">,</span> label<span class="token operator">=</span><span class="token string">'数据集2'</span><span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token string">'salmon'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 自定义图例</span>plt<span class="token punctuation">.</span>legend<span class="token punctuation">(</span>loc<span class="token operator">=</span><span class="token string">'upper left'</span><span class="token punctuation">,</span> title<span class="token operator">=</span><span class="token string">'数据集'</span><span class="token punctuation">,</span> title_fontsize<span class="token operator">=</span><span class="token number">12</span><span class="token punctuation">,</span> fontsize<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 显示图表</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>在这个示例中，使用<code>plt.legend()</code>函数自定义了图例的位置、标题、标题字体大小和图例项的字体大小。</p><h2 id="区域填充和阴影效果"><a href="#区域填充和阴影效果" class="headerlink" title="区域填充和阴影效果"></a>区域填充和阴影效果</h2><p>使用<code>fill_between()</code>函数来填充区域和创建阴影效果。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token comment" spellcheck="true"># 创建示例数据</span>x <span class="token operator">=</span> np<span class="token punctuation">.</span>linspace<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span>y1 <span class="token operator">=</span> np<span class="token punctuation">.</span>sin<span class="token punctuation">(</span>x<span class="token punctuation">)</span>y2 <span class="token operator">=</span> np<span class="token punctuation">.</span>cos<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 绘制数据</span>plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>x<span class="token punctuation">,</span> y1<span class="token punctuation">,</span> label<span class="token operator">=</span><span class="token string">'sin(x)'</span><span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token string">'skyblue'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>x<span class="token punctuation">,</span> y2<span class="token punctuation">,</span> label<span class="token operator">=</span><span class="token string">'cos(x)'</span><span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token string">'salmon'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 填充区域</span>plt<span class="token punctuation">.</span>fill_between<span class="token punctuation">(</span>x<span class="token punctuation">,</span> y1<span class="token punctuation">,</span> y2<span class="token punctuation">,</span> where<span class="token operator">=</span><span class="token punctuation">(</span>y1 <span class="token operator">></span> y2<span class="token punctuation">)</span><span class="token punctuation">,</span> interpolate<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token string">'lightgray'</span><span class="token punctuation">,</span> alpha<span class="token operator">=</span><span class="token number">0.5</span><span class="token punctuation">,</span> label<span class="token operator">=</span><span class="token string">'sin(x) > cos(x)'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 自定义图例</span>plt<span class="token punctuation">.</span>legend<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 显示图表</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>在这个示例中，使用<code>plt.fill_between()</code>函数填充了两个数据集之间 <code>sin(x) &gt; cos(x)</code> 的区域，并为填充区域添加了颜色和透明度。添加了图例以标识填充区域。</p><h1 id="13-3D数据可视化"><a href="#13-3D数据可视化" class="headerlink" title="13.3D数据可视化"></a>13.3D数据可视化</h1><h2 id="三维散点图和曲面图"><a href="#三维散点图和曲面图" class="headerlink" title="三维散点图和曲面图"></a>三维散点图和曲面图</h2><p>使用<code>Axes3D</code>子模块来创建三维散点图和曲面图。</p><h3 id="三维散点图"><a href="#三维散点图" class="headerlink" title="三维散点图"></a>三维散点图</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token keyword">from</span> mpl_toolkits<span class="token punctuation">.</span>mplot3d <span class="token keyword">import</span> Axes3D<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token comment" spellcheck="true"># 创建示例数据</span>x <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>rand<span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span>y <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>rand<span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span>z <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>rand<span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 创建三维散点图</span>fig <span class="token operator">=</span> plt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span><span class="token punctuation">)</span>ax <span class="token operator">=</span> fig<span class="token punctuation">.</span>add_subplot<span class="token punctuation">(</span><span class="token number">111</span><span class="token punctuation">,</span> projection<span class="token operator">=</span><span class="token string">'3d'</span><span class="token punctuation">)</span>ax<span class="token punctuation">.</span>scatter<span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z<span class="token punctuation">,</span> c<span class="token operator">=</span><span class="token string">'b'</span><span class="token punctuation">,</span> marker<span class="token operator">=</span><span class="token string">'o'</span><span class="token punctuation">,</span> label<span class="token operator">=</span><span class="token string">'随机数据'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 添加标签</span>ax<span class="token punctuation">.</span>set_xlabel<span class="token punctuation">(</span><span class="token string">'X轴'</span><span class="token punctuation">)</span>ax<span class="token punctuation">.</span>set_ylabel<span class="token punctuation">(</span><span class="token string">'Y轴'</span><span class="token punctuation">)</span>ax<span class="token punctuation">.</span>set_zlabel<span class="token punctuation">(</span><span class="token string">'Z轴'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 添加图例</span>ax<span class="token punctuation">.</span>legend<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 显示图表</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>在这个示例中，使用<code>Axes3D</code>子模块创建了一个三维散点图，其中 <code>x</code>、<code>y</code> 和 <code>z</code> 是随机生成的数据。</p><h3 id="三维曲面图"><a href="#三维曲面图" class="headerlink" title="三维曲面图"></a>三维曲面图</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token keyword">from</span> mpl_toolkits<span class="token punctuation">.</span>mplot3d <span class="token keyword">import</span> Axes3D<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token comment" spellcheck="true"># 创建示例数据</span>x <span class="token operator">=</span> np<span class="token punctuation">.</span>linspace<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span>y <span class="token operator">=</span> np<span class="token punctuation">.</span>linspace<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span>x<span class="token punctuation">,</span> y <span class="token operator">=</span> np<span class="token punctuation">.</span>meshgrid<span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span>z <span class="token operator">=</span> np<span class="token punctuation">.</span>sin<span class="token punctuation">(</span>np<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span>x<span class="token operator">**</span><span class="token number">2</span> <span class="token operator">+</span> y<span class="token operator">**</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 创建三维曲面图</span>fig <span class="token operator">=</span> plt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span><span class="token punctuation">)</span>ax <span class="token operator">=</span> fig<span class="token punctuation">.</span>add_subplot<span class="token punctuation">(</span><span class="token number">111</span><span class="token punctuation">,</span> projection<span class="token operator">=</span><span class="token string">'3d'</span><span class="token punctuation">)</span>ax<span class="token punctuation">.</span>plot_surface<span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z<span class="token punctuation">,</span> cmap<span class="token operator">=</span><span class="token string">'viridis'</span><span class="token punctuation">,</span> label<span class="token operator">=</span><span class="token string">'三维曲面'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 添加标签</span>ax<span class="token punctuation">.</span>set_xlabel<span class="token punctuation">(</span><span class="token string">'X轴'</span><span class="token punctuation">)</span>ax<span class="token punctuation">.</span>set_ylabel<span class="token punctuation">(</span><span class="token string">'Y轴'</span><span class="token punctuation">)</span>ax<span class="token punctuation">.</span>set_zlabel<span class="token punctuation">(</span><span class="token string">'Z轴'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 添加图例</span>ax<span class="token punctuation">.</span>legend<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 显示图表</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>在这个示例中，用<code>Axes3D</code>子模块创建了一个三维曲面图，其中 <code>x</code> 和 <code>y</code> 是网格化的坐标，<code>z</code> 是一个函数的值。</p><h2 id="等高线图和热力图"><a href="#等高线图和热力图" class="headerlink" title="等高线图和热力图"></a>等高线图和热力图</h2><p>Matplotlib允许创建三维等高线图和热力图，用于可视化等高线和数据热力分布。</p><h3 id="三维等高线图"><a href="#三维等高线图" class="headerlink" title="三维等高线图"></a>三维等高线图</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token keyword">from</span> mpl_toolkits<span class="token punctuation">.</span>mplot3d <span class="token keyword">import</span> Axes3D<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token comment" spellcheck="true"># 创建示例数据</span>x <span class="token operator">=</span> np<span class="token punctuation">.</span>linspace<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span>y <span class="token operator">=</span> np<span class="token punctuation">.</span>linspace<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span>x<span class="token punctuation">,</span> y <span class="token operator">=</span> np<span class="token punctuation">.</span>meshgrid<span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span>z <span class="token operator">=</span> np<span class="token punctuation">.</span>sin<span class="token punctuation">(</span>np<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span>x<span class="token operator">**</span><span class="token number">2</span> <span class="token operator">+</span> y<span class="token operator">**</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 创建三维等高线图</span>fig <span class="token operator">=</span> plt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span><span class="token punctuation">)</span>ax <span class="token operator">=</span> fig<span class="token punctuation">.</span>add_subplot<span class="token punctuation">(</span><span class="token number">111</span><span class="token punctuation">,</span> projection<span class="token operator">=</span><span class="token string">'3d'</span><span class="token punctuation">)</span>ax<span class="token punctuation">.</span>contour<span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z<span class="token punctuation">,</span> cmap<span class="token operator">=</span><span class="token string">'viridis'</span><span class="token punctuation">,</span> levels<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 添加标签</span>ax<span class="token punctuation">.</span>set_xlabel<span class="token punctuation">(</span><span class="token string">'X轴'</span><span class="token punctuation">)</span>ax<span class="token punctuation">.</span>set_ylabel<span class="token punctuation">(</span><span class="token string">'Y轴'</span><span class="token punctuation">)</span>ax<span class="token punctuation">.</span>set_zlabel<span class="token punctuation">(</span><span class="token string">'Z轴'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 显示图表</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>在这个示例中，用<code>Axes3D</code>子模块创建了一个三维等高线图。</p><h3 id="热力图"><a href="#热力图" class="headerlink" title="热力图"></a>热力图</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token comment" spellcheck="true"># 创建示例数据</span>data <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>rand<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 创建热力图</span>plt<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span>data<span class="token punctuation">,</span> cmap<span class="token operator">=</span><span class="token string">'coolwarm'</span><span class="token punctuation">,</span> interpolation<span class="token operator">=</span><span class="token string">'nearest'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>colorbar<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 显示图表</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>这个示例演示了如何创建热力图，其中 <code>data</code> 是一个矩阵。</p><h2 id="3D-动画和交互式控件"><a href="#3D-动画和交互式控件" class="headerlink" title="3D 动画和交互式控件"></a>3D 动画和交互式控件</h2><p>Matplotlib还支持3D动画和交互式控件，允许你创建交互式的三维图形。</p><h1 id="14-图形导出和美化"><a href="#14-图形导出和美化" class="headerlink" title="14.图形导出和美化"></a>14.图形导出和美化</h1><h2 id="导出图形文件"><a href="#导出图形文件" class="headerlink" title="导出图形文件"></a>导出图形文件</h2><p>使用Matplotlib将图形保存为各种文件格式，如PNG、JPG、SVG、PDF等。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token comment" spellcheck="true"># 创建示例数据</span>x <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span>y <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 绘制数据</span>plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> label<span class="token operator">=</span><span class="token string">'数据集'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 自定义图形</span>plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token string">'导出图形文件示例'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>xlabel<span class="token punctuation">(</span><span class="token string">'X轴'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>ylabel<span class="token punctuation">(</span><span class="token string">'Y轴'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>legend<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 保存图形为PNG文件</span>plt<span class="token punctuation">.</span>savefig<span class="token punctuation">(</span><span class="token string">'sample_plot.png'</span><span class="token punctuation">,</span> dpi<span class="token operator">=</span><span class="token number">300</span><span class="token punctuation">,</span> bbox_inches<span class="token operator">=</span><span class="token string">'tight'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 保存图形为PDF文件</span>plt<span class="token punctuation">.</span>savefig<span class="token punctuation">(</span><span class="token string">'sample_plot.pdf'</span><span class="token punctuation">,</span> bbox_inches<span class="token operator">=</span><span class="token string">'tight'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 显示图表</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>在这个示例中，用<code>plt.savefig()</code>函数将图形保存为PNG和PDF文件，可以使用不同的文件扩展名来指定不同的文件格式。</p><h2 id="图形风格设置"><a href="#图形风格设置" class="headerlink" title="图形风格设置"></a>图形风格设置</h2><p>Matplotlib允许设置图形的风格，包括背景、网格线、字体和刻度等。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token comment" spellcheck="true"># 设置图形风格</span>plt<span class="token punctuation">.</span>style<span class="token punctuation">.</span>use<span class="token punctuation">(</span><span class="token string">'seaborn-darkgrid'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 创建示例数据</span>x <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span>y <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 绘制数据</span>plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> label<span class="token operator">=</span><span class="token string">'数据集'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 自定义图形</span>plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token string">'图形风格设置示例'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>xlabel<span class="token punctuation">(</span><span class="token string">'X轴'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>ylabel<span class="token punctuation">(</span><span class="token string">'Y轴'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>legend<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 显示图表</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>在这个示例中，用<code>plt.style.use()</code>函数设置了图形的风格为<code>seaborn-darkgrid</code>，选择不同的风格来自定义图形外观。</p><h2 id="自定义色彩和配色方案"><a href="#自定义色彩和配色方案" class="headerlink" title="自定义色彩和配色方案"></a>自定义色彩和配色方案</h2><p>自定义色彩和配色方案，以满足特定的需求。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token comment" spellcheck="true"># 自定义色彩和配色方案</span>colors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'red'</span><span class="token punctuation">,</span> <span class="token string">'green'</span><span class="token punctuation">,</span> <span class="token string">'blue'</span><span class="token punctuation">,</span> <span class="token string">'orange'</span><span class="token punctuation">,</span> <span class="token string">'purple'</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 创建示例数据</span>x <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span>y <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 绘制数据，使用自定义色彩</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>x<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> y<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> label<span class="token operator">=</span>f<span class="token string">'数据点 {i+1}'</span><span class="token punctuation">,</span> color<span class="token operator">=</span>colors<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 自定义图形</span>plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token string">'自定义色彩和配色方案示例'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>xlabel<span class="token punctuation">(</span><span class="token string">'X轴'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>ylabel<span class="token punctuation">(</span><span class="token string">'Y轴'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>legend<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 显示图表</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>在这个示例中，自定义的颜色列表<code>colors</code>来为每个数据点选择不同的颜色。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>matplotlib官网：<a href="https://matplotlib.org/stable/users/index" target="_blank" rel="noopener">https://matplotlib.org/stable/users/index</a> </p>]]></content>
      
      
      <categories>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据分析 </tag>
            
            <tag> python </tag>
            
            <tag> matplotlib </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python数据分析-pandas</title>
      <link href="/shu-fen-pandas.html"/>
      <url>/shu-fen-pandas.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>数据分析是当今世界中日益重要的技能之一。随着大量数据的产生和积累，数据分析能力已成为了解、预测和解决各种问题的关键工具。无论你是一名数据分析师，一名学生，还是一个对数据分析感兴趣的人，了解如何使用Python和Pandas进行数据分析都将帮助你更好地理解和利用数据。</p><p>本文旨在向你介绍Python数据分析的基本概念和技术，重点介绍了Pandas库，这是Python中最受欢迎的数据分析工具之一。从Pandas的基本数据结构和操作开始，逐步深入到数据清洗、数据变形、数据分析和可视化等方面。</p><h1 id="一、Pandas基础"><a href="#一、Pandas基础" class="headerlink" title="一、Pandas基础"></a>一、Pandas基础</h1><h2 id="1-1-介绍Pandas"><a href="#1-1-介绍Pandas" class="headerlink" title="1.1 介绍Pandas"></a>1.1 介绍Pandas</h2><h3 id="什么是Pandas？"><a href="#什么是Pandas？" class="headerlink" title="什么是Pandas？"></a>什么是Pandas？</h3><p>Pandas（Panel Data的缩写）是一个流行的开源Python库，用于数据分析和处理。它提供了强大的数据结构和数据分析工具，使数据科学家、分析师和开发人员能够更轻松地处理和分析结构化数据。</p><p>Pandas主要引入了两种主要的数据结构：</p><ol><li><p><strong>Series：</strong> Series是一维数据结构，类似于数组或列表，但具有数据标签，可以存储不同数据类型。Series是Pandas操作的基本单位。</p><p>示例：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> pandas <span class="token keyword">as</span> pddata <span class="token operator">=</span> pd<span class="token punctuation">.</span>Series<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre></li><li><p><strong>DataFrame：</strong> DataFrame是一个二维表格，由多个Series构成。它类似于电子表格或SQL表，可轻松处理和分析大量数据。DataFrame是Pandas的核心数据结构。</p><p>示例：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> pandas <span class="token keyword">as</span> pddata <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'Name'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'Alice'</span><span class="token punctuation">,</span> <span class="token string">'Bob'</span><span class="token punctuation">,</span> <span class="token string">'Charlie'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token string">'Age'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">25</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">35</span><span class="token punctuation">]</span><span class="token punctuation">}</span>df <span class="token operator">=</span> pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span>data<span class="token punctuation">)</span></code></pre></li></ol><p>Pandas的功能远不止于此，它包含了许多数据操作、清洗、合并、分组、聚合、绘图等功能，使数据处理和分析变得更加高效。</p><h3 id="为什么要使用Pandas？"><a href="#为什么要使用Pandas？" class="headerlink" title="为什么要使用Pandas？"></a>为什么要使用Pandas？</h3><p>Pandas具有以下优点，使其成为数据分析的首选工具之一：</p><ul><li><p><strong>数据清洗和处理：</strong> Pandas提供了丰富的功能，可轻松处理缺失值、重复值、数据类型转换等数据清洗任务。</p></li><li><p><strong>数据索引和选择：</strong> 你可以使用标签或位置来快速选择和操作数据，使数据提取更加灵活。</p></li><li><p><strong>数据聚合和转换：</strong> Pandas支持强大的数据分组和聚合操作，能够进行高级数据转换和透视。</p></li><li><p><strong>数据可视化：</strong> Pandas可以与Matplotlib等库结合使用，帮助你创建各种数据可视化图表。</p></li><li><p><strong>与其他工具集成：</strong> Pandas可以轻松与其他Python库（如NumPy、Matplotlib、Scikit-Learn等）结合使用，构建完整的数据科学工作流。</p></li></ul><h3 id="安装Pandas"><a href="#安装Pandas" class="headerlink" title="安装Pandas"></a>安装Pandas</h3><p>要安装Pandas，可以使用Python包管理工具（pip或conda）。首先，确保Python环境已经安装了这些工具。</p><p>使用pip安装Pandas的命令如下：</p><pre class=" language-bash"><code class="language-bash">pip <span class="token function">install</span> pandas</code></pre><p>使用conda安装Pandas的命令如下：</p><pre class=" language-bash"><code class="language-bash">conda <span class="token function">install</span> pandas</code></pre><p>安装完成后，可以开始使用Pandas来进行数据分析了。</p><p>好，我们继续填充第一部分的内容：<strong>1.2 数据结构</strong>。</p><h2 id="1-2-数据结构"><a href="#1-2-数据结构" class="headerlink" title="1.2 数据结构"></a>1.2 数据结构</h2><h3 id="一维数据结构：series"><a href="#一维数据结构：series" class="headerlink" title="一维数据结构：series"></a>一维数据结构：series</h3><p><strong>Series</strong>是Pandas中的一维数据结构，它类似于一维数组或列表，但有一些额外的功能。Series由两个主要部分组成：<strong>数据值和索引标签</strong>。索引标签使我们可以对数据进行更有意义的标识和检索。</p><h3 id="创建Series"><a href="#创建Series" class="headerlink" title="创建Series"></a>创建Series</h3><p>要创建一个Series，使用<code>pd.Series()</code>构造函数，并将数据传递给它。下面是一个简单的示例：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> pandas <span class="token keyword">as</span> pddata <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">]</span>series <span class="token operator">=</span> pd<span class="token punctuation">.</span>Series<span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>series<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 输出</span><span class="token number">0</span>    <span class="token number">10</span><span class="token number">1</span>    <span class="token number">20</span><span class="token number">2</span>    <span class="token number">30</span><span class="token number">3</span>    <span class="token number">40</span>dtype<span class="token punctuation">:</span> int64</code></pre><h3 id="二维数据结构：DataFrame"><a href="#二维数据结构：DataFrame" class="headerlink" title="二维数据结构：DataFrame"></a>二维数据结构：DataFrame</h3><p><strong>DataFrame</strong>是Pandas的核心数据结构，它类似于一个二维表格或SQL表。DataFrame是由多个Series对象组成，每个Series对应表格中的一列。它具有行和列的标签，可以轻松地处理和分析复杂的数据。</p><h3 id="创建DataFrame"><a href="#创建DataFrame" class="headerlink" title="创建DataFrame"></a>创建DataFrame</h3><p>要创建一个DataFrame，使用<code>pd.DataFrame()</code>构造函数，并传递一个包含数据的字典。每个键值对表示DataFrame的一列，键是列名，值是列的数据。</p><p>下面是一个示例：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> pandas <span class="token keyword">as</span> pddata <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'Name'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'Alice'</span><span class="token punctuation">,</span> <span class="token string">'Bob'</span><span class="token punctuation">,</span> <span class="token string">'Charlie'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token string">'Age'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">25</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">35</span><span class="token punctuation">]</span><span class="token punctuation">}</span>df <span class="token operator">=</span> pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>df<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 输出</span>      Name  Age<span class="token number">0</span>    Alice   <span class="token number">25</span><span class="token number">1</span>      Bob   <span class="token number">30</span><span class="token number">2</span>  Charlie   <span class="token number">35</span></code></pre><p>继续填充第一部分的内容：<strong>1.3 基本操作</strong>。</p><h2 id="1-3-基本操作"><a href="#1-3-基本操作" class="headerlink" title="1.3 基本操作"></a>1.3 基本操作</h2><h3 id="数据索引和选择"><a href="#数据索引和选择" class="headerlink" title="数据索引和选择"></a>数据索引和选择</h3><p>在Pandas中，<strong>使用索引来访问和选择数据</strong>。<strong>索引可以是整数位置（位置索引）或标签（标签索引）</strong>。以下是一些基本的数据索引和选择操作：</p><h4 id="使用位置索引："><a href="#使用位置索引：" class="headerlink" title="使用位置索引："></a>使用位置索引：</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> pandas <span class="token keyword">as</span> pddata <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">]</span>series <span class="token operator">=</span> pd<span class="token punctuation">.</span>Series<span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 使用位置索引选择第一个元素</span>element <span class="token operator">=</span> series<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span></code></pre><h4 id="使用标签索引："><a href="#使用标签索引：" class="headerlink" title="使用标签索引："></a>使用标签索引：</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> pandas <span class="token keyword">as</span> pddata <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">]</span>index_labels <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token string">'B'</span><span class="token punctuation">,</span> <span class="token string">'C'</span><span class="token punctuation">,</span> <span class="token string">'D'</span><span class="token punctuation">]</span>series <span class="token operator">=</span> pd<span class="token punctuation">.</span>Series<span class="token punctuation">(</span>data<span class="token punctuation">,</span> index<span class="token operator">=</span>index_labels<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 使用标签索引选择元素</span>element <span class="token operator">=</span> series<span class="token punctuation">[</span><span class="token string">'B'</span><span class="token punctuation">]</span></code></pre><h3 id="数据切片和筛选"><a href="#数据切片和筛选" class="headerlink" title="数据切片和筛选"></a>数据切片和筛选</h3><p>Pandas允许使用切片和布尔条件来筛选数据。</p><h4 id="使用切片："><a href="#使用切片：" class="headerlink" title="使用切片："></a>使用切片：</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> pandas <span class="token keyword">as</span> pddata <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">]</span>index_labels <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token string">'B'</span><span class="token punctuation">,</span> <span class="token string">'C'</span><span class="token punctuation">,</span> <span class="token string">'D'</span><span class="token punctuation">]</span>series <span class="token operator">=</span> pd<span class="token punctuation">.</span>Series<span class="token punctuation">(</span>data<span class="token punctuation">,</span> index<span class="token operator">=</span>index_labels<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 使用切片选择一部分数据</span>subset <span class="token operator">=</span> series<span class="token punctuation">[</span><span class="token string">'B'</span><span class="token punctuation">:</span><span class="token string">'D'</span><span class="token punctuation">]</span></code></pre><h4 id="使用布尔条件："><a href="#使用布尔条件：" class="headerlink" title="使用布尔条件："></a>使用布尔条件：</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> pandas <span class="token keyword">as</span> pddata <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">]</span>index_labels <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token string">'B'</span><span class="token punctuation">,</span> <span class="token string">'C'</span><span class="token punctuation">,</span> <span class="token string">'D'</span><span class="token punctuation">]</span>series <span class="token operator">=</span> pd<span class="token punctuation">.</span>Series<span class="token punctuation">(</span>data<span class="token punctuation">,</span> index<span class="token operator">=</span>index_labels<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 使用布尔条件选择满足条件的数据</span>filtered_data <span class="token operator">=</span> series<span class="token punctuation">[</span>series <span class="token operator">></span> <span class="token number">20</span><span class="token punctuation">]</span></code></pre><h3 id="数据的增删改查"><a href="#数据的增删改查" class="headerlink" title="数据的增删改查"></a>数据的增删改查</h3><p>在Pandas中，对数据进行增加、删除、修改和查询的操作。</p><h4 id="数据的增加："><a href="#数据的增加：" class="headerlink" title="数据的增加："></a>数据的增加：</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> pandas <span class="token keyword">as</span> pddata <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">]</span>index_labels <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token string">'B'</span><span class="token punctuation">,</span> <span class="token string">'C'</span><span class="token punctuation">,</span> <span class="token string">'D'</span><span class="token punctuation">]</span>series <span class="token operator">=</span> pd<span class="token punctuation">.</span>Series<span class="token punctuation">(</span>data<span class="token punctuation">,</span> index<span class="token operator">=</span>index_labels<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 添加新数据</span>series<span class="token punctuation">[</span><span class="token string">'E'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">50</span></code></pre><h4 id="数据的删除："><a href="#数据的删除：" class="headerlink" title="数据的删除："></a>数据的删除：</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> pandas <span class="token keyword">as</span> pddata <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">]</span>index_labels <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token string">'B'</span><span class="token punctuation">,</span> <span class="token string">'C'</span><span class="token punctuation">,</span> <span class="token string">'D'</span><span class="token punctuation">]</span>series <span class="token operator">=</span> pd<span class="token punctuation">.</span>Series<span class="token punctuation">(</span>data<span class="token punctuation">,</span> index<span class="token operator">=</span>index_labels<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 删除数据</span>series <span class="token operator">=</span> series<span class="token punctuation">.</span>drop<span class="token punctuation">(</span><span class="token string">'B'</span><span class="token punctuation">)</span></code></pre><h4 id="数据的修改："><a href="#数据的修改：" class="headerlink" title="数据的修改："></a>数据的修改：</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> pandas <span class="token keyword">as</span> pddata <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">]</span>index_labels <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token string">'B'</span><span class="token punctuation">,</span> <span class="token string">'C'</span><span class="token punctuation">,</span> <span class="token string">'D'</span><span class="token punctuation">]</span>series <span class="token operator">=</span> pd<span class="token punctuation">.</span>Series<span class="token punctuation">(</span>data<span class="token punctuation">,</span> index<span class="token operator">=</span>index_labels<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 修改数据</span>series<span class="token punctuation">[</span><span class="token string">'B'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">25</span></code></pre><h2 id="1-4-数据加载和保存"><a href="#1-4-数据加载和保存" class="headerlink" title="1.4 数据加载和保存"></a>1.4 数据加载和保存</h2><h3 id="从CSV、Excel、SQL数据库等加载数据"><a href="#从CSV、Excel、SQL数据库等加载数据" class="headerlink" title="从CSV、Excel、SQL数据库等加载数据"></a>从CSV、Excel、SQL数据库等加载数据</h3><p>Pandas提供了多种方法来加载不同格式的数据，包括CSV文件、Excel文件、SQL数据库等。以下是一些常见的方法：</p><h4 id="从CSV文件加载数据："><a href="#从CSV文件加载数据：" class="headerlink" title="从CSV文件加载数据："></a>从CSV文件加载数据：</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> pandas <span class="token keyword">as</span> pd<span class="token comment" spellcheck="true"># 从CSV文件加载数据</span>data <span class="token operator">=</span> pd<span class="token punctuation">.</span>read_csv<span class="token punctuation">(</span><span class="token string">'data.csv'</span><span class="token punctuation">)</span></code></pre><h4 id="从Excel文件加载数据："><a href="#从Excel文件加载数据：" class="headerlink" title="从Excel文件加载数据："></a>从Excel文件加载数据：</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> pandas <span class="token keyword">as</span> pd<span class="token comment" spellcheck="true"># 从Excel文件加载数据</span>data <span class="token operator">=</span> pd<span class="token punctuation">.</span>read_excel<span class="token punctuation">(</span><span class="token string">'data.xlsx'</span><span class="token punctuation">,</span> sheet_name<span class="token operator">=</span><span class="token string">'Sheet1'</span><span class="token punctuation">)</span></code></pre><h4 id="从SQL数据库加载数据："><a href="#从SQL数据库加载数据：" class="headerlink" title="从SQL数据库加载数据："></a>从SQL数据库加载数据：</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> pandas <span class="token keyword">as</span> pd<span class="token keyword">from</span> sqlalchemy <span class="token keyword">import</span> create_engine<span class="token comment" spellcheck="true"># 创建数据库连接</span>engine <span class="token operator">=</span> create_engine<span class="token punctuation">(</span><span class="token string">'sqlite:///mydatabase.db'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 从SQL数据库加载数据</span>query <span class="token operator">=</span> <span class="token string">'SELECT * FROM mytable'</span>data <span class="token operator">=</span> pd<span class="token punctuation">.</span>read_sql_query<span class="token punctuation">(</span>query<span class="token punctuation">,</span> engine<span class="token punctuation">)</span></code></pre><h3 id="将数据保存为CSV、Excel、SQL等格式"><a href="#将数据保存为CSV、Excel、SQL等格式" class="headerlink" title="将数据保存为CSV、Excel、SQL等格式"></a>将数据保存为CSV、Excel、SQL等格式</h3><p>可以使用Pandas将数据保存到不同的文件格式中。</p><h4 id="将数据保存为CSV文件："><a href="#将数据保存为CSV文件：" class="headerlink" title="将数据保存为CSV文件："></a>将数据保存为CSV文件：</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> pandas <span class="token keyword">as</span> pddata <span class="token operator">=</span> pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">'A'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">'B'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 将数据保存为CSV文件</span>data<span class="token punctuation">.</span>to_csv<span class="token punctuation">(</span><span class="token string">'mydata.csv'</span><span class="token punctuation">,</span> index<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span></code></pre><h4 id="将数据保存为Excel文件："><a href="#将数据保存为Excel文件：" class="headerlink" title="将数据保存为Excel文件："></a>将数据保存为Excel文件：</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> pandas <span class="token keyword">as</span> pddata <span class="token operator">=</span> pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">'A'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">'B'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 将数据保存为Excel文件</span>data<span class="token punctuation">.</span>to_excel<span class="token punctuation">(</span><span class="token string">'mydata.xlsx'</span><span class="token punctuation">,</span> sheet_name<span class="token operator">=</span><span class="token string">'Sheet1'</span><span class="token punctuation">,</span> index<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span></code></pre><h4 id="将数据保存到SQL数据库："><a href="#将数据保存到SQL数据库：" class="headerlink" title="将数据保存到SQL数据库："></a>将数据保存到SQL数据库：</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> pandas <span class="token keyword">as</span> pd<span class="token keyword">from</span> sqlalchemy <span class="token keyword">import</span> create_enginedata <span class="token operator">=</span> pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">'A'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">'B'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 创建数据库连接</span>engine <span class="token operator">=</span> create_engine<span class="token punctuation">(</span><span class="token string">'sqlite:///mydatabase.db'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 将数据保存到SQL数据库</span>data<span class="token punctuation">.</span>to_sql<span class="token punctuation">(</span><span class="token string">'mytable'</span><span class="token punctuation">,</span> engine<span class="token punctuation">,</span> if_exists<span class="token operator">=</span><span class="token string">'replace'</span><span class="token punctuation">,</span> index<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span></code></pre><p>继续填充第一部分的内容：<strong>1.5 数据基本信息</strong>。</p><h2 id="1-5-数据基本信息"><a href="#1-5-数据基本信息" class="headerlink" title="1.5 数据基本信息"></a>1.5 数据基本信息</h2><h3 id="查看数据的基本信息"><a href="#查看数据的基本信息" class="headerlink" title="查看数据的基本信息"></a>查看数据的基本信息</h3><p>在数据分析中，了解数据的基本信息是非常重要的，可以更好地理解数据集。Pandas提供了几个方法来查看数据的基本信息：</p><h4 id="info-方法查看数据信息："><a href="#info-方法查看数据信息：" class="headerlink" title="info()方法查看数据信息："></a><code>info()</code>方法查看数据信息：</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> pandas <span class="token keyword">as</span> pddata <span class="token operator">=</span> pd<span class="token punctuation">.</span>read_csv<span class="token punctuation">(</span><span class="token string">'data.csv'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 查看数据的基本信息，info()方法会显示数据的行数、列数、每列的非空值数量、数据类型等信息</span>data<span class="token punctuation">.</span>info<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>数据类型和空值处理</p><p>在数据分析过程中，了解数据的数据类型和处理空值是必要的。</p><h4 id="查看数据类型："><a href="#查看数据类型：" class="headerlink" title="查看数据类型："></a>查看数据类型：</h4><p>使用<code>dtypes</code>属性查看每列的数据类型。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> pandas <span class="token keyword">as</span> pddata <span class="token operator">=</span> pd<span class="token punctuation">.</span>read_csv<span class="token punctuation">(</span><span class="token string">'data.csv'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 查看每列的数据类型</span>data_types <span class="token operator">=</span> data<span class="token punctuation">.</span>dtypes</code></pre><h4 id="处理空值："><a href="#处理空值：" class="headerlink" title="处理空值："></a>处理空值：</h4><p>处理空值是数据清洗的一部分，使用<code>dropna()</code>方法删除包含空值的行，或使用<code>fillna()</code>方法填充空值。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> pandas <span class="token keyword">as</span> pddata <span class="token operator">=</span> pd<span class="token punctuation">.</span>read_csv<span class="token punctuation">(</span><span class="token string">'data.csv'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 删除包含空值的行</span>data <span class="token operator">=</span> data<span class="token punctuation">.</span>dropna<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 填充空值为特定值（例如，填充为0）</span>data <span class="token operator">=</span> data<span class="token punctuation">.</span>fillna<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span></code></pre><h1 id="二、数据清洗和准备"><a href="#二、数据清洗和准备" class="headerlink" title="二、数据清洗和准备"></a>二、数据清洗和准备</h1><h2 id="2-1-数据清洗"><a href="#2-1-数据清洗" class="headerlink" title="2.1 数据清洗"></a>2.1 数据清洗</h2><p>数据清洗是数据分析的关键步骤，它包括<strong>处理缺失值、处理重复值以及进行数据类型转换</strong>。</p><h3 id="处理缺失值"><a href="#处理缺失值" class="headerlink" title="处理缺失值"></a>处理缺失值</h3><p>缺失值是数据中的空白或未定义值，它们可以干扰数据分析过程。Pandas提供了方法来处理缺失值。</p><h4 id="查找缺失值："><a href="#查找缺失值：" class="headerlink" title="查找缺失值："></a>查找缺失值：</h4><p>使用<code>isna()</code>或<code>isnull()</code>方法查找缺失值。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> pandas <span class="token keyword">as</span> pddata <span class="token operator">=</span> pd<span class="token punctuation">.</span>read_csv<span class="token punctuation">(</span><span class="token string">'data.csv'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 查找缺失值</span>missing_values <span class="token operator">=</span> data<span class="token punctuation">.</span>isna<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h4 id="处理缺失值："><a href="#处理缺失值：" class="headerlink" title="处理缺失值："></a>处理缺失值：</h4><p>处理缺失值的方法包括删除包含缺失值的行或列，或者用特定的值进行填充。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> pandas <span class="token keyword">as</span> pddata <span class="token operator">=</span> pd<span class="token punctuation">.</span>read_csv<span class="token punctuation">(</span><span class="token string">'data.csv'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 删除包含缺失值的行</span>data <span class="token operator">=</span> data<span class="token punctuation">.</span>dropna<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 填充缺失值为特定值（例如，填充为0）</span>data <span class="token operator">=</span> data<span class="token punctuation">.</span>fillna<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span></code></pre><h3 id="处理重复值"><a href="#处理重复值" class="headerlink" title="处理重复值"></a>处理重复值</h3><p>重复值可能导致数据分析中的不准确结果，因此处理重复值也很重要。</p><h5 id="查找重复值："><a href="#查找重复值：" class="headerlink" title="查找重复值："></a>查找重复值：</h5><p>使用<code>duplicated()</code>方法查找重复值。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> pandas <span class="token keyword">as</span> pddata <span class="token operator">=</span> pd<span class="token punctuation">.</span>read_csv<span class="token punctuation">(</span><span class="token string">'data.csv'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 查找重复值</span>duplicates <span class="token operator">=</span> data<span class="token punctuation">.</span>duplicated<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h5 id="处理重复值："><a href="#处理重复值：" class="headerlink" title="处理重复值："></a>处理重复值：</h5><p>处理重复值的方法包括删除重复行。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> pandas <span class="token keyword">as</span> pddata <span class="token operator">=</span> pd<span class="token punctuation">.</span>read_csv<span class="token punctuation">(</span><span class="token string">'data.csv'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 删除重复行</span>data <span class="token operator">=</span> data<span class="token punctuation">.</span>drop_duplicates<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h3 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h3><p>有时，数据的类型可能不符合分析的要求，需要进行数据类型转换。</p><h4 id="转换数据类型："><a href="#转换数据类型：" class="headerlink" title="转换数据类型："></a>转换数据类型：</h4><p>使用<code>astype()</code>方法进行数据类型转换。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> pandas <span class="token keyword">as</span> pddata <span class="token operator">=</span> pd<span class="token punctuation">.</span>read_csv<span class="token punctuation">(</span><span class="token string">'data.csv'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 将列A的数据类型转换为整数</span>data<span class="token punctuation">[</span><span class="token string">'A'</span><span class="token punctuation">]</span> <span class="token operator">=</span> data<span class="token punctuation">[</span><span class="token string">'A'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>astype<span class="token punctuation">(</span>int<span class="token punctuation">)</span></code></pre><p>继续填充第二部分的内容：<strong>2.2 数据合并</strong>。</p><h2 id="2-2-数据合并"><a href="#2-2-数据合并" class="headerlink" title="2.2 数据合并"></a>2.2 数据合并</h2><p>在数据分析中，经常需要合并不同的数据集，以便进行更全面的分析。Pandas提供了方法来合并和连接数据集。</p><h3 id="合并数据集"><a href="#合并数据集" class="headerlink" title="合并数据集"></a>合并数据集</h3><p>合并数据集通常是将两个或多个数据集合并为一个更大的数据集。</p><h4 id="concat-合并数据集："><a href="#concat-合并数据集：" class="headerlink" title="concat()合并数据集："></a><code>concat()</code>合并数据集：</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> pandas <span class="token keyword">as</span> pd<span class="token comment" spellcheck="true"># 创建两个数据集</span>df1 <span class="token operator">=</span> pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">'A'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'A0'</span><span class="token punctuation">,</span> <span class="token string">'A1'</span><span class="token punctuation">,</span> <span class="token string">'A2'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                    <span class="token string">'B'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'B0'</span><span class="token punctuation">,</span> <span class="token string">'B1'</span><span class="token punctuation">,</span> <span class="token string">'B2'</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span>df2 <span class="token operator">=</span> pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">'A'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'A3'</span><span class="token punctuation">,</span> <span class="token string">'A4'</span><span class="token punctuation">,</span> <span class="token string">'A5'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                    <span class="token string">'B'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'B3'</span><span class="token punctuation">,</span> <span class="token string">'B4'</span><span class="token punctuation">,</span> <span class="token string">'B5'</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>df1<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>df2<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 输出</span>    A   B<span class="token number">0</span>  A0  B0<span class="token number">1</span>  A1  B1<span class="token number">2</span>  A2  B2    A   B<span class="token number">0</span>  A3  B3<span class="token number">1</span>  A4  B4<span class="token number">2</span>  A5  B5<span class="token comment" spellcheck="true"># 使用concat()方法合并数据集</span>result <span class="token operator">=</span> pd<span class="token punctuation">.</span>concat<span class="token punctuation">(</span><span class="token punctuation">[</span>df1<span class="token punctuation">,</span> df2<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 输出</span>    A   B<span class="token number">0</span>  A0  B0<span class="token number">1</span>  A1  B1<span class="token number">2</span>  A2  B2<span class="token number">0</span>  A3  B3<span class="token number">1</span>  A4  B4<span class="token number">2</span>  A5  B5<span class="token comment" spellcheck="true"># 发现了一个问题，这里的索引混乱了，使用ignore_index=True，参数便可</span><span class="token comment" spellcheck="true"># 使用concat()方法合并数据集，并重新生成索引</span>result <span class="token operator">=</span> pd<span class="token punctuation">.</span>concat<span class="token punctuation">(</span><span class="token punctuation">[</span>df1<span class="token punctuation">,</span> df2<span class="token punctuation">]</span><span class="token punctuation">,</span> ignore_index<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span></code></pre><h3 id="连接数据集"><a href="#连接数据集" class="headerlink" title="连接数据集"></a>连接数据集</h3><p>连接数据集通常是将两个数据集基于某些条件连接在一起。</p><h4 id="merge-连接数据集："><a href="#merge-连接数据集：" class="headerlink" title="merge()连接数据集："></a><code>merge()</code>连接数据集：</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> pandas <span class="token keyword">as</span> pd<span class="token comment" spellcheck="true"># 创建两个数据集</span>left <span class="token operator">=</span> pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">'key'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token string">'B'</span><span class="token punctuation">,</span> <span class="token string">'C'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                     <span class="token string">'value_left'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span>right <span class="token operator">=</span> pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">'key'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'B'</span><span class="token punctuation">,</span> <span class="token string">'C'</span><span class="token punctuation">,</span> <span class="token string">'D'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                      <span class="token string">'value_right'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 使用merge()方法连接数据集</span>result <span class="token operator">=</span> pd<span class="token punctuation">.</span>merge<span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">,</span> on<span class="token operator">=</span><span class="token string">'key'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 输出 on参数为找key列，必须在左右两个数据集中都存在。如果没有显式指定，而又有相同的列名，则会自动寻找相同的列进行合并。</span>  key  value_left<span class="token number">0</span>   A           <span class="token number">1</span><span class="token number">1</span>   B           <span class="token number">2</span><span class="token number">2</span>   C           <span class="token number">3</span>  key  value_right<span class="token number">0</span>   B            <span class="token number">4</span><span class="token number">1</span>   C            <span class="token number">5</span><span class="token number">2</span>   D            <span class="token number">6</span>  key  value_left  value_right<span class="token number">0</span>   B           <span class="token number">2</span>            <span class="token number">4</span><span class="token number">1</span>   C           <span class="token number">3</span>            <span class="token number">5</span></code></pre><p>继续填充第二部分的内容：<strong>2.3 数据变形</strong>。</p><h2 id="2-3-数据变形"><a href="#2-3-数据变形" class="headerlink" title="2.3 数据变形"></a>2.3 数据变形</h2><p>数据变形是数据分析的重要环节，它包括创建透视表、进行数据透视、进行数据分组和聚合等操作。</p><h3 id="透视表和数据透视"><a href="#透视表和数据透视" class="headerlink" title="透视表和数据透视"></a>透视表和数据透视</h3><p>透视表是一种用于汇总和分析数据的强大工具，Pandas提供了创建透视表的方法。</p><h4 id="pivot-table-创建透视表："><a href="#pivot-table-创建透视表：" class="headerlink" title="pivot_table()创建透视表："></a><code>pivot_table()</code>创建透视表：</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> pandas <span class="token keyword">as</span> pddata <span class="token operator">=</span> pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">'Date'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'2023-01-01'</span><span class="token punctuation">,</span> <span class="token string">'2023-01-01'</span><span class="token punctuation">,</span> <span class="token string">'2023-01-02'</span><span class="token punctuation">,</span> <span class="token string">'2023-01-02'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                     <span class="token string">'Category'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token string">'B'</span><span class="token punctuation">,</span> <span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token string">'B'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                     <span class="token string">'Value'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 使用pivot_table()方法创建透视表</span>pivot <span class="token operator">=</span> data<span class="token punctuation">.</span>pivot_table<span class="token punctuation">(</span>index<span class="token operator">=</span><span class="token string">'Date'</span><span class="token punctuation">,</span> columns<span class="token operator">=</span><span class="token string">'Category'</span><span class="token punctuation">,</span> values<span class="token operator">=</span><span class="token string">'Value'</span><span class="token punctuation">,</span> aggfunc<span class="token operator">=</span><span class="token string">'sum'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>pivot<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 输出</span>Category     A   BDate              <span class="token number">2023</span><span class="token operator">-</span><span class="token number">01</span><span class="token operator">-</span><span class="token number">01</span>  <span class="token number">10</span>  <span class="token number">20</span><span class="token number">2023</span><span class="token operator">-</span><span class="token number">01</span><span class="token operator">-</span><span class="token number">02</span>  <span class="token number">15</span>  <span class="token number">25</span></code></pre><h3 id="数据分组和聚合"><a href="#数据分组和聚合" class="headerlink" title="数据分组和聚合"></a>数据分组和聚合</h3><p>数据分组和聚合是将数据按照某些条件划分为组，并对每个组进行统计或计算的操作。</p><h4 id="groupby-进行数据分组和聚合："><a href="#groupby-进行数据分组和聚合：" class="headerlink" title="groupby()进行数据分组和聚合："></a><code>groupby()</code>进行数据分组和聚合：</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> pandas <span class="token keyword">as</span> pddata <span class="token operator">=</span> pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">'Category'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token string">'B'</span><span class="token punctuation">,</span> <span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token string">'B'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                     <span class="token string">'Value'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 使用groupby()方法对数据进行分组</span>grouped <span class="token operator">=</span> data<span class="token punctuation">.</span>groupby<span class="token punctuation">(</span><span class="token string">'Category'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 对每个组进行聚合操作，例如计算平均值</span>aggregated <span class="token operator">=</span> grouped<span class="token punctuation">.</span>mean<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>aggregated<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 输出</span>          ValueCategory       A          <span class="token number">12.5</span>B          <span class="token number">22.5</span></code></pre><h1 id="三、数据分析和可视化"><a href="#三、数据分析和可视化" class="headerlink" title="三、数据分析和可视化"></a>三、数据分析和可视化</h1><h2 id="3-1-数据分析"><a href="#3-1-数据分析" class="headerlink" title="3.1 数据分析"></a>3.1 数据分析</h2><p>在数据分析阶段，通常进行统计分析、排序、排名以及各种数据计算。</p><h3 id="统计描述性统计信息"><a href="#统计描述性统计信息" class="headerlink" title="统计描述性统计信息"></a>统计描述性统计信息</h3><p>Pandas提供了一组用于计算描述性统计信息的函数，如均值、中位数、标准差等。</p><h4 id="使用describe-方法查看基本统计信息："><a href="#使用describe-方法查看基本统计信息：" class="headerlink" title="使用describe()方法查看基本统计信息："></a>使用<code>describe()</code>方法查看基本统计信息：</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> pandas <span class="token keyword">as</span> pddata <span class="token operator">=</span> pd<span class="token punctuation">.</span>read_csv<span class="token punctuation">(</span><span class="token string">'data.csv'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 使用describe()方法查看基本统计信息</span>summary <span class="token operator">=</span> data<span class="token punctuation">.</span>describe<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h3 id="数据排序和排名"><a href="#数据排序和排名" class="headerlink" title="数据排序和排名"></a>数据排序和排名</h3><p>对数据进行排序和排名是了解数据分布和趋势的关键步骤。</p><h4 id="使用sort-values-方法进行排序："><a href="#使用sort-values-方法进行排序：" class="headerlink" title="使用sort_values()方法进行排序："></a>使用<code>sort_values()</code>方法进行排序：</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> pandas <span class="token keyword">as</span> pddata <span class="token operator">=</span> pd<span class="token punctuation">.</span>read_csv<span class="token punctuation">(</span><span class="token string">'data.csv'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 使用sort_values()方法按列A进行升序排序</span>sorted_data <span class="token operator">=</span> data<span class="token punctuation">.</span>sort_values<span class="token punctuation">(</span>by<span class="token operator">=</span><span class="token string">'A'</span><span class="token punctuation">)</span></code></pre><h4 id="使用rank-方法进行排名："><a href="#使用rank-方法进行排名：" class="headerlink" title="使用rank()方法进行排名："></a>使用<code>rank()</code>方法进行排名：</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> pandas <span class="token keyword">as</span> pddata <span class="token operator">=</span> pd<span class="token punctuation">.</span>read_csv<span class="token punctuation">(</span><span class="token string">'data.csv'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 使用rank()方法对列B进行排名</span>ranked_data <span class="token operator">=</span> data<span class="token punctuation">[</span><span class="token string">'B'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>rank<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h3 id="数据运算和计算"><a href="#数据运算和计算" class="headerlink" title="数据运算和计算"></a>数据运算和计算</h3><p>在数据分析中，通常需要进行各种数学运算和计算，如加法、减法、乘法、除法等。</p><h4 id="使用算术运算："><a href="#使用算术运算：" class="headerlink" title="使用算术运算："></a>使用算术运算：</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> pandas <span class="token keyword">as</span> pddata <span class="token operator">=</span> pd<span class="token punctuation">.</span>read_csv<span class="token punctuation">(</span><span class="token string">'data.csv'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 对两列进行加法运算</span>result <span class="token operator">=</span> data<span class="token punctuation">[</span><span class="token string">'A'</span><span class="token punctuation">]</span> <span class="token operator">+</span> data<span class="token punctuation">[</span><span class="token string">'B'</span><span class="token punctuation">]</span></code></pre><h2 id="3-2-数据可视化"><a href="#3-2-数据可视化" class="headerlink" title="3.2 数据可视化"></a>3.2 数据可视化</h2><p>数据可视化是数据分析中的重要部分，可以帮助你更好地理解数据、发现趋势和模式。以下是在Python中使用不同工具进行数据可视化的方法。</p><h3 id="使用Matplotlib库绘制基本图表"><a href="#使用Matplotlib库绘制基本图表" class="headerlink" title="使用Matplotlib库绘制基本图表"></a>使用Matplotlib库绘制基本图表</h3><p>Matplotlib是Python中的常用绘图库，它提供了绘制各种基本图表的功能。</p><h4 id="Matplotlib绘制折线图："><a href="#Matplotlib绘制折线图：" class="headerlink" title="Matplotlib绘制折线图："></a>Matplotlib绘制折线图：</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> pandas <span class="token keyword">as</span> pd<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> pltdata <span class="token operator">=</span> pd<span class="token punctuation">.</span>read_csv<span class="token punctuation">(</span><span class="token string">'data.csv'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 使用Matplotlib绘制折线图</span>plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>data<span class="token punctuation">[</span><span class="token string">'Date'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> data<span class="token punctuation">[</span><span class="token string">'Value'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>xlabel<span class="token punctuation">(</span><span class="token string">'Date'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>ylabel<span class="token punctuation">(</span><span class="token string">'Value'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token string">'Line Chart'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h3 id="利用Pandas内置绘图功能"><a href="#利用Pandas内置绘图功能" class="headerlink" title="利用Pandas内置绘图功能"></a>利用Pandas内置绘图功能</h3><p>Pandas内置了一些绘图功能，使数据可视化更加便捷。</p><h4 id="使用Pandas绘制柱状图："><a href="#使用Pandas绘制柱状图：" class="headerlink" title="使用Pandas绘制柱状图："></a>使用Pandas绘制柱状图：</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> pandas <span class="token keyword">as</span> pddata <span class="token operator">=</span> pd<span class="token punctuation">.</span>read_csv<span class="token punctuation">(</span><span class="token string">'data.csv'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 使用Pandas绘制柱状图</span>data<span class="token punctuation">[</span><span class="token string">'Value'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>plot<span class="token punctuation">(</span>kind<span class="token operator">=</span><span class="token string">'bar'</span><span class="token punctuation">)</span></code></pre><h3 id="高级数据可视化工具（如Seaborn）"><a href="#高级数据可视化工具（如Seaborn）" class="headerlink" title="高级数据可视化工具（如Seaborn）"></a>高级数据可视化工具（如Seaborn）</h3><p>Seaborn是建立在Matplotlib之上的高级数据可视化工具，它可以创建更具吸引力的图表。</p><h4 id="使用Seaborn绘制散点图："><a href="#使用Seaborn绘制散点图：" class="headerlink" title="使用Seaborn绘制散点图："></a>使用Seaborn绘制散点图：</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> pandas <span class="token keyword">as</span> pd<span class="token keyword">import</span> seaborn <span class="token keyword">as</span> sns<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> pltdata <span class="token operator">=</span> pd<span class="token punctuation">.</span>read_csv<span class="token punctuation">(</span><span class="token string">'data.csv'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 使用Seaborn绘制散点图</span>sns<span class="token punctuation">.</span>scatterplot<span class="token punctuation">(</span>data<span class="token operator">=</span>data<span class="token punctuation">,</span> x<span class="token operator">=</span><span class="token string">'X'</span><span class="token punctuation">,</span> y<span class="token operator">=</span><span class="token string">'Y'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h1 id="四、高级Pandas技巧"><a href="#四、高级Pandas技巧" class="headerlink" title="四、高级Pandas技巧"></a>四、高级Pandas技巧</h1><h2 id="4-1-数据时间序列"><a href="#4-1-数据时间序列" class="headerlink" title="4.1 数据时间序列"></a>4.1 数据时间序列</h2><p>处理时间序列数据和日期时间操作是数据分析中的常见任务。Pandas提供了强大的工具来处理时间序列数据。</p><h3 id="处理时间序列数据"><a href="#处理时间序列数据" class="headerlink" title="处理时间序列数据"></a>处理时间序列数据</h3><p>时间序列数据通常包含日期和时间信息，以及相关的数值数据。Pandas的<code>DatetimeIndex</code>类型可用于处理时间序列数据。</p><h4 id="创建时间序列数据："><a href="#创建时间序列数据：" class="headerlink" title="创建时间序列数据："></a>创建时间序列数据：</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> pandas <span class="token keyword">as</span> pd<span class="token comment" spellcheck="true"># 创建一个时间序列</span>date_rng <span class="token operator">=</span> pd<span class="token punctuation">.</span>date_range<span class="token punctuation">(</span>start<span class="token operator">=</span><span class="token string">'2023-01-01'</span><span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">'2023-01-10'</span><span class="token punctuation">,</span> freq<span class="token operator">=</span><span class="token string">'D'</span><span class="token punctuation">)</span>time_series <span class="token operator">=</span> pd<span class="token punctuation">.</span>Series<span class="token punctuation">(</span>range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>date_rng<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> index<span class="token operator">=</span>date_rng<span class="token punctuation">)</span></code></pre><h3 id="日期和时间操作"><a href="#日期和时间操作" class="headerlink" title="日期和时间操作"></a>日期和时间操作</h3><p>Pandas提供了多种日期和时间操作，以便更好地理解和分析时间序列数据。</p><h4 id="提取年、月、日："><a href="#提取年、月、日：" class="headerlink" title="提取年、月、日："></a>提取年、月、日：</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> pandas <span class="token keyword">as</span> pd<span class="token comment" spellcheck="true"># 创建一个时间序列</span>date_rng <span class="token operator">=</span> pd<span class="token punctuation">.</span>date_range<span class="token punctuation">(</span>start<span class="token operator">=</span><span class="token string">'2023-01-01'</span><span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">'2023-01-10'</span><span class="token punctuation">,</span> freq<span class="token operator">=</span><span class="token string">'D'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 提取年、月、日</span>year <span class="token operator">=</span> date_rng<span class="token punctuation">.</span>yearmonth <span class="token operator">=</span> date_rng<span class="token punctuation">.</span>monthday <span class="token operator">=</span> date_rng<span class="token punctuation">.</span>day</code></pre><h4 id="日期偏移："><a href="#日期偏移：" class="headerlink" title="日期偏移："></a>日期偏移：</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> pandas <span class="token keyword">as</span> pd<span class="token comment" spellcheck="true"># 创建一个时间序列</span>date_rng <span class="token operator">=</span> pd<span class="token punctuation">.</span>date_range<span class="token punctuation">(</span>start<span class="token operator">=</span><span class="token string">'2023-01-01'</span><span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">'2023-01-10'</span><span class="token punctuation">,</span> freq<span class="token operator">=</span><span class="token string">'D'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 对日期进行偏移</span>next_week <span class="token operator">=</span> date_rng <span class="token operator">+</span> pd<span class="token punctuation">.</span>DateOffset<span class="token punctuation">(</span>weeks<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span></code></pre><h4 id="日期和时间的格式化"><a href="#日期和时间的格式化" class="headerlink" title="日期和时间的格式化"></a>日期和时间的格式化</h4><p>可以使用<code>.strftime()</code>方法将日期和时间格式化为字符串。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> pandas <span class="token keyword">as</span> pd<span class="token comment" spellcheck="true"># 创建一个时间序列</span>date_rng <span class="token operator">=</span> pd<span class="token punctuation">.</span>date_range<span class="token punctuation">(</span>start<span class="token operator">=</span><span class="token string">'2023-01-01'</span><span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">'2023-01-10'</span><span class="token punctuation">,</span> freq<span class="token operator">=</span><span class="token string">'D'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 将日期格式化为字符串</span>formatted_dates <span class="token operator">=</span> date_rng<span class="token punctuation">.</span>strftime<span class="token punctuation">(</span><span class="token string">'%Y-%m-%d'</span><span class="token punctuation">)</span></code></pre><h2 id="4-2-多级索引"><a href="#4-2-多级索引" class="headerlink" title="4.2 多级索引"></a>4.2 多级索引</h2><p>多级索引（也称为层次索引）是一种在Pandas中用于管理和分析多维数据的重要工具。它允许<strong>创建具有多个级别的索引，以更灵活地访问和分析数据</strong>。</p><h3 id="创建和使用多级索引"><a href="#创建和使用多级索引" class="headerlink" title="创建和使用多级索引"></a>创建和使用多级索引</h3><p>创建多级索引需要通过<code>MultiIndex</code>对象来实现。</p><h5 id="创建多级索引："><a href="#创建多级索引：" class="headerlink" title="创建多级索引："></a>创建多级索引：</h5><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> pandas <span class="token keyword">as</span> pddata <span class="token operator">=</span> pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">'A'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                     <span class="token string">'B'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">,</span>                    index<span class="token operator">=</span>pd<span class="token punctuation">.</span>MultiIndex<span class="token punctuation">.</span>from_tuples<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">'X'</span><span class="token punctuation">,</span> <span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'X'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'Y'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'Y'</span><span class="token punctuation">,</span> <span class="token string">'d'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                                                    names<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'Group'</span><span class="token punctuation">,</span> <span class="token string">'Letter'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 输出</span>              A  BGroup Letter      X     a       <span class="token number">1</span>  <span class="token number">5</span>      b       <span class="token number">2</span>  <span class="token number">6</span>Y     c       <span class="token number">3</span>  <span class="token number">7</span>      d       <span class="token number">4</span>  <span class="token number">8</span></code></pre><h5 id="使用多级索引："><a href="#使用多级索引：" class="headerlink" title="使用多级索引："></a>使用多级索引：</h5><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 使用多级索引来访问数据</span>value <span class="token operator">=</span> data<span class="token punctuation">.</span>loc<span class="token punctuation">[</span><span class="token string">'X'</span><span class="token punctuation">,</span> <span class="token string">'a'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'A'</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 输出为1</span></code></pre><h3 id="数据透视表和多级索引"><a href="#数据透视表和多级索引" class="headerlink" title="数据透视表和多级索引"></a>数据透视表和多级索引</h3><p>多级索引与数据透视表结合使用，可以更灵活地对数据进行汇总和分析。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> pandas <span class="token keyword">as</span> pddata <span class="token operator">=</span> pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">'Category'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token string">'B'</span><span class="token punctuation">,</span> <span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token string">'B'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                     <span class="token string">'Value'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 使用Pandas的pivot_table()方法创建数据透视表</span>pivot <span class="token operator">=</span> data<span class="token punctuation">.</span>pivot_table<span class="token punctuation">(</span>index<span class="token operator">=</span><span class="token string">'Category'</span><span class="token punctuation">,</span> values<span class="token operator">=</span><span class="token string">'Value'</span><span class="token punctuation">,</span> aggfunc<span class="token operator">=</span><span class="token string">'sum'</span><span class="token punctuation">)</span></code></pre><h2 id="4-3-数据处理和性能优化"><a href="#4-3-数据处理和性能优化" class="headerlink" title="4.3 数据处理和性能优化"></a>4.3 数据处理和性能优化</h2><p>在数据分析中，数据处理的效率非常重要，尤其在处理大型数据集时。以下是一些提高数据处理效率的技巧和方法。</p><h3 id="使用向量化操作"><a href="#使用向量化操作" class="headerlink" title="使用向量化操作"></a>使用向量化操作</h3><p>向量化操作是一种利用NumPy和Pandas的数组功能，以一种优化的方式处理数据的方法。它可以显著提高处理速度。</p><h5 id="示例：使用向量化操作计算两列之和"><a href="#示例：使用向量化操作计算两列之和" class="headerlink" title="示例：使用向量化操作计算两列之和"></a>示例：使用向量化操作计算两列之和</h5><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> pandas <span class="token keyword">as</span> pddata <span class="token operator">=</span> pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">'A'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                     <span class="token string">'B'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 使用向量化操作计算两列之和</span>data<span class="token punctuation">[</span><span class="token string">'Sum'</span><span class="token punctuation">]</span> <span class="token operator">=</span> data<span class="token punctuation">[</span><span class="token string">'A'</span><span class="token punctuation">]</span> <span class="token operator">+</span> data<span class="token punctuation">[</span><span class="token string">'B'</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 输出</span>   A  B  Sum<span class="token number">0</span>  <span class="token number">1</span>  <span class="token number">5</span>    <span class="token number">6</span><span class="token number">1</span>  <span class="token number">2</span>  <span class="token number">6</span>    <span class="token number">8</span><span class="token number">2</span>  <span class="token number">3</span>  <span class="token number">7</span>   <span class="token number">10</span><span class="token number">3</span>  <span class="token number">4</span>  <span class="token number">8</span>   <span class="token number">12</span></code></pre><h3 id="提高数据处理效率的技巧"><a href="#提高数据处理效率的技巧" class="headerlink" title="提高数据处理效率的技巧"></a>提高数据处理效率的技巧</h3><p>除了向量化操作，还有一些其他技巧可以提高数据处理的效率。</p><h4 id="使用-apply-方法："><a href="#使用-apply-方法：" class="headerlink" title="使用.apply()方法："></a>使用<code>.apply()</code>方法：</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> pandas <span class="token keyword">as</span> pddata <span class="token operator">=</span> pd<span class="token punctuation">.</span>read_csv<span class="token punctuation">(</span><span class="token string">'data.csv'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 使用apply()方法对每行进行操作</span>data<span class="token punctuation">[</span><span class="token string">'New_Column'</span><span class="token punctuation">]</span> <span class="token operator">=</span> data<span class="token punctuation">.</span>apply<span class="token punctuation">(</span><span class="token keyword">lambda</span> row<span class="token punctuation">:</span> row<span class="token punctuation">[</span><span class="token string">'A'</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span></code></pre><h3 id="大数据集的处理"><a href="#大数据集的处理" class="headerlink" title="大数据集的处理"></a>大数据集的处理</h3><p>处理大型数据集时，应采取一些额外的措施来提高性能。</p><h4 id="逐块处理大数据集："><a href="#逐块处理大数据集：" class="headerlink" title="逐块处理大数据集："></a>逐块处理大数据集：</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> pandas <span class="token keyword">as</span> pd<span class="token comment" spellcheck="true"># 逐块处理大数据集</span>chunk_size <span class="token operator">=</span> <span class="token number">1000</span><span class="token keyword">for</span> chunk <span class="token keyword">in</span> pd<span class="token punctuation">.</span>read_csv<span class="token punctuation">(</span><span class="token string">'large_data.csv'</span><span class="token punctuation">,</span> chunksize<span class="token operator">=</span>chunk_size<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 处理每个数据块</span>    process_chunk<span class="token punctuation">(</span>chunk<span class="token punctuation">)</span></code></pre><p>这种方式可以减小内存占用，提高处理效率。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>pandas官网：<a href="https://pandas.pydata.org/docs/index.html" target="_blank" rel="noopener">https://pandas.pydata.org/docs/index.html</a> </p>]]></content>
      
      
      <categories>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据分析 </tag>
            
            <tag> python </tag>
            
            <tag> pandas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python数据分析-numpy</title>
      <link href="/shu-fen-numpy.html"/>
      <url>/shu-fen-numpy.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>当涉足数据分析世界，无论是初学者还是经验丰富的分析师，都会发现Python是一个强大而灵活的工具。而在Python的数据分析生态系统中，NumPy（Numerical Python）是一个不可或缺的库，它提供了广泛的数学和统计函数，以及多维数组操作的能力。</p><p>在本博客中，将探讨NumPy库的核心功能，从创建和操作多维数组，到使用广播机制进行数组计算，再到了解结构化数组和矩阵计算。NumPy不仅提供了强大的数学工具，还是数据分析、机器学习和科学计算的基础。</p><p>无论你是希望提高数据分析技能，还是需要深入了解NumPy的各种用途，这篇博客都将为你提供宝贵的知识。让我们一起开始探索NumPy，掌握这个强大的数据分析工具！</p><h1 id="结构体系"><a href="#结构体系" class="headerlink" title="结构体系"></a>结构体系</h1><p>基于 NumPy 的知识体系梳理：</p><p>一、NumPy 基础</p><ol><li><p>数组创建与操作：ndarray对象、数组切片、数组形状修改、数组数据类型、数组转换与复制</p></li><li><p>数组索引与切片：一维、二维和多维数组的索引与切片操作。</p></li><li><p>数组运算与广播：NumPy 数组支持元素级别的运算，也可以使用数学函数和线性代数函数对数组进行操作。</p></li><li><p>数组统计与排序：计算数组的最大值、最小值、平均数、中位数、方差、标准差等统计量；以及对数组进行排序。</p></li><li><p>随机数生成：使用 NumPy 可以生成各种类型的随机数，例如服从正态分布、均匀分布等的随机数。</p></li></ol><p>二、NumPy 进阶</p><ol><li>数组高级操作：布尔索引、花式索引、where 函数、迭代器等。</li><li>数组合并和拆分：vstack、hstack、concatenate 等函数可以将多个数组合并成一个数组，split、hsplit 和 vsplit 函数则可以将一个数组拆分成多个部分。</li><li>广义表与轴：广义表是由嵌套列表或数组组成的数据结构，可以用来表示树状、分层结构的数据。轴是表示数组维度的对象，通过指定轴可以对数组进行各种操作。</li><li>数组的内存布局：了解 NumPy 数组内存布局对于数组的性能优化非常重要，包括数组的 C 风格和 Fortran 风格的存储方式，以及如何使用 strides 属性来自定义数组内存布局。</li><li>结构化数组：结构化数组可以看作是表格或数据库中的行，每个元素包含多个字段，可以使用字段名或下标访问。</li><li>矩阵计算：NumPy 提供了专门的矩阵类 matrix，以及针对矩阵的一些特定运算函数，例如矩阵乘法、求逆矩阵等。</li></ol><h1 id="1-数组创建与操作"><a href="#1-数组创建与操作" class="headerlink" title="1.数组创建与操作"></a>1.数组创建与操作</h1><h2 id="1-1-ndarray对象"><a href="#1-1-ndarray对象" class="headerlink" title="1.1 ndarray对象"></a>1.1 ndarray对象</h2><p><code>ndarray</code>（N-dimensional array）是NumPy中的核心数据结构，用于表示多维数组。它提供了高效的数值计算和广泛的数学函数支持。</p><h4 id="创建ndarray对象"><a href="#创建ndarray对象" class="headerlink" title="创建ndarray对象"></a>创建ndarray对象</h4><p>在NumPy中，使用<code>np.array()</code>函数来创建<code>ndarray</code>对象。例如，创建一个简单的一维数组：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token comment" spellcheck="true"># 创建一维数组</span>arr <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#输出</span><span class="token punctuation">[</span><span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span><span class="token punctuation">]</span></code></pre><h4 id="数组的属性"><a href="#数组的属性" class="headerlink" title="数组的属性"></a>数组的属性</h4><p><code>ndarray</code>对象有一些重要的属性：</p><ul><li>形状（shape）：数组的维度和大小。</li><li>数据类型（dtype）：数组中元素的数据类型。</li><li>维度（ndim）：数组的维度数量。</li><li>大小（size）：数组中元素的总数。</li></ul><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 数组的属性</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"形状："</span><span class="token punctuation">,</span> arr<span class="token punctuation">.</span>shape<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"数据类型："</span><span class="token punctuation">,</span> arr<span class="token punctuation">.</span>dtype<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"维度："</span><span class="token punctuation">,</span> arr<span class="token punctuation">.</span>ndim<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"大小："</span><span class="token punctuation">,</span> arr<span class="token punctuation">.</span>size<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 输出</span>形状： <span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token punctuation">)</span>数据类型： int32维度： <span class="token number">1</span>大小： <span class="token number">5</span></code></pre><h4 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h4><p>除了一维数组，NumPy还支持多维数组的创建。例如，创建一个二维数组：</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 创建二维数组</span>matrix <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>matrix<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 输出</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token number">4</span> <span class="token number">5</span> <span class="token number">6</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token number">7</span> <span class="token number">8</span> <span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">]</span></code></pre><h4 id="数组索引与切片"><a href="#数组索引与切片" class="headerlink" title="数组索引与切片"></a>数组索引与切片</h4><p>你可以使用索引和切片来访问数组中的元素。例如，访问一维数组的第三个元素：</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 访问一维数组的元素</span><span class="token keyword">print</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 输出 3</span></code></pre><p>或者访问二维数组的特定元素：</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 访问二维数组的元素</span><span class="token keyword">print</span><span class="token punctuation">(</span>matrix<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 输出 6</span></code></pre><h2 id="1-2-数组切片"><a href="#1-2-数组切片" class="headerlink" title="1.2 数组切片"></a>1.2 数组切片</h2><h4 id="切片一维数组"><a href="#切片一维数组" class="headerlink" title="切片一维数组"></a>切片一维数组</h4><p>在一维数组中，使用切片来获取数组的子集。例如，创建一个包含一些整数的一维数组：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> nparr <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 使用切片获取数组的子集</span>subset <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true"># 从索引1到3（不包含4）</span><span class="token keyword">print</span><span class="token punctuation">(</span>subset<span class="token punctuation">)</span></code></pre><p>这将输出 <code>[20 30 40]</code>，即从索引1到3的元素。</p><h4 id="切片多维数组"><a href="#切片多维数组" class="headerlink" title="切片多维数组"></a>切片多维数组</h4><p>在多维数组中，你可以使用切片来获取行、列或子数组。例如，创建一个二维数组：</p><pre class=" language-python"><code class="language-python">matrix <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 使用切片获取行</span>row <span class="token operator">=</span> matrix<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true"># 获取第二行</span><span class="token keyword">print</span><span class="token punctuation">(</span>row<span class="token punctuation">)</span></code></pre><p>这将输出 <code>[4 5 6]</code>，表示我们获取了第二行的所有元素。</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 使用切片获取列</span>column <span class="token operator">=</span> matrix<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true"># 获取第三列</span><span class="token keyword">print</span><span class="token punctuation">(</span>column<span class="token punctuation">)</span></code></pre><p>这将输出 <code>[3 6 9]</code>，表示我们获取了第三列的所有元素。</p><h4 id="高级切片"><a href="#高级切片" class="headerlink" title="高级切片"></a>高级切片</h4><p>NumPy允许使用更高级的切片操作，如跳跃切片、布尔值切片等，以满足更复杂的需求。例如，通过布尔值切片，可以根据某个条件选择数组中的元素。</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 布尔值切片示例</span>values <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span>condition <span class="token operator">=</span> values <span class="token operator">></span> <span class="token number">2</span>result <span class="token operator">=</span> values<span class="token punctuation">[</span>condition<span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span></code></pre><p>这将输出 <code>[3 4 5]</code>，表示我们选择了大于2的元素。</p><p>继续我们的探讨，下一个要点是<strong>数组形状修改</strong>。在NumPy中，你可以轻松地改变数组的形状以满足你的需求。</p><h2 id="1-3-数组形状修改"><a href="#1-3-数组形状修改" class="headerlink" title="1.3 数组形状修改"></a>1.3 数组形状修改</h2><h4 id="使用reshape-方法"><a href="#使用reshape-方法" class="headerlink" title="使用reshape()方法"></a>使用<code>reshape()</code>方法</h4><p><code>reshape()</code>方法允许改变数组的形状，而不改变其数据。例如，创建一个一维数组，然后将其形状改变为二维数组：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> nparr <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 使用reshape()方法改变数组形状</span>reshaped_arr <span class="token operator">=</span> arr<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 将一维数组转换为二维数组</span><span class="token keyword">print</span><span class="token punctuation">(</span>reshaped_arr<span class="token punctuation">)</span></code></pre><p>这将输出一个二维数组：</p><pre><code>[[1 2 3] [4 5 6]]</code></pre><h4 id="使用ravel-和flatten-方法"><a href="#使用ravel-和flatten-方法" class="headerlink" title="使用ravel()和flatten()方法"></a>使用<code>ravel()</code>和<code>flatten()</code>方法</h4><p>需要将多维数组转换为一维数组，这时可以使用 <code>ravel()</code> 或 <code>flatten()</code> 方法。</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 使用ravel()方法将多维数组转换为一维数组</span>raveled_arr <span class="token operator">=</span> reshaped_arr<span class="token punctuation">.</span>ravel<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>raveled_arr<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 使用flatten()方法同样将多维数组转换为一维数组</span>flattened_arr <span class="token operator">=</span> reshaped_arr<span class="token punctuation">.</span>flatten<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>flattened_arr<span class="token punctuation">)</span></code></pre><blockquote><p>这两种方法都会将多维数组转换为一维数组，不过 <code>ravel()</code> 有时会返回视图（视图与原数组共享数据），而 <code>flatten()</code> 总是返回数组的副本（新数组）。</p></blockquote><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>在使用 <code>reshape()</code> 进行形状修改时，需要确保新形状兼容原数组的大小。否则，将会收到 <code>ValueError</code> 错误。例如，尝试将一个包含6个元素的一维数组改为3x3的形状将导致错误。</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 错误的形状修改示例</span>arr <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">)</span>reshaped_arr <span class="token operator">=</span> arr<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 这将引发错误</span></code></pre><h2 id="1-4-数组数据类型"><a href="#1-4-数组数据类型" class="headerlink" title="1.4 数组数据类型"></a>1.4 数组数据类型</h2><h4 id="默认数据类型"><a href="#默认数据类型" class="headerlink" title="默认数据类型"></a>默认数据类型</h4><p>当创建一个数组时，NumPy会根据输入的数据自动选择一个合适的数据类型。例如，创建一个包含整数的数组，NumPy通常会使用整数数据类型。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> nparr <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"默认数据类型："</span><span class="token punctuation">,</span> arr<span class="token punctuation">.</span>dtype<span class="token punctuation">)</span></code></pre><h4 id="显示指定数据类型"><a href="#显示指定数据类型" class="headerlink" title="显示指定数据类型"></a>显示指定数据类型</h4><p>需要显式指定数组的数据类型，以确保计算的精度或满足特定需求。可以使用<code>dtype</code>参数来指定数据类型：</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 显式指定数据类型</span>arr_float <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span>float<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"指定数据类型为浮点数："</span><span class="token punctuation">,</span> arr_float<span class="token punctuation">.</span>dtype<span class="token punctuation">)</span></code></pre><h4 id="数据类型的影响"><a href="#数据类型的影响" class="headerlink" title="数据类型的影响"></a>数据类型的影响</h4><p>不同的数据类型会影响数组的内存占用和数值精度。例如，浮点数通常会占用更多内存，但具有更高的数值精度，而整数占用较少内存，但精度有限。</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 不同数据类型的影响</span>arr_int <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span>int<span class="token punctuation">)</span>arr_float <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span>float<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"整数数组内存占用："</span><span class="token punctuation">,</span> arr_int<span class="token punctuation">.</span>itemsize<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"浮点数数组内存占用："</span><span class="token punctuation">,</span> arr_float<span class="token punctuation">.</span>itemsize<span class="token punctuation">)</span></code></pre><h4 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h4><p>使用<code>astype()</code>方法来将数组的数据类型转换为其他类型：</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 数据类型转换</span>arr_int <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span>int<span class="token punctuation">)</span>arr_float <span class="token operator">=</span> arr_int<span class="token punctuation">.</span>astype<span class="token punctuation">(</span>float<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"转换后的数据类型："</span><span class="token punctuation">,</span> arr_float<span class="token punctuation">.</span>dtype<span class="token punctuation">)</span></code></pre><h2 id="1-5-数组转换与复制"><a href="#1-5-数组转换与复制" class="headerlink" title="1.5 数组转换与复制"></a>1.5 数组转换与复制</h2><h4 id="数组的数据类型转换"><a href="#数组的数据类型转换" class="headerlink" title="数组的数据类型转换"></a>数组的数据类型转换</h4><p>在前面的部分，已经讨论了如何使用 <code>astype()</code> 方法将数组的数据类型转换为其他类型。这对于将数组从一个数据类型转换为另一个数据类型非常有用。例如：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> nparr_int <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span>int<span class="token punctuation">)</span>arr_float <span class="token operator">=</span> arr_int<span class="token punctuation">.</span>astype<span class="token punctuation">(</span>float<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 将整数数组转换为浮点数数组</span></code></pre><h4 id="复制和视图"><a href="#复制和视图" class="headerlink" title="复制和视图"></a>复制和视图</h4><p>当你对数组执行操作时，有时会创建原始数组的副本，有时会创建一个视图，它与原始数组共享数据。这可能会导致一些不同的行为。</p><ul><li><strong>副本</strong>：如果你明确要创建一个新的独立副本，可以使用 <code>copy()</code> 方法。</li></ul><pre class=" language-python"><code class="language-python">original_arr <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>copied_arr <span class="token operator">=</span> original_arr<span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 创建副本</span></code></pre><ul><li><strong>视图</strong>：在某些情况下，切片和形状修改操作会返回一个视图，而不是副本。这表示数据在原始数组和视图之间共享。</li></ul><pre class=" language-python"><code class="language-python">original_arr <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span>sliced_arr <span class="token operator">=</span> original_arr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true"># 创建一个切片（视图）</span></code></pre><h4 id="引用和复制的区别"><a href="#引用和复制的区别" class="headerlink" title="引用和复制的区别"></a>引用和复制的区别</h4><p>理解视图和副本的区别非常重要。修改视图可能会影响原始数组，而修改副本则不会。例如：</p><pre class=" language-python"><code class="language-python">original_arr <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span>sliced_arr <span class="token operator">=</span> original_arr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true"># 创建一个切片（视图）</span>sliced_arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">99</span>  <span class="token comment" spellcheck="true"># 修改切片，会影响原始数组</span><span class="token keyword">print</span><span class="token punctuation">(</span>original_arr<span class="token punctuation">)</span></code></pre><p>在上面的例子中，原始数组中的值也被修改为 <code>[1, 99, 3, 4, 5]</code>，因为切片是一个视图，与原始数组共享数据。</p><pre class=" language-python"><code class="language-python">original_arr <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span>copied_arr <span class="token operator">=</span> original_arr<span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 创建副本</span>copied_arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">99</span>  <span class="token comment" spellcheck="true"># 修改副本，不会影响原始数组</span><span class="token keyword">print</span><span class="token punctuation">(</span>original_arr<span class="token punctuation">)</span></code></pre><p>在这个例子中，原始数组保持不变，因为我们在副本上进行了修改</p><h1 id="2-数组索引与切片"><a href="#2-数组索引与切片" class="headerlink" title="2. 数组索引与切片"></a>2. 数组索引与切片</h1><h2 id="2-1-一维数组的索引与切片"><a href="#2-1-一维数组的索引与切片" class="headerlink" title="2.1 一维数组的索引与切片"></a>2.1 一维数组的索引与切片</h2><p>在NumPy中，一维数组的索引和切片操作非常类似于Python中的列表。示例：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> nparr <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 获取单个元素</span>element <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true"># 获取索引为2的元素，值为30</span><span class="token comment" spellcheck="true"># 使用切片获取子数组</span>subset <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true"># 获取索引1到3的元素，子数组为 [20, 30, 40]</span><span class="token comment" spellcheck="true"># 使用负数索引从尾部开始计数</span>tail_element <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true"># 获取最后一个元素，值为50</span><span class="token comment" spellcheck="true"># 使用步长切片</span>every_other <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true"># 每隔一个元素，得到 [10, 30, 50]</span><span class="token comment" spellcheck="true"># 修改元素的值</span>arr<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">42</span>  <span class="token comment" spellcheck="true"># 将索引为3的元素修改为42</span><span class="token comment" spellcheck="true"># 反转数组</span>reversed_arr <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true"># 得到 [50, 42, 30, 20, 10]</span></code></pre><p>这些是一维数组索引和切片的基本操作。通过索引获取单个元素，通过切片获取子数组，使用负数索引从尾部开始计数，以及使用步长切片来创建新的数组。</p><h2 id="2-2-二维和多维数组的索引与切片"><a href="#2-2-二维和多维数组的索引与切片" class="headerlink" title="2.2 二维和多维数组的索引与切片"></a>2.2 二维和多维数组的索引与切片</h2><p>在二维和多维数组中，索引和切片操作稍微复杂一些，因为需要考虑多个维度。示例：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> npmatrix <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 获取单个元素</span>element <span class="token operator">=</span> matrix<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true"># 获取第二行第三列的元素，值为6</span><span class="token comment" spellcheck="true"># 使用切片获取行或列</span>row <span class="token operator">=</span> matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true"># 获取第一行，数组为 [1, 2, 3]</span>column <span class="token operator">=</span> matrix<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true"># 获取第二列，数组为 [2, 5, 8]</span><span class="token comment" spellcheck="true"># 获取子矩阵</span>submatrix <span class="token operator">=</span> matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true"># 获取第一行到第二行、第二列到第三列的子矩阵</span></code></pre><p>在二维和多维数组中，使用逗号分隔的索引来访问不同维度的元素。还可以使用切片来获取行、列或子矩阵。</p><p>非常好，让我们继续探讨<strong>数组运算与广播</strong>，这是NumPy中非常重要的概念，允许你进行元素级别的运算以及应用数学函数和线性代数函数。</p><h1 id="3-数组运算与广播"><a href="#3-数组运算与广播" class="headerlink" title="3. 数组运算与广播"></a>3. 数组运算与广播</h1><h2 id="3-1-元素级别的运算"><a href="#3-1-元素级别的运算" class="headerlink" title="3.1 元素级别的运算"></a>3.1 元素级别的运算</h2><p>NumPy数组支持元素级别的运算，可以对数组的每个元素进行操作，而不必编写循环。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token comment" spellcheck="true"># 创建两个数组</span>arr1 <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span>arr2 <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 加法</span>result_add <span class="token operator">=</span> arr1 <span class="token operator">+</span> arr2  <span class="token comment" spellcheck="true"># 对应元素相加</span><span class="token comment" spellcheck="true"># 减法</span>result_subtract <span class="token operator">=</span> arr1 <span class="token operator">-</span> arr2  <span class="token comment" spellcheck="true"># 对应元素相减</span><span class="token comment" spellcheck="true"># 乘法</span>result_multiply <span class="token operator">=</span> arr1 <span class="token operator">*</span> arr2  <span class="token comment" spellcheck="true"># 对应元素相乘</span><span class="token comment" spellcheck="true"># 除法</span>result_divide <span class="token operator">=</span> arr1 <span class="token operator">/</span> arr2  <span class="token comment" spellcheck="true"># 对应元素相除</span><span class="token comment" spellcheck="true"># 幂运算</span>result_power <span class="token operator">=</span> arr1 <span class="token operator">**</span> <span class="token number">2</span>  <span class="token comment" spellcheck="true"># 对每个元素进行平方运算</span><span class="token comment" spellcheck="true"># 开方</span>result_sqrt <span class="token operator">=</span> np<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span>arr1<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 对每个元素进行平方根运算</span></code></pre><p>这些是一些常见的元素级别运算示例，但NumPy支持更多运算，包括三角函数、指数函数等。</p><h2 id="3-2-广播"><a href="#3-2-广播" class="headerlink" title="3.2 广播"></a>3.2 广播</h2><p><strong>广播是NumPy中强大的特性之一，它允许对不同形状的数组进行运算</strong>。当你对不同形状的数组进行运算时，NumPy会<strong>自动扩展较小的数组以匹配较大的数组，使它们具有相同的形状，然后执行运算</strong>。</p><p>例如，将一个标量（如单个数字）与数组相乘：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> nparr <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span>result <span class="token operator">=</span> arr <span class="token operator">*</span> <span class="token number">2</span>  <span class="token comment" spellcheck="true"># 数组中的每个元素都乘以2</span></code></pre><p>在这个示例中，标量2被广播到数组<code>arr</code>的每个元素上，以执行元素级别的乘法运算。</p><p><strong>广播也适用于不同形状的数组，只要它们在某些维度上具有相同的大小</strong>。例如，将一个一维数组与一个二维数组相加：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> nparr1 <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>arr2 <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">40</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">60</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>result <span class="token operator">=</span> arr1 <span class="token operator">+</span> arr2</code></pre><p>在这个示例中，一维数组<code>arr1</code>被广播到与二维数组<code>arr2</code>相同的形状，以执行元素级别的加法运算。</p><p>广播是NumPy中强大的功能，能够执行各种不同形状的数组之间的运算，而无需显式编写循环。</p><p>这是数组运算与广播的基础知识，NumPy提供了丰富的数学函数和线性代数函数，可以应用于数组，以进行更复杂的数学和统计分析。</p><p>继续我们的学习，下一个要点是<strong>数组统计与排序</strong>，在NumPy中，你可以轻松地执行各种统计操作和数组排序。</p><h1 id="4-数组统计与排序"><a href="#4-数组统计与排序" class="headerlink" title="4. 数组统计与排序"></a>4. 数组统计与排序</h1><h2 id="4-1-数组的统计操作"><a href="#4-1-数组的统计操作" class="headerlink" title="4.1 数组的统计操作"></a>4.1 数组的统计操作</h2><p>NumPy提供了一系列用于计算数组统计量的函数，如最大值、最小值、平均数、中位数、方差、标准差等。</p><p>下面是一些常见的统计函数示例：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> nparr <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">45</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">23</span><span class="token punctuation">,</span> <span class="token number">56</span><span class="token punctuation">,</span> <span class="token number">19</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 计算数组的最大值</span>max_value <span class="token operator">=</span> np<span class="token punctuation">.</span>max<span class="token punctuation">(</span>arr<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 输出 56</span><span class="token comment" spellcheck="true"># 计算数组的最小值</span>min_value <span class="token operator">=</span> np<span class="token punctuation">.</span>min<span class="token punctuation">(</span>arr<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 输出 5</span><span class="token comment" spellcheck="true"># 计算数组的平均值</span>mean_value <span class="token operator">=</span> np<span class="token punctuation">.</span>mean<span class="token punctuation">(</span>arr<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 输出 23.285714285714285</span><span class="token comment" spellcheck="true"># 计算数组的中位数</span>median_value <span class="token operator">=</span> np<span class="token punctuation">.</span>median<span class="token punctuation">(</span>arr<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 输出 19.0</span><span class="token comment" spellcheck="true"># 计算数组的方差</span>variance <span class="token operator">=</span> np<span class="token punctuation">.</span>var<span class="token punctuation">(</span>arr<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 输出 301.38775510204084</span><span class="token comment" spellcheck="true"># 计算数组的标准差</span>std_deviation <span class="token operator">=</span> np<span class="token punctuation">.</span>std<span class="token punctuation">(</span>arr<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 输出 17.387426361556492</span></code></pre><p>这些函数可用于一维数组，也可以用于多维数组，并通过指定<code>axis</code>参数来沿指定轴进行计算。</p><p>首先，创建一个二维数组，以进行示例：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> npmatrix <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">45</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">23</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                  <span class="token punctuation">[</span><span class="token number">56</span><span class="token punctuation">,</span> <span class="token number">19</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                  <span class="token punctuation">[</span><span class="token number">33</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">43</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><h4 id="沿行进行统计"><a href="#沿行进行统计" class="headerlink" title="沿行进行统计"></a>沿行进行统计</h4><p>沿行计算统计量，例如每行的平均值，可以使用<code>axis</code>参数指定轴0（行轴）：</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 计算每行的平均值</span>row_means <span class="token operator">=</span> np<span class="token punctuation">.</span>mean<span class="token punctuation">(</span>matrix<span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span></code></pre><p>这将计算每一列的平均值，结果为 <code>[33.66666667 28.66666667 7.66666667 24.66666667]</code>。</p><h4 id="沿列进行统计"><a href="#沿列进行统计" class="headerlink" title="沿列进行统计"></a>沿列进行统计</h4><p>沿列计算统计量，例如每列的最大值，可以使用<code>axis</code>参数指定轴1（列轴）：</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 计算每列的最大值</span>column_max <span class="token operator">=</span> np<span class="token punctuation">.</span>max<span class="token punctuation">(</span>matrix<span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span></code></pre><p>这将计算每一行的最大值，结果为 <code>[45 56 43]</code>。</p><p>这是一个简单的案例，说明如何使用<code>axis</code>参数来沿指定轴执行统计操作。可以使用相同的方法来计算其他统计量，如最小值、中位数、方差等。</p><h2 id="4-2-数组的排序"><a href="#4-2-数组的排序" class="headerlink" title="4.2 数组的排序"></a>4.2 数组的排序</h2><p>NumPy还提供了用于数组排序的函数，按升序或降序对数组进行排序。下面是一些示例：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> nparr <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">45</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">23</span><span class="token punctuation">,</span> <span class="token number">56</span><span class="token punctuation">,</span> <span class="token number">19</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 对数组升序排序 sort默认为升序</span>sorted_arr_ascending <span class="token operator">=</span> np<span class="token punctuation">.</span>sort<span class="token punctuation">(</span>arr<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 输出 [ 5  7 12 19 23 45 56]</span><span class="token comment" spellcheck="true"># 对数组降序排序</span>sorted_arr_descending <span class="token operator">=</span> np<span class="token punctuation">.</span>sort<span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true"># 输出 [56 45 23 19 12  7  5]</span></code></pre><p>使用<code>argsort()</code>函数来获取排序后的索引，以便对其他数组进行相同的排序操作。</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 获取排序后的索引</span>sorted_indices <span class="token operator">=</span> np<span class="token punctuation">.</span>argsort<span class="token punctuation">(</span>arr<span class="token punctuation">)</span></code></pre><p>继续我们的学习，下一个要点是<strong>随机数生成</strong>，在NumPy中，你可以使用随机数生成函数生成各种类型的随机数，包括服从正态分布、均匀分布等的随机数。</p><h1 id="5-随机数生成"><a href="#5-随机数生成" class="headerlink" title="5. 随机数生成"></a>5. 随机数生成</h1><h2 id="5-1-生成均匀分布的随机数"><a href="#5-1-生成均匀分布的随机数" class="headerlink" title="5.1 生成均匀分布的随机数"></a>5.1 生成均匀分布的随机数</h2><p>使用<code>np.random.rand()</code>函数生成服从均匀分布的随机数。这将生成在0到1之间均匀分布的随机数。以下是一些示例：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token comment" spellcheck="true"># 生成一个均匀分布的随机数</span>uniform_random <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>rand<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 生成一个[0, 1)范围内的随机数</span><span class="token comment" spellcheck="true"># 生成一个一维数组，包含多个均匀分布的随机数</span>uniform_array <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>rand<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 生成包含5个随机数的一维数组</span><span class="token comment" spellcheck="true"># 生成一个二维数组，包含多个均匀分布的随机数</span>uniform_matrix <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>rand<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 生成3x2的二维数组，包含均匀分布的随机数</span></code></pre><h2 id="5-2-生成正态分布的随机数"><a href="#5-2-生成正态分布的随机数" class="headerlink" title="5.2 生成正态分布的随机数"></a>5.2 生成正态分布的随机数</h2><p>使用<code>np.random.randn()</code>函数生成服从标准正态分布（均值为0，标准差为1）的随机数。以下是一些示例：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token comment" spellcheck="true"># 生成一个标准正态分布的随机数</span>normal_random <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>randn<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 生成一个标准正态分布的随机数</span><span class="token comment" spellcheck="true"># 生成一个一维数组，包含多个标准正态分布的随机数</span>normal_array <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>randn<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 生成包含5个标准正态分布的随机数的一维数组</span><span class="token comment" spellcheck="true"># 生成一个二维数组，包含多个标准正态分布的随机数</span>normal_matrix <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>randn<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 生成3x2的二维数组，包含标准正态分布的随机数</span></code></pre><h2 id="5-3-生成指定分布的随机数"><a href="#5-3-生成指定分布的随机数" class="headerlink" title="5.3 生成指定分布的随机数"></a>5.3 生成指定分布的随机数</h2><p>NumPy还提供了其他随机数生成函数，可以生成不同分布的随机数，如二项分布、泊松分布等。使用<code>np.random</code>模块来探索这些函数。</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 生成二项分布的随机数</span>binomial_random <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>binomial<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 生成5个符合二项分布的随机数</span><span class="token comment" spellcheck="true"># 生成泊松分布的随机数</span>poisson_random <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>poisson<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 生成5个符合泊松分布的随机数</span></code></pre><p>这些函数非常有用，可以生成符合不同分布的随机数，以用于模拟、实验或统计分析。</p><p>非常好，我们将继续学习<strong>数组高级操作</strong>，包括布尔索引、花式索引、<code>where</code>函数、迭代器等。</p><h1 id="6-数组高级操作"><a href="#6-数组高级操作" class="headerlink" title="6. 数组高级操作"></a>6. 数组高级操作</h1><h2 id="6-1-布尔索引"><a href="#6-1-布尔索引" class="headerlink" title="6.1 布尔索引"></a>6.1 布尔索引</h2><p>布尔索引是一种强大的工具，用于<strong>根据某些条件从数组中选择元素</strong>。创建一个布尔数组，其中每个元素表示与条件相对应的真值，然后使用该布尔数组来选择满足条件的元素。以下是一个示例：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> nparr <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 创建一个布尔数组，满足条件的元素为True</span>condition <span class="token operator">=</span> arr <span class="token operator">></span> <span class="token number">3</span><span class="token comment" spellcheck="true"># 使用布尔索引选择满足条件的元素</span>selected <span class="token operator">=</span> arr<span class="token punctuation">[</span>condition<span class="token punctuation">]</span>  <span class="token comment" spellcheck="true"># 选择大于3的元素</span><span class="token keyword">print</span><span class="token punctuation">(</span>selected<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 输出 [4 5 6]</span></code></pre><h2 id="6-2-花式索引"><a href="#6-2-花式索引" class="headerlink" title="6.2 花式索引"></a>6.2 花式索引</h2><p><strong>花式索引是一种通过指定索引数组来获取数组元素的方式</strong>。使用整数数组来选择元素，从而创建一个新的数组。以下是一个示例：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> nparr <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 创建一个索引数组，用于选择元素</span>indices <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 使用花式索引选择元素</span>selected <span class="token operator">=</span> arr<span class="token punctuation">[</span>indices<span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span>selected<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 输出 [2 4 6]</span></code></pre><h2 id="6-3-where函数"><a href="#6-3-where函数" class="headerlink" title="6.3 where函数"></a>6.3 <code>where</code>函数</h2><p><code>np.where()</code>函数是一个强大的工具，用于<strong>根据条件从数组中选择元素</strong>。它可以返回满足条件的元素的索引或实际的元素值。以下是一些示例：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> nparr <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 使用np.where()选择满足条件的元素的索引</span>indices <span class="token operator">=</span> np<span class="token punctuation">.</span>where<span class="token punctuation">(</span>arr <span class="token operator">></span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 使用np.where()选择满足条件的元素的值 np.where(condition, x, y)</span>values <span class="token operator">=</span> np<span class="token punctuation">.</span>where<span class="token punctuation">(</span>arr <span class="token operator">></span> <span class="token number">3</span><span class="token punctuation">,</span> arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>indices<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 输出 (array([3, 4, 5]),)</span><span class="token keyword">print</span><span class="token punctuation">(</span>values<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true"># 输出 [0 0 0 4 5 6]</span></code></pre><p><code>np.where()</code>函数是一个非常灵活的工具，它可以在不同的条件下返回不同的结果。</p><h2 id="6-4-迭代器"><a href="#6-4-迭代器" class="headerlink" title="6.4 迭代器"></a>6.4 迭代器</h2><p>NumPy数组可以使用Python标准的<code>for</code>循环进行迭代，但更常见的做法是使用NumPy提供的迭代器。以下是一个示例：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> nparr <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 使用NumPy迭代器遍历数组</span><span class="token keyword">for</span> element <span class="token keyword">in</span> np<span class="token punctuation">.</span>nditer<span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span></code></pre><p>继续我们的学习，下一个要点是<strong>数组合并和拆分</strong>，在NumPy中，你可以使用各种函数来将多个数组合并成一个数组，或将一个数组拆分成多个部分。</p><h1 id="7-数组合并和拆分"><a href="#7-数组合并和拆分" class="headerlink" title="7. 数组合并和拆分"></a>7. 数组合并和拆分</h1><h2 id="7-1-数组合并"><a href="#7-1-数组合并" class="headerlink" title="7.1 数组合并"></a>7.1 数组合并</h2><p>在NumPy中，可以用不同的函数来合并多个数组，如 <code>vstack</code>、<code>hstack</code>、<code>concatenate</code> 等。以下是一些示例：</p><ul><li><code>vstack</code> 函数用于垂直堆叠（按行堆叠）多个数组：</li></ul><pre class=" language-python"><code class="language-python">    <span class="token keyword">import</span> numpy <span class="token keyword">as</span> np    arr1 <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    arr2 <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 使用vstack垂直堆叠数组</span>    result <span class="token operator">=</span> np<span class="token punctuation">.</span>vstack<span class="token punctuation">(</span><span class="token punctuation">(</span>arr1<span class="token punctuation">,</span> arr2<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">#输出</span>    <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span><span class="token punctuation">]</span>      <span class="token punctuation">[</span><span class="token number">4</span> <span class="token number">5</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">]</span></code></pre><p>结果是一个新的数组，其中包含两个输入数组按行堆叠在一起。</p><ul><li><code>hstack</code> 函数用于水平堆叠（按列堆叠）多个数组：</li></ul><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> nparr1 <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>arr2 <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 使用hstack水平堆叠数组</span>result <span class="token operator">=</span> np<span class="token punctuation">.</span>hstack<span class="token punctuation">(</span><span class="token punctuation">(</span>arr1<span class="token punctuation">,</span> arr2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#输出[1 2 3 4 5 6]</span></code></pre><p>结果是一个新的数组，其中包含两个输入数组按列堆叠在一起。</p><ul><li><code>concatenate</code> 函数允许你指定要沿着哪个轴合并数组：</li></ul><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token comment" spellcheck="true"># 定义两个一维数组</span>arr1 <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>arr2 <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 使用 concatenate 函数按行合并数组</span>result_row <span class="token operator">=</span> np<span class="token punctuation">.</span>concatenate<span class="token punctuation">(</span><span class="token punctuation">(</span>arr1<span class="token punctuation">,</span> arr2<span class="token punctuation">)</span><span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 将一维数组转换为二维数组</span>arr1_2d <span class="token operator">=</span> arr1<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>arr2_2d <span class="token operator">=</span> arr2<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 使用 concatenate 函数按列合并二维数组</span>result_column <span class="token operator">=</span> np<span class="token punctuation">.</span>concatenate<span class="token punctuation">(</span><span class="token punctuation">(</span>arr1_2d<span class="token punctuation">,</span> arr2_2d<span class="token punctuation">)</span><span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>result_row<span class="token punctuation">)</span>     <span class="token comment" spellcheck="true"># 输出 [1 2 3 4 5 6]</span><span class="token keyword">print</span><span class="token punctuation">(</span>result_column<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 输出 [[1 4]</span>                      <span class="token comment" spellcheck="true">#      [2 5]</span>                      <span class="token comment" spellcheck="true">#      [3 6]]</span></code></pre><h2 id="7-2-数组拆分"><a href="#7-2-数组拆分" class="headerlink" title="7.2 数组拆分"></a>7.2 数组拆分</h2><p>NumPy也提供了函数来拆分数组，如 <code>split</code>、<code>hsplit</code> 和 <code>vsplit</code>。以下是一些示例：</p><ul><li><code>split</code> 函数可以将数组沿指定轴拆分成多个部分：</li></ul><pre><code>np.split(arr, indices_or_sections, axis=0)</code></pre><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token comment" spellcheck="true"># 定义一个一维数组</span>arr <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 将数组分割成两个等份</span>result1 <span class="token operator">=</span> np<span class="token punctuation">.</span>split<span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>result1<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 输出 [array([1, 2, 3, 4, 5]), array([6, 7, 8, 9, 10])]</span><span class="token comment" spellcheck="true"># 在索引 3 和 7 处进行分割</span>result2 <span class="token operator">=</span> np<span class="token punctuation">.</span>split<span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>result2<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 输出 [array([1, 2, 3]), array([4, 5, 6]), array([7, 8, 9, 10])]</span><span class="token comment" spellcheck="true"># 沿着列方向分割二维数组</span>arr_2d <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>result3 <span class="token operator">=</span> np<span class="token punctuation">.</span>split<span class="token punctuation">(</span>arr_2d<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>result3<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 输出 [array([[1], [4], [7]]), array([[2], [5], [8]]), array([[3], [6], [9]])]</span></code></pre><p>结果是一个包含拆分后的数组部分的列表。</p><ul><li><code>hsplit</code> 函数用于水平拆分数组，<code>vsplit</code> 用于垂直拆分数组：</li></ul><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> npmatrix <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 使用hsplit函数水平拆分数组</span>hsplit_parts <span class="token operator">=</span> np<span class="token punctuation">.</span>hsplit<span class="token punctuation">(</span>matrix<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 使用vsplit函数垂直拆分数组</span>vsplit_parts <span class="token operator">=</span> np<span class="token punctuation">.</span>vsplit<span class="token punctuation">(</span>matrix<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>hsplit_parts<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>vsplit_parts<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 输出</span><span class="token punctuation">[</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>       <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span>       <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span>       <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span>       <span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span>       <span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span>       <span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">[</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span></code></pre><p>这些函数允许你按照指定轴将数组拆分为多个部分。</p><h1 id="8-广义表与轴"><a href="#8-广义表与轴" class="headerlink" title="8. 广义表与轴"></a>8. 广义表与轴</h1><h2 id="8-1-广义表"><a href="#8-1-广义表" class="headerlink" title="8.1 广义表"></a>8.1 广义表</h2><p>广义表是一种由嵌套列表或多维数组组成的数据结构，它可以表示树状、分层结构的数据。在NumPy中，多维数组通常被视为广义表，其中每个维度对应于数据的一个层次结构。</p><p>例如，考虑一个包含学生成绩的二维数组，其中第一个维度表示不同的课程，第二个维度表示不同的学生。这可以被视为广义表，其中每个课程有一组学生成绩。以下是一个示例：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token comment" spellcheck="true"># 创建包含学生成绩的二维数组</span>grades <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">85</span><span class="token punctuation">,</span> <span class="token number">92</span><span class="token punctuation">,</span> <span class="token number">78</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                  <span class="token punctuation">[</span><span class="token number">90</span><span class="token punctuation">,</span> <span class="token number">88</span><span class="token punctuation">,</span> <span class="token number">80</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                  <span class="token punctuation">[</span><span class="token number">79</span><span class="token punctuation">,</span> <span class="token number">85</span><span class="token punctuation">,</span> <span class="token number">88</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># grades 是一个广义表，其中每行表示一个课程的成绩</span></code></pre><h2 id="8-2-轴"><a href="#8-2-轴" class="headerlink" title="8.2 轴"></a>8.2 轴</h2><p>在NumPy中，轴是表示数组的维度的对象。对于二维数组，通常有两个轴：0轴表示行，1轴表示列。对于三维数组，会有三个轴，以此类推。</p><p>轴在NumPy中非常重要，因为它们允许你在多维数组中执行各种操作。例如，可以使用轴来计算每一行或每一列的总和、平均值等。</p><p>以下是一些示例：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> npmatrix <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                  <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                  <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 计算每一行的总和（沿0轴）</span>row_sum <span class="token operator">=</span> np<span class="token punctuation">.</span>sum<span class="token punctuation">(</span>matrix<span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 计算每一列的总和（沿1轴）</span>column_sum <span class="token operator">=</span> np<span class="token punctuation">.</span>sum<span class="token punctuation">(</span>matrix<span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>row_sum<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 输出 [12 15 18]</span><span class="token keyword">print</span><span class="token punctuation">(</span>column_sum<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 输出 [ 6 15 24]</span></code></pre><p>理解NumPy数组的内存布局对于数组的性能优化至关重要。NumPy支持两种主要的内存布局方式：C风格和Fortran风格，并提供<code>strides</code>属性来自定义数组的内存布局。让我们详细了解这些概念。</p><h1 id="9-数组的内存布局"><a href="#9-数组的内存布局" class="headerlink" title="9. 数组的内存布局"></a>9. 数组的内存布局</h1><h2 id="9-1-C风格内存布局"><a href="#9-1-C风格内存布局" class="headerlink" title="9.1 C风格内存布局"></a>9.1 C风格内存布局</h2><p>C风格内存布局是NumPy中的默认方式，它与大多数编程语言的内存布局一致，数据以行为主存储。在C风格内存布局中，数组的元素在内存中是按行存储的，即相邻元素在相邻内存位置中。</p><p>下面是一个示例：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> nparr <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span>flags<span class="token punctuation">[</span><span class="token string">'C_CONTIGUOUS'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 输出 True，表示C风格内存布局</span></code></pre><h2 id="9-2-Fortran风格内存布局"><a href="#9-2-Fortran风格内存布局" class="headerlink" title="9.2 Fortran风格内存布局"></a>9.2 Fortran风格内存布局</h2><p>Fortran风格内存布局与C风格相反，它以列为主存储数据。在Fortran风格内存布局中，数组的元素在内存中是按列存储的，即相邻元素在相邻内存位置中。</p><p>下面是一个示例：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> nparr <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span>flags<span class="token punctuation">[</span><span class="token string">'F_CONTIGUOUS'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 输出 False，表示不是Fortran风格内存布局</span></code></pre><h2 id="9-3-自定义数组内存布局"><a href="#9-3-自定义数组内存布局" class="headerlink" title="9.3 自定义数组内存布局"></a>9.3 自定义数组内存布局</h2><p>NumPy还允许自定义数组的内存布局，通过使用<code>strides</code>属性。<code>strides</code>是一个元组，指定了在每个维度上跨越数组元素所需的字节数。可以使用<code>strides</code>属性来创建一个不连续的数组，以满足特定的需求。</p><p>下面是一个示例，创建一个具有自定义内存布局的数组：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token comment" spellcheck="true"># 创建一个自定义内存布局的数组</span>arr <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">13</span><span class="token punctuation">,</span> <span class="token number">14</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">,</span> <span class="token number">17</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span>np<span class="token punctuation">.</span>int32<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 设置自定义strides，使数组在每行之间有空隙</span>arr<span class="token punctuation">.</span>strides <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">24</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 每行跨越24字节，每个元素之间跨越4字节</span><span class="token keyword">print</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span></code></pre><p>通过自定义<code>strides</code>属性，可以创建特定内存布局的数组，以满足性能和数据处理需求。</p><h1 id="10结构化数据"><a href="#10结构化数据" class="headerlink" title="10结构化数据"></a>10结构化数据</h1><p>结构化数组是NumPy中的一个重要概念，它允许创建类似表格或数据库中的数据结构，每个元素都包含多个字段，可以使用字段名或下标来访问和操作数据。结构化数组通常用于处理异构数据，例如，每个元素包含不同类型的数据，如字符串、整数、浮点数等。</p><p>以下是如何创建和使用结构化数组的基本示例：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token comment" spellcheck="true"># 创建一个结构化数组，定义字段名和数据类型</span>data_type <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">,</span> <span class="token string">'U10'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'age'</span><span class="token punctuation">,</span> int<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'weight'</span><span class="token punctuation">,</span> float<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 创建一个空的结构化数组</span>people <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span>data_type<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 添加数据到结构化数组</span>person1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">'Alice'</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">,</span> <span class="token number">55.5</span><span class="token punctuation">)</span>person2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">'Bob'</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">68.2</span><span class="token punctuation">)</span>person3 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">'Charlie'</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">,</span> <span class="token number">61.8</span><span class="token punctuation">)</span>people <span class="token operator">=</span> np<span class="token punctuation">.</span>append<span class="token punctuation">(</span>people<span class="token punctuation">,</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span>person1<span class="token punctuation">,</span> person2<span class="token punctuation">,</span> person3<span class="token punctuation">]</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span>data_type<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 访问结构化数组中的数据</span><span class="token keyword">print</span><span class="token punctuation">(</span>people<span class="token punctuation">[</span><span class="token string">'name'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 输出 ['Alice' 'Bob' 'Charlie']</span><span class="token keyword">print</span><span class="token punctuation">(</span>people<span class="token punctuation">[</span><span class="token string">'age'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true"># 输出 [25 30 22]</span><span class="token keyword">print</span><span class="token punctuation">(</span>people<span class="token punctuation">[</span><span class="token string">'weight'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 输出 [55.5 68.2 61.8]</span></code></pre><p>在这个示例中，我们首先定义了结构化数组的数据类型，其中包含三个字段：’name’（字符串类型，最大长度为10），’age’（整数类型），’weight’（浮点数类型）。然后，我们创建了一个空的结构化数组，并向其中添加数据，最后通过字段名访问数组中的数据。</p><h1 id="11矩阵计算"><a href="#11矩阵计算" class="headerlink" title="11矩阵计算"></a>11矩阵计算</h1><p>NumPy提供了专门的矩阵类<code>matrix</code>，以及针对矩阵的一些特定运算函数，使矩阵计算更方便。虽然NumPy中的多维数组（<code>ndarray</code>）可以执行矩阵计算，但<code>matrix</code>类提供了更直观的语法和一些额外的矩阵运算功能。</p><p>以下是一些关于矩阵计算的基本示例：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token comment" spellcheck="true"># 创建矩阵</span>matrix1 <span class="token operator">=</span> np<span class="token punctuation">.</span>matrix<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>matrix2 <span class="token operator">=</span> np<span class="token punctuation">.</span>matrix<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 矩阵乘法</span>result <span class="token operator">=</span> matrix1 <span class="token operator">*</span> matrix2<span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 求逆矩阵</span>inverse_matrix <span class="token operator">=</span> matrix1<span class="token punctuation">.</span>I<span class="token keyword">print</span><span class="token punctuation">(</span>inverse_matrix<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 矩阵转置</span>transpose_matrix <span class="token operator">=</span> matrix1<span class="token punctuation">.</span>T<span class="token keyword">print</span><span class="token punctuation">(</span>transpose_matrix<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 输出</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">19</span> <span class="token number">22</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token number">43</span> <span class="token number">50</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">.</span>   <span class="token number">1</span><span class="token punctuation">.</span> <span class="token punctuation">]</span> <span class="token punctuation">[</span> <span class="token number">1.5</span> <span class="token operator">-</span><span class="token number">0.5</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span> <span class="token number">3</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token number">2</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">]</span></code></pre><p>在上述示例中，首先创建了两个矩阵<code>matrix1</code>和<code>matrix2</code>，然后进行了矩阵乘法、求逆矩阵和矩阵转置的操作。<code>matrix</code>类提供了更直观的运算符重载，使矩阵计算更容易理解。</p><p>虽然<code>matrix</code>类在某些情况下很有用，但在实际应用中，NumPy多维数组（<code>ndarray</code>）仍然是更通用和灵活的数据结构，因为它们支持更多的数学和科学计算操作，并且在生态系统中更为广泛使用。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>numpy官网：<a href="https://numpy.org/doc/stable/index.html" target="_blank" rel="noopener">https://numpy.org/doc/stable/index.html</a> </p>]]></content>
      
      
      <categories>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据分析 </tag>
            
            <tag> python </tag>
            
            <tag> numpy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python生成器与yield</title>
      <link href="/bian-cheng-python-sheng-cheng-qi-yu-yield.html"/>
      <url>/bian-cheng-python-sheng-cheng-qi-yu-yield.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在Python编程世界中，有一种神奇的机制，它能够以惊人的效率管理数据流，同时又占用极少的内存空间。这个机制就是生成器，而它的魔力关键字是”yield”。生成器和yield在处理大型数据集或无限序列时，可以成为性能的保障，同时让代码变得更加优雅。无需担心内存泄漏或效率问题，生成器和yield将为你打开崭新的编程大门。</p><h1 id="什么是生成器"><a href="#什么是生成器" class="headerlink" title="什么是生成器"></a>什么是生成器</h1><p>在Python中，生成器（Generator）是一种特殊类型的迭代器，它们以一种独特的方式生成值。与普通的列表不同，生成器并不一次性将所有值存储在内存中，而是按需生成并返回数据。这使得生成器在处理大型数据集或需要无限生成数据的情况下非常有用。</p><h2 id="生成器和普通列表的区别"><a href="#生成器和普通列表的区别" class="headerlink" title="生成器和普通列表的区别"></a>生成器和普通列表的区别</h2><p>生成器和普通的列表之间存在一些关键的区别：</p><ul><li><p><strong>内存占用</strong>：列表将所有元素存储在内存中，占据大量空间，尤其在处理大型数据集时。生成器仅在需要时生成数据，因此占用的内存非常有限。</p></li><li><p><strong>迭代方式</strong>：生成器是一种迭代器，通过<code>for</code>循环逐个生成值，而列表可以一次性获取所有值。这使生成器在处理大数据集或无限序列时更具优势。</p></li><li><p><strong>延迟计算</strong>：生成器的值是按需计算的，而不是提前计算和存储的。这使得生成器能够处理无限序列，例如斐波那契数列，而列表则不适用于这种情况。</p></li></ul><h2 id="生成器的优势，包括节省空间和提高效率"><a href="#生成器的优势，包括节省空间和提高效率" class="headerlink" title="生成器的优势，包括节省空间和提高效率"></a>生成器的优势，包括节省空间和提高效率</h2><p>生成器的优势在于其能力以及如何节省空间和提高效率：</p><ul><li><p><strong>节省内存</strong>：生成器一次只生成一个值，不需要在内存中保存整个序列，因此适用于处理大型数据集或无限数据流。</p></li><li><p><strong>高效迭代</strong>：生成器在迭代时能够以非常高效的方式生成数据，因为它们按需生成值，而不是预先计算和存储所有值。</p></li><li><p><strong>惰性计算</strong>：生成器允许你以惰性计算的方式处理数据，只有在需要时才会生成新值，这在某些情况下可以提高性能。</p></li><li><p><strong>支持无限序列</strong>：生成器可以轻松处理无限序列，例如自然数序列，而列表不适合。</p></li></ul><h2 id="生成器使用与常规代码的执行时间对比"><a href="#生成器使用与常规代码的执行时间对比" class="headerlink" title="生成器使用与常规代码的执行时间对比"></a>生成器使用与常规代码的执行时间对比</h2><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> time<span class="token keyword">def</span> <span class="token function">calculate_time</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 定义一个计算时间的函数，该函数接受一个函数作为参数，并返回该函数执行所需要的时间</span>    start_time <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 记录开始时间</span>    func<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 调用传入的函数</span>    end_time <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 记录结束时间</span>    execution_time <span class="token operator">=</span> end_time <span class="token operator">-</span> start_time  <span class="token comment" spellcheck="true"># 计算函数执行所需的时间</span>    <span class="token keyword">return</span> execution_time  <span class="token comment" spellcheck="true"># 返回时间差</span><span class="token comment" spellcheck="true"># 接下来是示例函数，分别使用生成器和列表进行迭代，用来比较它们的执行效率</span><span class="token keyword">def</span> <span class="token function">calculate_with_generator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    generator <span class="token operator">=</span> <span class="token punctuation">(</span>i <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1000000</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 定义一个生成器</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> generator<span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># 遍历生成器中的所有元素</span>        <span class="token keyword">pass</span>  <span class="token keyword">def</span> <span class="token function">calculate_without_generator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    lst <span class="token operator">=</span> <span class="token punctuation">[</span>i <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1000000</span><span class="token punctuation">)</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true"># 定义一个列表</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> lst<span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># 遍历列表中的所有元素</span>        <span class="token keyword">pass</span>  time_with_generator <span class="token operator">=</span> calculate_time<span class="token punctuation">(</span>calculate_with_generator<span class="token punctuation">)</span>time_without_generator <span class="token operator">=</span> calculate_time<span class="token punctuation">(</span>calculate_without_generator<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"使用生成器的函数执行时间：{time_with_generator} 秒"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"不使用生成器的函数执行时间：{time_without_generator} 秒"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 输出结果</span>使用生成器的函数执行时间：<span class="token number">0.00123</span> 秒不使用生成器的函数执行时间：<span class="token number">0.01567</span> 秒</code></pre><p>从执行的时间上来看，使用生成器的执行时间相对更少， 生成器是根据一定的规律算法生成的，当我们去遍历它的时候，它可以通过特定的算法不断的推算出相应的元素，边运行边推算结果，从而节省了很多空间。 </p><h1 id="yield关键词及其作用"><a href="#yield关键词及其作用" class="headerlink" title="yield关键词及其作用"></a><code>yield</code>关键词及其作用</h1><p><code>yield</code> 是生成器函数中的一个关键词，它在生成器的定义和行为中发挥着关键作用。<strong><code>yield</code> 允许你在生成器函数中产生一个值，同时保持函数的状态，以便在之后的迭代中从上次停止的地方继续执行</strong>。</p><h3 id="yield-与-return-的异同"><a href="#yield-与-return-的异同" class="headerlink" title="yield 与 return 的异同"></a><code>yield</code> 与 <code>return</code> 的异同</h3><p><code>yield</code> 和 <code>return</code> 是在函数中用于返回值的两个关键词，但它们之间存在一些重要的异同点：</p><ul><li><strong><code>return</code></strong>：<ul><li>用于从函数中返回一个值。</li><li>当函数执行 <code>return</code> 后，函数的状态会被完全销毁。</li><li>函数的下次调用会重新开始执行，从头开始。</li></ul></li><li><strong><code>yield</code></strong>：<ul><li>用于在生成器函数中产生一个值，并在函数的状态中保持位置。</li><li>函数执行 <code>yield</code> 后，状态会被保持，函数暂停，等待下一次迭代。</li><li>函数的下一次迭代会从上次暂停的地方继续执行，保持了函数的上下文。</li></ul></li></ul><h3 id="异同代码示例"><a href="#异同代码示例" class="headerlink" title="异同代码示例"></a>异同代码示例</h3><p>当使用<code>yield</code>关键字时，生成器的行为与常规函数有显著不同。以下是一个示例</p><p><strong>常规函数</strong>：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">normal_numbers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    numbers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> n <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        numbers<span class="token punctuation">.</span>append<span class="token punctuation">(</span>n<span class="token punctuation">)</span>    <span class="token keyword">return</span> numbersresult <span class="token operator">=</span> normal_numbers<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span></code></pre><p><strong>使用<code>yield</code>的生成器函数</strong>：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">generator_numbers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    n <span class="token operator">=</span> <span class="token number">1</span>    <span class="token keyword">while</span> n <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">:</span>        <span class="token keyword">yield</span> n        n <span class="token operator">+=</span> <span class="token number">1</span>gen <span class="token operator">=</span> generator_numbers<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> num <span class="token keyword">in</span> gen<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span></code></pre><p>在常规函数中，我们使用一个列表来存储自然数，然后返回整个列表。在生成器函数中，我们使用<code>yield</code>来逐个生成自然数，而不是一次性生成整个列表。当迭代生成器时，我们会逐个获取并打印自然数。</p><p>这两个示例的输出结果相同，都是打印出自然数1到5，但它们的实现方式不同。生成器函数使用<code>yield</code>可以避免一次性占用大量内存，特别在处理大数据集时，这种差异将会更加显著。</p><h2 id="yield-在生成器函数中的作用"><a href="#yield-在生成器函数中的作用" class="headerlink" title="yield 在生成器函数中的作用"></a><code>yield</code> 在生成器函数中的作用</h2><p><code>yield</code> 在生成器函数中发挥着重要作用：</p><ul><li><p><strong>中途暂停函数执行</strong>：当生成器函数执行到 <code>yield</code> 语句时，函数的状态被冻结，函数暂停执行，当前生成的值被返回给调用者。这使得生成器能够将值逐个生成，而不是一次性生成整个序列。生成器的状态被保留，以便下次调用时能够从 <code>yield</code> 语句之后的代码行继续执行。</p></li><li><p><strong>从上次暂停的地方继续执行</strong>：生成器函数的每次调用都会从上一次 <code>yield</code> 语句的位置继续执行，而不是从头开始。这允许生成器在迭代中继续生成值，同时保持函数内部变量和状态。</p></li></ul><h1 id="如何使用生成器和-yield"><a href="#如何使用生成器和-yield" class="headerlink" title="如何使用生成器和 yield"></a>如何使用生成器和 <code>yield</code></h1><h2 id="使用-next-方法遍历生成器"><a href="#使用-next-方法遍历生成器" class="headerlink" title="使用 next 方法遍历生成器"></a>使用 <code>next</code> 方法遍历生成器</h2><p>生成器可以使用 <code>next</code> 方法逐个获取值。以下是一个示例：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">simple_generator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">yield</span> <span class="token number">1</span>    <span class="token keyword">yield</span> <span class="token number">2</span>    <span class="token keyword">yield</span> <span class="token number">3</span>gen <span class="token operator">=</span> simple_generator<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>next<span class="token punctuation">(</span>gen<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 输出 1</span><span class="token keyword">print</span><span class="token punctuation">(</span>next<span class="token punctuation">(</span>gen<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 输出 2</span><span class="token keyword">print</span><span class="token punctuation">(</span>next<span class="token punctuation">(</span>gen<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 输出 3</span></code></pre><p>在上述示例中，<code>simple_generator</code> 是一个生成器函数，它使用 <code>yield</code> 返回三个值。我们创建生成器对象 <code>gen</code>，然后使用 <code>next</code> 方法逐个获取这些值。</p><blockquote><p>当生成器没有更多的值可供生成时，再次调用 <code>next</code> 方法会引发 <code>StopIteration</code> 异常。通常，我们使用 <code>for</code> 循环来遍历生成器，这样可以自动处理异常。</p></blockquote><h2 id="yield-后面可以跟常用的数据类型，如字符串、整数和字典"><a href="#yield-后面可以跟常用的数据类型，如字符串、整数和字典" class="headerlink" title="yield 后面可以跟常用的数据类型，如字符串、整数和字典"></a><code>yield</code> 后面可以跟常用的数据类型，如字符串、整数和字典</h2><p><code>yield</code> 后面可以跟各种数据类型，包括字符串、整数、字典等。这使得生成器函数非常灵活，可以用于生成各种类型的数据。以下是一个示例：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">mixed_data_generator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">yield</span> <span class="token string">"Hello, World"</span>    <span class="token keyword">yield</span> <span class="token number">42</span>    <span class="token keyword">yield</span> <span class="token punctuation">{</span><span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"Alice"</span><span class="token punctuation">,</span> <span class="token string">"age"</span><span class="token punctuation">:</span> <span class="token number">30</span><span class="token punctuation">}</span>gen <span class="token operator">=</span> mixed_data_generator<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>next<span class="token punctuation">(</span>gen<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 输出 "Hello, World"</span><span class="token keyword">print</span><span class="token punctuation">(</span>next<span class="token punctuation">(</span>gen<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 输出 42</span><span class="token keyword">print</span><span class="token punctuation">(</span>next<span class="token punctuation">(</span>gen<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 输出 {"name": "Alice", "age": 30}</span></code></pre><h2 id="制作生成器表达式"><a href="#制作生成器表达式" class="headerlink" title="制作生成器表达式"></a>制作生成器表达式</h2><p>类似于列表推导式，Python 也支持生成器表达式，这是一种创建生成器的简洁方式。生成器表达式使用小括号 <code>()</code>，而不是列表推导式的中括号 <code>[]</code>。以下是一个示例：</p><pre class=" language-python"><code class="language-python">gen <span class="token operator">=</span> <span class="token punctuation">(</span>x <span class="token operator">**</span> <span class="token number">2</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">for</span> val <span class="token keyword">in</span> gen<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span></code></pre><p>在这个示例中，我们使用生成器表达式创建了一个生成平方数的生成器。生成器表达式非常适合在一行代码中创建简单的生成器。</p><h1 id="生成器和-yield-的应用"><a href="#生成器和-yield-的应用" class="headerlink" title="生成器和 yield 的应用"></a>生成器和 <code>yield</code> 的应用</h1><h2 id="生成大规模数据时的优势"><a href="#生成大规模数据时的优势" class="headerlink" title="生成大规模数据时的优势"></a>生成大规模数据时的优势</h2><ul><li><p><strong>节省内存</strong>：生成器一次只生成一个值，而不是将整个数据集加载到内存中。这对于处理大型数据集非常重要，因为它可以避免占用过多内存。</p></li><li><p><strong>提高效率</strong>：生成器能够按需生成数据，这意味着在迭代过程中不需要计算和存储所有值。这可以显著提高程序的效率，特别是在处理大数据集时。</p></li><li><p><strong>处理无限序列</strong>：生成器可以处理无限序列，例如自然数序列或无限的传感器数据流。这是传统数据结构无法做到的。</p></li></ul><h2 id="对于流处理和协同程序的支持"><a href="#对于流处理和协同程序的支持" class="headerlink" title="对于流处理和协同程序的支持"></a>对于流处理和协同程序的支持</h2><ul><li><p><strong>流处理</strong>：生成器可以用于处理数据流，例如日志文件、网络数据流或传感器数据。你可以一次处理一部分数据，而不需要加载整个数据集。</p></li><li><p><strong>协同程序</strong>：生成器可以用于实现协同程序，允许多个任务在不同生成器之间交替执行。这有助于编写高效的并发程序，例如网络爬虫或数据处理流水线。</p></li></ul><h2 id="实现自定义的迭代器"><a href="#实现自定义的迭代器" class="headerlink" title="实现自定义的迭代器"></a>实现自定义的迭代器</h2><p>生成器和 <code>yield</code> 还可以用于创建自定义的迭代器，使你能够遍历自定义数据结构，例如树、图或复杂对象。这些自定义迭代器可以根据需要生成数据，提供了灵活性和可读性。</p><p>以下是一个示例，使用生成器创建自定义迭代器，以遍历树结构：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">TreeNode</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>value <span class="token operator">=</span> value  <span class="token comment" spellcheck="true"># value 存储节点的值</span>        self<span class="token punctuation">.</span>children <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true"># children 存储该节点的子节点列表</span>    <span class="token keyword">def</span> <span class="token function">add_child</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> child<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>children<span class="token punctuation">.</span>append<span class="token punctuation">(</span>child<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 添加一个子节点</span><span class="token comment" spellcheck="true"># 定义遍历树的生成器函数</span><span class="token keyword">def</span> <span class="token function">traverse_tree</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">yield</span> node<span class="token punctuation">.</span>value  <span class="token comment" spellcheck="true"># 首先生成当前节点的值</span>    <span class="token keyword">for</span> child <span class="token keyword">in</span> node<span class="token punctuation">.</span>children<span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># 然后依次生成它的每个子节点的值</span>        <span class="token keyword">yield</span> <span class="token keyword">from</span> traverse_tree<span class="token punctuation">(</span>child<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 创建一个树结构</span>root <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 树的根节点是 1</span>child1 <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>child2 <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>root<span class="token punctuation">.</span>add_child<span class="token punctuation">(</span>child1<span class="token punctuation">)</span>root<span class="token punctuation">.</span>add_child<span class="token punctuation">(</span>child2<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 将两个节点添加到根节点下</span>gen <span class="token operator">=</span> traverse_tree<span class="token punctuation">(</span>root<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 遍历整棵树，并生成一个生成器对象</span><span class="token keyword">for</span> value <span class="token keyword">in</span> gen<span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># 遍历生成器中的所有元素</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 打印元素的值</span></code></pre><p>在这个示例中，我们创建了一个树结构并使用生成器函数 <code>traverse_tree</code> 遍历树中的节点。生成器允许我们以递归的方式遍历树，同时保持函数状态，从上次暂停的地方继续执行。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>Python中的生成器和yield关键词是一种高效的编程方式，通过节省空间和提高效率，可以大大提高代码的执行效率。在Python编程中，生成器和yield的应用非常广泛，在处理大规模数据、流处理和协同程序等方面都具有重要作用。因此，掌握生成器和yield的用法，对于提高Python编程水平和效率是非常重要的。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> yield </tag>
            
            <tag> Generator </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>探索pyhon的面向对象编程</title>
      <link href="/bian-cheng-python-mian-xiang-dui-xiang.html"/>
      <url>/bian-cheng-python-mian-xiang-dui-xiang.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在现代编程世界中，面向对象编程（OOP）已经成为一种广泛使用的编程范式。它的核心思想是<strong>将现实世界中的事物抽象为对象，这些对象具有属性和方法，可以相互协作和交互</strong>。Python，作为一种多范式编程语言，强调了面向对象编程在其编程生态中的重要性。在本文中，我们将深入探讨Python中的OOP概念，并通过示例代码演示如何创建类、定义属性和方法，以及应用封装、继承和多态等核心概念。</p><p><strong>面向对象编程不仅仅是一种编程范式，它也是一种思考问题和解决问题的方式</strong>。通过OOP，我们可以更好地组织代码，提高代码的可维护性和可扩展性，以及更好地模拟现实世界中的关系和行为。在接下来的文章中，我们将逐步探索Python中的OOP，帮助您理解其重要性以及如何运用这一概念来构建更健壮和灵活的应用程序。</p><p>在Python中，我们将学习如何创建类（Class），定义类的属性和方法，以及如何应用封装、继承和多态等OOP特征。无论您是初学者还是有一定经验的Python开发者，本文都将为您提供有关OOP的清晰理解，以及如何在Python中充分利用这一编程范式的实际方法。</p><p>当我们谈论面向对象编程（OOP），我们首先需要了解对象、属性和方法的概念。在这一节中，我们将解释这些概念，并提供示例代码来说明如何在Python中定义一个简单的类，并创建对象。</p><h1 id="对象、属性和方法"><a href="#对象、属性和方法" class="headerlink" title="对象、属性和方法"></a>对象、属性和方法</h1><ul><li><strong>对象</strong>：<strong>在面向对象编程中，对象是现实世界中的事物的抽象表示</strong>。这些对象可以是<u>具体的物体</u>（如一辆汽车）或<u>抽象的概念</u>（如一个银行账户）。对象可以有自己的状态（属性）和行为（方法）。</li></ul><blockquote><p>对象=属性+方法</p></blockquote><ul><li><strong>属性</strong>：<strong>属性是对象的特征或状态</strong>。它们描述了对象的特定性质。例如，对于一辆汽车对象，属性可以包括颜色、制造商和速度。</li><li><strong>方法</strong>：<strong>方法是对象可以执行的操作或行为</strong>。它们定义了对象的行为。对于一辆汽车对象，方法可以包括启动、停止和加速。</li></ul><p><strong>示例代码：定义一个简单的类和创建对象</strong></p><p>通过一个简单的示例来说明对象、属性和方法的概念。以下为创建一个代表汽车的类，其中包括汽车的属性和方法。</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 定义一个简单的Car类</span><span class="token keyword">class</span> <span class="token class-name">Car</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 初始化方法，用于设置汽车的属性</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> make<span class="token punctuation">,</span> model<span class="token punctuation">,</span> year<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>make <span class="token operator">=</span> make  <span class="token comment" spellcheck="true"># 制造商</span>        self<span class="token punctuation">.</span>model <span class="token operator">=</span> model  <span class="token comment" spellcheck="true"># 型号</span>        self<span class="token punctuation">.</span>year <span class="token operator">=</span> year  <span class="token comment" spellcheck="true"># 出厂年份</span>        self<span class="token punctuation">.</span>speed <span class="token operator">=</span> <span class="token number">0</span>  <span class="token comment" spellcheck="true"># 初始速度</span>    <span class="token comment" spellcheck="true"># 定义加减速度两个方法</span>    <span class="token comment" spellcheck="true"># 加速方法</span>    <span class="token keyword">def</span> <span class="token function">accelerate</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> increment<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>speed <span class="token operator">+=</span> increment    <span class="token comment" spellcheck="true"># 减速方法</span>    <span class="token keyword">def</span> <span class="token function">decelerate</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> decrement<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>speed <span class="token operator">-=</span> decrement    <span class="token comment" spellcheck="true"># 获取当前速度</span>    <span class="token keyword">def</span> <span class="token function">get_speed</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>speed<span class="token comment" spellcheck="true"># 创建Car类的对象</span>my_car <span class="token operator">=</span> Car<span class="token punctuation">(</span><span class="token string">"Lamborghini"</span><span class="token punctuation">,</span> <span class="token string">"Aventador"</span><span class="token punctuation">,</span> <span class="token number">2023</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 访问对象的属性</span><span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"制造商：{my_car.make}"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"型号：{my_car.model}"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"出厂年份：{my_car.year}"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 使用对象的方法</span>my_car<span class="token punctuation">.</span>accelerate<span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"当前速度：{my_car.get_speed()} km/h"</span><span class="token punctuation">)</span>my_car<span class="token punctuation">.</span>decelerate<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"当前速度：{my_car.get_speed()} km/h"</span><span class="token punctuation">)</span></code></pre><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 以上print的输出如下</span>制造商：Lamborghini型号：Aventador出厂年份：<span class="token number">2023</span>当前速度：<span class="token number">20</span> km<span class="token operator">/</span>h当前速度：<span class="token number">15</span> km<span class="token operator">/</span>h</code></pre><p>在上面的示例中，我们首先定义了一个名为<code>Car</code>的类，该类具有<code>make</code>、<code>model</code>、<code>year</code>和<code>speed</code>等属性，以及<code>accelerate</code>、<code>decelerate</code>和<code>get_speed</code>等方法。然后，创建了一个<code>my_car</code>对象，访问对象的属性和调用对象的方法。</p><blockquote><p>在Python类中规定，<strong>函数的第一个参数是实例对象本身，并且约定俗成，名字写为self</strong>。其作用相当于java中的this，表示当前类的对象，可以调用当前类中的属性和方法。</p><p><strong>self 简单的说就是把 class 中 定义的 变量和函数 变成 实例变量和实例函数</strong>，作为类 class 的成员，使得成员间能互相调用，而不需要从外部调用 数据（即变量）和 方法（即 函数），以实现数据的封装</p></blockquote><p>这个简单的示例帮助我们理解了对象、属性和方法的基本概念，并展示了如何在Python中创建类和对象。</p><h1 id="类的定义和命名规则"><a href="#类的定义和命名规则" class="headerlink" title="类的定义和命名规则"></a>类的定义和命名规则</h1><ul><li><strong>定义一个类</strong>：要定义一个类，可以使用<code>class</code>关键字，后面跟着类的名称，然后是一个冒号。类的主体通常包含类的属性和方法定义。以下是一个简单的类定义示例：</li></ul><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">MyClass</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 类的属性和方法定义在这里</span>    <span class="token keyword">pass</span></code></pre><ul><li><strong>类名通常以大写字母开头</strong>：按照通用的Python命名规则，<strong>类名通常以大写字母开头</strong>，使用驼峰命名法（每个单词的首字母大写，没有下划线）。这有助于使类名在代码中更容易识别。</li></ul><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Car</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 类名通常以大写字母开头</span>    <span class="token keyword">pass</span></code></pre><ul><li><strong>函数名通常以小写字母开头的命名规则</strong>：在类中定义的<strong>方法（函数）通常以小写字母开头</strong>，并可以使用下划线分隔单词。这是一种命名规则，有助于提高代码的可读性。</li></ul><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Car</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">start_engine</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 方法名通常以小写字母开头，使用下划线分隔单词</span>        <span class="token keyword">pass</span></code></pre><h1 id="面向对象的特征"><a href="#面向对象的特征" class="headerlink" title="面向对象的特征"></a>面向对象的特征</h1><p><strong>封装（Encapsulation）、继承（Inheritance）和多态（Polymorphism）</strong>是面向对象编程（OOP）的三个主要特征。</p><ol><li>封装（Encapsulation）：封装是指将数据和操作数据的方法绑定在一起，形成一个类。通过封装，我们可以隐藏具体的实现细节，只对外部提供公共接口，从而提高代码的可读性和可维护性。封装还能够保护数据的安全性，控制数据的访问权限，防止意外的修改。</li><li>继承（Inheritance）：继承是指一个类可以派生出子类，子类可以继承父类的属性和方法。通过继承，子类可以重用父类的代码，并且可以在不修改父类的情况下扩展或修改父类的行为。继承还能够建立类之间的层次关系，实现代码的组织和结构化，提高代码的复用性。</li><li>多态（Polymorphism）：多态是指同一个类的对象在不同的情况下可以表现出不同的行为。多态能够增加代码的灵活性和可扩展性。通过多态，我们可以使用统一的接口来操作不同的对象，而无需关心具体对象的类型。多态使得程序的设计和扩展更加容易，能够提高代码的可读性和可维护性。</li></ol><h1 id="OOP-封装"><a href="#OOP-封装" class="headerlink" title="OOP-封装"></a>OOP-封装</h1><p><strong>封装是一种将数据（属性）和操作数据的方法（方法）捆绑在一起的机制</strong>。它允许我们将数据隐藏在类内部，只通过类的公共接口来访问数据。这意味着<strong>外部代码无法直接访问或修改类的内部数据，而必须使用类的方法来操作数据</strong>。这提供了以下几个好处：</p><ol><li><p><strong>数据保护</strong>：通过封装，我们可以将数据保护起来，防止外部代码不当地修改或破坏数据的完整性。</p></li><li><p><strong>数据隔离</strong>：封装允许类的实现细节被隐藏，从而降低了代码的复杂性，并提供了一个清晰的界面，使外部代码更容易使用。</p></li><li><p><strong>代码可维护性</strong>：封装有助于提高代码的可维护性，因为如果类的内部实现需要改变，只需更改类的方法，而不影响使用类的外部代码。</p></li></ol><p><strong>示例代码：使用封装实现数据保护</strong></p><p>以下示例将展示封装的作用，创建一个类，代表一个简单的银行账户，并使用封装来保护账户余额。外部代码只能通过类的方法来访问和修改余额。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">BankAccount</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> account_holder<span class="token punctuation">,</span> initial_balance<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>account_holder <span class="token operator">=</span> account_holder        self<span class="token punctuation">.</span>__balance <span class="token operator">=</span> initial_balance  <span class="token comment" spellcheck="true"># 使用双下划线前缀进行数据封装</span>    <span class="token keyword">def</span> <span class="token function">deposit</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> amount<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 存款</span>        <span class="token keyword">if</span> amount <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>__balance <span class="token operator">+=</span> amount    <span class="token keyword">def</span> <span class="token function">withdraw</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> amount<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 取款</span>        <span class="token keyword">if</span> <span class="token number">0</span> <span class="token operator">&lt;</span> amount <span class="token operator">&lt;=</span> self<span class="token punctuation">.</span>__balance<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>__balance <span class="token operator">-=</span> amount        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"余额不足"</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">get_balance</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>__balance  <span class="token comment" spellcheck="true"># 通过方法访问和返回封装的数据</span><span class="token comment" spellcheck="true"># 创建银行账户对象</span>my_account <span class="token operator">=</span> BankAccount<span class="token punctuation">(</span><span class="token string">"Bevis"</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 尝试直接访问__balance（会引发AttributeError）</span><span class="token comment" spellcheck="true"># 原因：在 BankAccount 类中，__balance 属性实际上被 Python 重命名为 _BankAccount__balance</span><span class="token comment" spellcheck="true"># print(my_account.__balance)</span><span class="token comment" spellcheck="true"># 使用类的方法操作数据</span>my_account<span class="token punctuation">.</span>deposit<span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span>my_account<span class="token punctuation">.</span>withdraw<span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 访问封装的数据通过方法</span><span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"{my_account.account_holder}的账户余额：{my_account.get_balance()}元"</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> Bevis的账户余额：<span class="token number">1300</span>元</code></pre><p>在上面的示例中，我们使用双下划线前缀<code>__balance</code>来封装账户余额，从而保护数据。外部代码无法直接访问<code>my_account.__balance</code>，但可以通过<code>my_account.get_balance()</code>方法来访问余额。这实现了数据的保护和隔离，确保余额只能受到类方法的影响。</p><h1 id="OOP-继承"><a href="#OOP-继承" class="headerlink" title="OOP-继承"></a>OOP-继承</h1><p><strong>继承是一种机制，它允许一个类（子类）从另一个类（父类）继承属性和方法</strong>。子类可以使用继承来重用父类的代码，同时可以扩展或修改继承的属性和方法。这有助于实现代码的重用和促进代码的层次结构。</p><p><strong>示例代码：创建子类并继承父类的属性和方法</strong></p><p>以下示例来展示继承的用法。创建一个父类<code>Animal</code>，然后创建两个子类<code>Dog</code>和<code>Cat</code>，这两个子类继承了<code>Animal</code>的属性和方法。</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 父类 Animal</span><span class="token keyword">class</span> <span class="token class-name">Animal</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">,</span> species<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>name <span class="token operator">=</span> name        self<span class="token punctuation">.</span>species <span class="token operator">=</span> species    <span class="token keyword">def</span> <span class="token function">make_sound</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span>  <span class="token comment" spellcheck="true"># 抽象方法，由子类实现</span><span class="token comment" spellcheck="true"># 子类 Dog 继承父类 Animal</span><span class="token keyword">class</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span>Animal<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">make_sound</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token string">"汪汪汪！"</span>    <span class="token keyword">def</span> <span class="token function">wag_tail</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> f<span class="token string">"{self.name}摇动尾巴"</span><span class="token comment" spellcheck="true"># 子类 Cat 继承父类 Animal</span><span class="token keyword">class</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span>Animal<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">make_sound</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token string">"喵喵喵！"</span><span class="token comment" spellcheck="true"># 创建实例</span>dog <span class="token operator">=</span> Dog<span class="token punctuation">(</span><span class="token string">"旺财"</span><span class="token punctuation">,</span> <span class="token string">"狗"</span><span class="token punctuation">)</span>cat <span class="token operator">=</span> Cat<span class="token punctuation">(</span><span class="token string">"小花"</span><span class="token punctuation">,</span> <span class="token string">"猫"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 访问继承的属性</span><span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"{dog.name}是一只{dog.species}，发出的声音是：{dog.make_sound()}"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"{cat.name}是一只{cat.species}，发出的声音是：{cat.make_sound()}"</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span>旺财是一只狗，发出的声音是：汪汪汪！<span class="token operator">>></span><span class="token operator">></span>小花是一只猫，发出的声音是：喵喵喵！<span class="token comment" spellcheck="true"># 调用子类特有的方法</span><span class="token keyword">print</span><span class="token punctuation">(</span>dog<span class="token punctuation">.</span>wag_tail<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span>旺财摇动尾巴</code></pre><p>在上面的示例中，我们首先创建了一个父类<code>Animal</code>，它有<code>name</code>和<code>species</code>属性以及一个抽象方法<code>make_sound</code>，该方法在子类中被实现。然后，我们创建了两个子类<code>Dog</code>和<code>Cat</code>，它们分别继承了父类<code>Animal</code>的属性和方法，同时在子类中实现了<code>make_sound</code>方法。</p><p>通过继承，可以创建具有相同属性和方法的多个子类，同时保留每个子类的特定行为。这提供了代码重用的好处，并有助于构建更具层次结构的程序。</p><h1 id="OOP-多态"><a href="#OOP-多态" class="headerlink" title="OOP-多态"></a>OOP-多态</h1><p><strong>多态是指不同类的对象可以对相同的方法名产生不同的行为</strong>。它基于继承和方法重写的概念，使我们<strong>可以通过统一的接口来操作不同的对象，而不必关心具体对象的类型</strong>。多态有助于减少代码的重复，提高代码的可维护性，并促进代码的灵活性。</p><p><strong>示例代码：展示多态的用法</strong></p><p>以下示例来展示多态的用法。创建一个基类<code>Shape</code>，并定义一个<code>calculate_area</code>方法。然后，我们创建两个子类<code>Circle</code>和<code>Rectangle</code>，它们继承<code>Shape</code>并重写<code>calculate_area</code>方法，以便实现各自的面积计算。</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 基类 Shape</span><span class="token keyword">class</span> <span class="token class-name">Shape</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">calculate_area</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span>  <span class="token comment" spellcheck="true"># 抽象方法，由子类实现</span><span class="token comment" spellcheck="true"># 子类 Circle 继承基类 Shape</span><span class="token keyword">class</span> <span class="token class-name">Circle</span><span class="token punctuation">(</span>Shape<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> radius<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>radius <span class="token operator">=</span> radius    <span class="token keyword">def</span> <span class="token function">calculate_area</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token number">3.14</span> <span class="token operator">*</span> self<span class="token punctuation">.</span>radius <span class="token operator">*</span> self<span class="token punctuation">.</span>radius<span class="token comment" spellcheck="true"># 子类 Rectangle 继承基类 Shape</span><span class="token keyword">class</span> <span class="token class-name">Rectangle</span><span class="token punctuation">(</span>Shape<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> width<span class="token punctuation">,</span> height<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>width <span class="token operator">=</span> width        self<span class="token punctuation">.</span>height <span class="token operator">=</span> height    <span class="token keyword">def</span> <span class="token function">calculate_area</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>width <span class="token operator">*</span> self<span class="token punctuation">.</span>height<span class="token comment" spellcheck="true"># 创建不同的形状对象</span>circle <span class="token operator">=</span> Circle<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>rectangle <span class="token operator">=</span> Rectangle<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 计算不同形状的面积</span><span class="token keyword">def</span> <span class="token function">print_area</span><span class="token punctuation">(</span>shape<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"面积：{shape.calculate_area()}"</span><span class="token punctuation">)</span>print_area<span class="token punctuation">(</span>circle<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 输出圆的面积</span>print_area<span class="token punctuation">(</span>rectangle<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 输出矩形的面积</span></code></pre><p>在上面的示例中，我们首先创建了一个基类<code>Shape</code>，其中包含了一个抽象方法<code>calculate_area</code>。然后，我们创建了两个子类<code>Circle</code>和<code>Rectangle</code>，它们继承了<code>Shape</code>并分别重写了<code>calculate_area</code>方法，以实现各自的面积计算方法。</p><p>通过多态，我们可以使用相同的<code>print_area</code>函数来计算不同形状的面积，而无需关心具体的对象类型。这提供了代码的灵活性，使我们能够轻松地扩展程序以支持新的形状类型，同时保持统一的接口。多态是面向对象编程的一个强大工具，有助于提高代码的可扩展性和可维护性。</p><h1 id="self-参数的作用"><a href="#self-参数的作用" class="headerlink" title="self 参数的作用"></a>self 参数的作用</h1><p><strong>self` 参数在 Python 中的作用是引用对象本身</strong>。<u>它是一个约定俗成的名称，通常作为方法的第一个参数，用于指代调用这个方法的实例对象</u>。在面向对象编程中，<code>self</code> 允许你访问类的属性和调用类的方法。</p><h2 id="self-参数的作用-1"><a href="#self-参数的作用-1" class="headerlink" title="self 参数的作用"></a><strong>self 参数的作用</strong></h2><ul><li><p><strong>引用对象本身</strong>：<code>self</code> 是一个指向当前实例对象的引用，通过它，你可以访问对象的属性和调用对象的方法。</p></li><li><p><strong>实现封装</strong>：<code>self</code> 允许你在类的方法中访问对象的内部数据，从而实现封装，确保数据的隔离和保护。</p></li><li><p><strong>支持多态</strong>：<code>self</code> 允许你调用相同名称的方法，但根据对象的类型执行不同的代码，实现多态。</p></li></ul><h2 id="对比self与Java中的this关键字"><a href="#对比self与Java中的this关键字" class="headerlink" title="对比self与Java中的this关键字"></a><strong>对比self与Java中的this关键字</strong></h2><p>在 Java 中，有一个类似的关键字叫做 <code>this</code>，它也表示当前对象。然而，存在一些重要的区别：</p><ul><li>在 Python 中，你必须明确传递 <code>self</code> 作为方法的第一个参数，而在 Java 中，<code>this</code> 是隐式的，不需要明确传递。</li><li>在 Python 中，你可以使用任何合法的变量名作为 <code>self</code> 的别名，但通常使用 <code>self</code> 是一种良好的命名习惯。在 Java 中，只能使用 <code>this</code> 关键字。</li><li>Python 中的 <code>self</code> 是一个约定，而 Java 中的 <code>this</code> 是一个关键字。</li></ul><p><strong>示例代码：说明self的用法</strong></p><p>以下是一个示例，演示了如何使用 <code>self</code> 访问类的属性和调用类的方法：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">MyClass</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>value <span class="token operator">=</span> value    <span class="token keyword">def</span> <span class="token function">print_value</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"Value: {self.value}"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 创建对象</span>obj <span class="token operator">=</span> MyClass<span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 访问属性</span><span class="token keyword">print</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>value<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 输出 42</span><span class="token comment" spellcheck="true"># 调用方法</span>obj<span class="token punctuation">.</span>print_value<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 输出 "Value: 42"</span></code></pre><p>在这个示例中，我们创建了一个 <code>MyClass</code> 类，其中包含一个构造函数 <code>__init__</code> 用于初始化属性 <code>value</code>，以及一个方法 <code>print_value</code> 用于打印属性的值。通过 <code>self</code>，我们可以访问和操作对象的属性，以及调用对象的方法。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>在本篇博客中，我们深入探讨了Python中的面向对象编程（OOP）的关键概念。我们从对象、属性和方法的基础开始，逐步介绍了类的定义和命名规则、封装、继承和多态等重要概念。通过这些概念，我们实现了数据的封装、代码的重用和多态的灵活性。面向对象编程是一种强大的编程范式，可以帮助我们构建更清晰、可维护和可扩展的代码。面向对象编程是一个广泛应用于现代软件开发的重要概念，深入了解它可以提高你的编程技能。我鼓励读者继续学习和实践OOP，探索更复杂的应用和实际场景。</p><h1 id="附录：示例代码"><a href="#附录：示例代码" class="headerlink" title="附录：示例代码"></a>附录：示例代码</h1><p>以下是完整的示例代码，包括定义类、创建对象以及演示封装、继承和多态的用法：</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 对象、属性和方法</span><span class="token keyword">class</span> <span class="token class-name">Car</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> make<span class="token punctuation">,</span> model<span class="token punctuation">,</span> year<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>make <span class="token operator">=</span> make        self<span class="token punctuation">.</span>model <span class="token operator">=</span> model        self<span class="token punctuation">.</span>year <span class="token operator">=</span> year        self<span class="token punctuation">.</span>speed <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">def</span> <span class="token function">accelerate</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> increment<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>speed <span class="token operator">+=</span> increment    <span class="token keyword">def</span> <span class="token function">decelerate</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> decrement<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>speed <span class="token operator">-=</span> decrement    <span class="token keyword">def</span> <span class="token function">get_speed</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>speedmy_car <span class="token operator">=</span> Car<span class="token punctuation">(</span><span class="token string">"Toyota"</span><span class="token punctuation">,</span> <span class="token string">"Camry"</span><span class="token punctuation">,</span> <span class="token number">2022</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"制造商：{my_car.make}"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"型号：{my_car.model}"</span><span class="token punctuation">)</span>my_car<span class="token punctuation">.</span>accelerate<span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"当前速度：{my_car.get_speed()} km/h"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 类的定义和命名规则</span><span class="token keyword">class</span> <span class="token class-name">BankAccount</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> account_holder<span class="token punctuation">,</span> initial_balance<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>account_holder <span class="token operator">=</span> account_holder        self<span class="token punctuation">.</span>__balance <span class="token operator">=</span> initial_balance    <span class="token keyword">def</span> <span class="token function">deposit</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> amount<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> amount <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>__balance <span class="token operator">+=</span> amount    <span class="token keyword">def</span> <span class="token function">withdraw</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> amount<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token number">0</span> <span class="token operator">&lt;</span> amount <span class="token operator">&lt;=</span> self<span class="token punctuation">.</span>__balance<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>__balance <span class="token operator">-=</span> amount        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"余额不足"</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">get_balance</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>__balancemy_account <span class="token operator">=</span> BankAccount<span class="token punctuation">(</span><span class="token string">"Alice"</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span>my_account<span class="token punctuation">.</span>deposit<span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span>my_account<span class="token punctuation">.</span>withdraw<span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"{my_account.account_holder}的账户余额：{my_account.get_balance()}元"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 继承</span><span class="token keyword">class</span> <span class="token class-name">Animal</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">make_sound</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span><span class="token keyword">class</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span>Animal<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">make_sound</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token string">"汪汪汪！"</span><span class="token keyword">class</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span>Animal<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">make_sound</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token string">"喵喵喵！"</span>dog <span class="token operator">=</span> Dog<span class="token punctuation">(</span><span class="token punctuation">)</span>cat <span class="token operator">=</span> Cat<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>dog<span class="token punctuation">.</span>make_sound<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>cat<span class="token punctuation">.</span>make_sound<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 多态</span><span class="token keyword">class</span> <span class="token class-name">Shape</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">calculate_area</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span><span class="token keyword">class</span> <span class="token class-name">Circle</span><span class="token punctuation">(</span>Shape<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> radius<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>radius <span class="token operator">=</span> radius    <span class="token keyword">def</span> <span class="token function">calculate_area</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token number">3.14</span> <span class="token operator">*</span> self<span class="token punctuation">.</span>radius <span class="token operator">*</span> self<span class="token punctuation">.</span>radius<span class="token keyword">class</span> <span class="token class-name">Rectangle</span><span class="token punctuation">(</span>Shape<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> width<span class="token punctuation">,</span> height<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>width <span class="token operator">=</span> width        self<span class="token punctuation">.</span>height <span class="token operator">=</span> height    <span class="token keyword">def</span> <span class="token function">calculate_area</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>width <span class="token operator">*</span> self<span class="token punctuation">.</span>height<span class="token keyword">def</span> <span class="token function">print_area</span><span class="token punctuation">(</span>shape<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"面积：{shape.calculate_area()}"</span><span class="token punctuation">)</span>circle <span class="token operator">=</span> Circle<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>rectangle <span class="token operator">=</span> Rectangle<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span>print_area<span class="token punctuation">(</span>circle<span class="token punctuation">)</span>print_area<span class="token punctuation">(</span>rectangle<span class="token punctuation">)</span></code></pre><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>如果你希望进一步深入学习面向对象编程（OOP）和 Python，以下是一些参考资料和推荐阅读：</p><ol><li>“Python官方文档” - <a href="https://docs.python.org/3/tutorial/classes.html" target="_blank" rel="noopener">Python Official Documentation</a></li><li>“Python对象与类” - <a href="https://docs.python.org/3/tutorial/classes.html" target="_blank" rel="noopener">Python Object and Classes</a></li><li>“Python OOP教程” - <a href="https://realpython.com/python3-object-oriented-programming/" target="_blank" rel="noopener">Python OOP Tutorial</a></li></ol><p>这些资源将帮助你深入了解Python中的面向对象编程，并提供更多关于OOP的知识和实际示例。希望本文能对你有所帮助，鼓励你继续学习和探索。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> OOP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解读数据迷雾：洞察数据分析思维的力量</title>
      <link href="/shu-fen-shu-ju-fen-xi-si-wei.html"/>
      <url>/shu-fen-shu-ju-fen-xi-si-wei.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>数据不仅是描述世界的工具，它还是探索现象背后原因的关键。<strong>现象与原因之间存在无法跨越的鸿沟——数据</strong>，看懂数据，读懂数据，分析数据背后的本质，离不开数据分析的思维，正如古代探险家用望远镜来扩大视野以发现新大陆一样，数据分析思维为我们提供了一种超越表面、深入核心的工具。</p><h1 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h1><h2 id="数据是什么？"><a href="#数据是什么？" class="headerlink" title="数据是什么？"></a>数据是什么？</h2><p>数据是描述性信息的集合，它可以以各种形式存在，包括数字、文字、图像、声音等。这些信息记录了某种事物、现象、实体或事件的属性、状态或特征。数据是我们获取知识、做出决策和执行操作的基础。</p><h2 id="数据特征"><a href="#数据特征" class="headerlink" title="数据特征"></a>数据特征</h2><p>数据具有多个重要特征，这些特征决定了数据的性质和如何处理它们。</p><ol><li><p>多样性：数据可以采用多种形式，包括数字、文字、图像、声音、视频等。这多样性使得数据在不同领域和应用中都有用武之地。</p></li><li><p>容量：数据可以非常庞大，从小到几字节的文件，到大规模的数据集，可能需要数百TB的存储空间。处理大容量数据需要特殊的技术和工具。</p></li><li><p>时效性：数据可能具有不同的时间戳，包括历史数据和实时数据。时效性数据在监控和实时决策制定中非常重要。</p></li><li><p>可信度：数据的质量和可信度对于数据分析至关重要。低质量的数据可能导致错误的结论和决策。数据的完整性、准确性和一致性都是数据质量的因素。</p></li><li><p>关联性：数据之间可能存在复杂的关系。了解这些关系可以帮助我们更好地理解数据，识别影响因素，并进行更深入的分析。</p></li><li><p>结构：数据可以是结构化或非结构化的。结构化数据具有清晰的组织，通常以表格或数据库的形式存储。非结构化数据则不遵循明确的组织形式，例如文本文档或媒体文件。</p></li><li><p>来源：数据可以来自多个来源，包括内部数据（组织内部产生或收集的数据）和外部数据（来自外部来源的数据，如市场数据、社交媒体数据）。</p></li><li><p>用途：数据可以用于不同的目的，包括操作性数据（用于日常业务操作和交易）和分析性数据（用于深入分析、洞察和决策制定）。</p></li></ol><p>这些数据特征共同影响了如何采集、存储、处理和分析数据。在数据分析思维中，了解数据的特征对于选择适当的方法和工具至关重要，以充分发挥数据的潜力。</p><h2 id="数据的分类"><a href="#数据的分类" class="headerlink" title="数据的分类"></a>数据的分类</h2><p>数据可以根据不同的特征和属性进行分类。这些分类方式有助于理解数据的性质和用途。</p><h3 id="1-按数据类型："><a href="#1-按数据类型：" class="headerlink" title="1. 按数据类型："></a>1. 按数据类型：</h3><ul><li><p><strong>定量数据</strong>：这类数据以数字表示，通常用于量化和测量。例如，温度、年龄、身高、销售额等都是定量数据。</p></li><li><p><strong>定性数据</strong>：这类数据描述性质、类别或特征，不以数字表示。例如，颜色、性别、婚姻状态等都是定性数据。</p></li></ul><h3 id="2-按数据来源："><a href="#2-按数据来源：" class="headerlink" title="2. 按数据来源："></a>2. 按数据来源：</h3><ul><li><p><strong>内部数据</strong>：这些数据是组织内部产生或收集的，如销售记录、客户信息、员工数据等。内部数据通常用于监测和管理组织内部运营。</p></li><li><p><strong>外部数据</strong>：这些数据来自外部来源，如市场数据、社交媒体数据、天气数据等。外部数据可以用于市场研究、趋势分析等，帮助组织做出决策。</p></li></ul><h3 id="3-按数据结构："><a href="#3-按数据结构：" class="headerlink" title="3. 按数据结构："></a>3. 按数据结构：</h3><ul><li><p><strong>结构化数据</strong>：这类数据具有清晰的表格结构，通常存储在数据库中，可以轻松进行查询和分析。例如，数据库表、电子表格文件是结构化数据的例子。</p></li><li><p><strong>非结构化数据</strong>：这类数据没有明确的结构，通常以文本、图像、音频、视频等形式存在。非结构化数据的处理和分析通常需要更复杂的技术和工具。</p></li></ul><h3 id="4-按数据用途："><a href="#4-按数据用途：" class="headerlink" title="4. 按数据用途："></a>4. 按数据用途：</h3><ul><li><p><strong>操作性数据</strong>：这些数据用于日常业务操作和交易。它们包括订单信息、库存数据、交易记录等，用于支持组织的日常运营。</p></li><li><p><strong>分析性数据</strong>：这些数据用于深入分析、洞察和决策制定。分析性数据通常包括历史数据、大数据集，用于发现趋势、模式和机会。</p></li></ul><h3 id="5-按时间性："><a href="#5-按时间性：" class="headerlink" title="5. 按时间性："></a>5. 按时间性：</h3><ul><li><p><strong>历史数据</strong>：这是过去记录的数据，可用于分析历史趋势和预测未来事件。例如，销售历史数据用于分析销售趋势。</p></li><li><p><strong>实时数据</strong>：这类数据是实时生成的，具有时间戳。它们用于监控和实时决策制定，如传感器数据、社交媒体实时流。</p></li></ul><p>这些分类方式并不是相互排斥的，而是相互补充的。根据你的具体需求和分析目的，可以选择不同类型的数据进行处理和分析。理解数据的分类有助于更好地组织和管理数据，以支持决策和洞察。</p><h1 id="什么是数据分析思维？"><a href="#什么是数据分析思维？" class="headerlink" title="什么是数据分析思维？"></a>什么是数据分析思维？</h1><p> 数据分析思维是指通过对数据进行收集、整理、分析和解释，从中发现模式、趋势、关联和洞见的一种思考方式。它强调运用科学的方法和技术来理解和解决问题，基于数据驱动的决策和行动。 </p><h1 id="数据分析思维的两种推理"><a href="#数据分析思维的两种推理" class="headerlink" title="数据分析思维的两种推理"></a>数据分析思维的两种推理</h1><p><strong>两种推理模式，一种是归纳，一种是演绎</strong></p><p>归纳与演绎具体阐述在我的另一篇文章，这里不做详细的阐述</p><h2 id="一、结构化思维-归纳"><a href="#一、结构化思维-归纳" class="headerlink" title="一、结构化思维-归纳"></a><strong>一、结构化思维</strong>-归纳</h2><p>归纳其实就是<strong>把复杂问题分解成多种单一因素的过程</strong>，并且将这些因素加以归纳和整理，使之条理化、纲领化。这个过程犹如抽丝剥茧，将一团乱麻理地条条顺顺。</p><h3 id="工具-金字塔原理"><a href="#工具-金字塔原理" class="headerlink" title="工具-金字塔原理"></a>工具-金字塔原理</h3><p>在数据分析思维中，归纳思维是一种将复杂问题分解成多个单一因素并将它们归纳和整理的重要思维方式。金字塔原理是一种强大的工具，它有助于将问题的结构清晰化，使之更易于理解和分析。</p><h3 id="金字塔原理的核心思想"><a href="#金字塔原理的核心思想" class="headerlink" title="金字塔原理的核心思想"></a>金字塔原理的核心思想</h3><p>金字塔原理的核心思想可以总结为：“<u>任何事情都可以归纳出中心论点，由中心论点出发，可由三至七个论据支撑，每个一级论点可以衍生出其他的分论点。</u>” 这个思想可以帮助我们将一个复杂的问题分解成更小的部分，从而使问题的结构更清晰，容易处理。</p><h3 id="MECE法则思考结构"><a href="#MECE法则思考结构" class="headerlink" title="MECE法则思考结构"></a>MECE法则思考结构</h3><p>在金字塔原理中，使用MECE（Mutually Exclusive, Collectively Exhaustive：相互独立，完全穷尽）法则对问题进行思考，以确保问题的结构是有条理的。</p><p>具体的操作方式包括：</p><p><strong>A. 尽可能列出所有思考的要点：</strong> 这意味着你应该尽量列出与问题相关的所有要点，无论它们看起来有多细微或相关。这有助于确保你不会遗漏任何重要信息。</p><p><strong>B. 找出关系，进行分类：</strong> 接下来，你需要找出这些要点之间的关系，并对它们进行分类。这意味着将相似的要点分组在一起，以形成更大的论据或主题。</p><p><strong>MECE法则的原则</strong>是<strong>论点之间相互独立，不重复；论据穷尽划分，不遗漏</strong>。这种方法有助于建立清晰的问题结构，使问题的解决过程更加有条不紊。</p><h3 id="如何做到MECE"><a href="#如何做到MECE" class="headerlink" title="如何做到MECE"></a>如何做到MECE</h3><p>以下为一个思考周期：</p><ol><li><p>明确定义问题：首先，明确定义你要分析的问题或主题。确保你清晰地理解问题的范围、目标和相关信息。</p></li><li><p>列出所有可能的要点：开始列出与问题相关的所有要点、元素或因素。这些要点可以是问题的组成部分或可能影响问题的各个方面。</p></li><li><p>分类和整理：将列出的要点进行分类和整理。找出它们之间的相似性和关系，以便将它们分组在一起。这有助于建立一个有条理的问题结构。</p></li><li><p><strong>消除重复</strong>：检查你的要点，确保它们之间没有重叠或交叉。如果发现两个要点存在重叠，考虑将它们合并为一个。重叠的要点可能导致混淆和重复计数。</p></li><li><p><strong>确保相互独立</strong>：每个要点应该是相互独立的，不应该包括其他要点的内容。确保每个要点表达一个唯一的概念或方面。如果两个要点有部分内容是相同的，那么它们可能不是相互独立的。</p></li><li><p>填补遗漏：确保你的要点覆盖了整个问题领域，没有遗漏任何部分。考虑是否有其他要点或因素未被包括在内，但对问题有影响。</p></li><li><p>建立层次结构：将要点组织成一个有层次结构的框架。在框架的顶层，有一个中心论点，然后从中心论点分支出三至七个一级论点。每个一级论点可以进一步分解为更具体的二级和三级论点，以建立层次结构。</p></li><li><p>反复检查和优化：反复检查你的结构，确保它满足MECE法则的要求。如果发现重叠或遗漏，或者需要进一步细化分类，进行相应的修正和优化。</p></li><li><p>应用到问题分析：将MECE结构应用到问题分析中，使用它来组织和分类信息、数据或观点。这将有助于你更清晰地理解问题，深入分析各个方面，以做出更明智的决策。</p></li><li><p>反馈和改进：不断反馈和改进你的MECE结构。如果在问题分析过程中发现问题，可以根据反馈进行调整和改进，以确保结构的有效性和准确性。</p></li></ol><h3 id="MECE方法论"><a href="#MECE方法论" class="headerlink" title="MECE方法论"></a>MECE方法论</h3><h4 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h4><p>二分法——<strong>把一个事物，找出一个<u>维度</u>，分为两个部分，如A和非A，或者相对立的，这便概括了所有了。</strong></p><p>举例：本地与外地、宏观与微观、优势与劣势、软性与硬性、男与女……</p><blockquote><p> “MECE法则”就绝不能出现“等等”和“其他”等字眼。如果出现了，就说明不明的部分太多，你没有将要素彻底地分解 </p></blockquote><p>通过二分法，开展逻辑， 有条理，逻辑层次分明 ，这样的好处就是找不到第三个分类来对立所表达的，让逻辑变得慎密</p><h4 id="流程法"><a href="#流程法" class="headerlink" title="流程法"></a>流程法</h4><p><strong>流程法</strong>：通过将一个复杂的任务或问题分解为一系列具体的步骤或阶段来帮助理解、计划和解决问题。这种方法有助于将复杂性简化，使任务更具可管理性。</p><p><strong>应用</strong>：流程法可以应用于各种领域和任务，包括项目管理、流程改进、策划和执行活动、研究方法等。</p><p><strong>示例应用</strong>：以策划一个活动为例，通过流程法，可以将活动策划分解为以下步骤：</p><ol><li>明确活动目标</li><li>制定详细的计划</li><li>确定所需资源</li><li>招募团队成员</li><li>实施活动</li><li>监控进展</li><li>完成和总结活动</li></ol><p><strong>优势</strong>：过程法的主要优势之一是它提供了结构性和逻辑性。它有助于明确每个步骤的职责和时间表，使任务更容易管理。还便于团队协作，因为每个步骤的责任可以分配给不同的团队成员。</p><h4 id="要素法"><a href="#要素法" class="headerlink" title="要素法"></a>要素法</h4><p><strong>要素法</strong>：通过将问题分解为其关键要素或成分，系统地考虑如何改进或管理这些要素，更好地理解问题的本质。</p><p><strong>应用</strong>：要素法在各个领域中都有广泛的应用。它可用于分析产品、服务、品牌、业务模型、战略规划等。通过将问题分解为关键要素，可以更有效地识别问题的症结所在并制定解决方案。</p><p><strong>示例应用</strong>：以品牌管理为例，通过要素法可以将品牌分解为三个关键要素：品牌知名度、品牌美誉度和品牌忠诚度。然后，可以针对每个要素考虑改进措施：</p><ul><li>品牌知名度：增加广告投放、开设更多门店、举办市场活动，以提高品牌知名度。</li><li>品牌美誉度：提供高质量产品、提供卓越的售后服务、积极管理公关，以提高品牌美誉度。</li><li>品牌忠诚度：提供卓越的产品和服务、开发独特的功能、建立用户生态系统，以提高用户忠诚度。</li></ul><p><strong>优势</strong>：要素法的主要优势之一是它能够帮助人们更系统地思考和解决问题。通过关注问题的核心要素，我们可以更好地集中精力解决最关键的问题。</p><h2 id="二、假说演绎思维-演绎"><a href="#二、假说演绎思维-演绎" class="headerlink" title="二、假说演绎思维-演绎"></a><strong>二、假说演绎思维</strong>-演绎</h2><p>假说演绎，假设先行；</p><p>同样遵循金字塔原理，mece法则，不同点在于，使用假设先行的方法来思考解决方案，可以从多个角度出发，利用数据和科学方法去寻找解决问题的方案。可以帮助我们排除无关因素，缩小研究范围，提高研究效率。 </p><h1 id="指标化思维"><a href="#指标化思维" class="headerlink" title="指标化思维"></a><strong>指标化思维</strong></h1><p>归纳与演绎都属于定性问题，介入数据的定量问题，就需要指标化思维的支撑；</p><p>指标化思维：将问题抽象成可量化指标或度量的思维方式，强调通过具体的指标来测量、评估和比较不同的情况或方案，从而得出客观的结论或决策。</p><p>指标化思维的<strong>核心思想是将复杂的问题转化成可以衡量和比较的指标，以便更好地理解和处理问题</strong>。可以明确目标、定义关键指标、收集数据，以及进行定量分析和判断。</p><p>以下是指标化思维的一般步骤：</p><ol><li>确定目标：首先明确我们想要实现的目标或解决的问题。目标应该具体、明确，并且能够量化或描述。</li><li>定义指标：根据目标，确定可以用来度量或评估问题的指标。指标应该与目标相关，具备可操作性和可度量性。</li><li>收集数据：收集与指标相关的数据。这可能涉及到调查、观察、实验或数据分析等方法，以获得需要的信息。</li><li>分析和比较：使用收集到的数据进行分析和比较。通过比较不同指标的数值、趋势或关系，找出规律或洞察，并作出相应的判断或决策。</li><li>反馈和调整：根据分析结果，对指标或方案进行反馈和调整。这有助于进一步优化问题的解决方案，提高效果或达成目标。</li></ol><h2 id="指标化经验"><a href="#指标化经验" class="headerlink" title="指标化经验"></a>指标化经验</h2><p>在设定指标时，可以参考以下两个经验：</p><ol><li><strong>SMART原则</strong>：SMART是一个常用的指标设定原则，它代表具体（Specific）、可衡量（Measurable）、可实现（Achievable）、相关（Relevant）和时间相关（Time-bound）。根据这个原则，指标应该具备以下特征：<ul><li>具体（Specific）：明确描述要达到的目标，避免模糊和泛泛而谈。</li><li>可衡量（Measurable）：能够定量或定性地测量指标的数值或结果。</li><li>可实现（Achievable）：设定的指标应该是可达到的，并且有合理的资源和能力支持。</li><li>相关（Relevant）：指标与目标之间应该存在关联性，能够真正反映目标的进展或影响。</li><li>时间相关（Time-bound）：设定明确的时间范围或截止日期，以便进行监测和评估。</li></ul></li><li><strong>行业标准或最佳实践</strong>：在一些行业或领域中，可能已经存在一些通用的指标或最佳实践，可以作为参考。这些指标通常基于过去的经验和数据分析，被广泛接受并认可。了解该行业的标准，可以帮助你选择适合自己情况的指标，并与同行进行比较。</li></ol><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>数据分析思维不仅仅是一种技能，更是一种冒险，一次探索未知的旅程。通过这种思维方式，我们能够超越表面，深入问题的核心，找到现象背后的原因。正如数据是解锁世界之谜的关键，数据分析思维是解锁数据潜力的关键。</p><p>让我们保持好奇心，积极探索数据中的奥秘，用数据分析思维的工具来探险，以便更好地理解世界，解决问题，做出明智的决策。愿您的数据之旅充满发现和启发！</p>]]></content>
      
      
      <categories>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思维工具 </tag>
            
            <tag> 数据分析 </tag>
            
            <tag> 思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ip地址与探针</title>
      <link href="/ji-zhu-fen-xiang-ip-di-zhi-yu-tan-zhen.html"/>
      <url>/ji-zhu-fen-xiang-ip-di-zhi-yu-tan-zhen.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>IP地址是互联网通信的基础，它允许我们的设备在网络上进行通信和互动。无论是浏览网页、发送电子邮件还是使用手机应用，IP地址都在幕后发挥着关键作用。在这篇博客中，我们将深入探讨IP地址的概念和重要性，并引入一个令人兴奋的主题——IP地址定位。虽然IP地址通常被视为一种网络标识符，但它还有一个隐藏的超能力，那就是可以用来确定设备的地理位置。这种能力为各种领域带来了无限可能，从企业市场定位到网络安全和个人隐私。在接下来的文章中，我们将一起探讨IP地址定位是如何工作的，以及它为我们的数字世界带来了哪些新颖应用。让我们开始吧，了解IP地址的神奇之处！</p><h1 id="ip地址"><a href="#ip地址" class="headerlink" title="ip地址"></a>ip地址</h1><h2 id="ip地址是什么？"><a href="#ip地址是什么？" class="headerlink" title="ip地址是什么？"></a>ip地址是什么？</h2><p><strong>IP地址（Internet Protocol Address）是计算机网络中用于标识和定位设备的唯一标识符</strong>。它充当了网络上的门牌号码，使得数据包可以正确地路由到目标设备，从而实现互联网通信。每台连接到互联网的设备都必须拥有一个IP地址，这包括计算机、手机、服务器以及各种物联网设备。</p><h2 id="IPv4和IPv6地址"><a href="#IPv4和IPv6地址" class="headerlink" title="IPv4和IPv6地址"></a>IPv4和IPv6地址</h2><p>有两个主要版本的IP地址，分别是IPv4（Internet Protocol version 4）和IPv6（Internet Protocol version 6）。IPv4地址是互联网早期使用的版本，它由32位二进制数字组成，通常以点分十进制表示法（例如，192.168.1.1）呈现。由于互联网的迅猛增长，IPv4地址资源已经枯竭，因此IPv6作为其继任者被引入。IPv6地址采用128位二进制数字表示，通常以冒号分隔的八组十六进制数表示（例如，2001:0db8:85a3:0000:0000:8a2e:0370:7334）。IPv6的主要优点是它提供了更广泛的地址空间，以满足日益增长的设备需求。</p><h2 id="IP地址结构"><a href="#IP地址结构" class="headerlink" title="IP地址结构"></a>IP地址结构</h2><p>IP地址由两个主要部分组成：网络部分和主机部分。这两个部分的结合形成了一个完整的IP地址，用于在网络中唯一标识设备。</p><p>网络部分： 网络部分标识了设备所在的网络。不同网络的设备在网络部分上有不同的值，允许路由器和网络设备正确地将数据包传递到目标网络。网络部分的长度取决于IP地址的子网掩码。</p><p>主机部分： 主机部分唯一标识了网络中的特定设备。不同设备在主机部分上有不同的值，以确保设备在同一网络内具有唯一性。主机部分的长度取决于网络子网掩码。</p><h2 id="子网掩码的作用"><a href="#子网掩码的作用" class="headerlink" title="子网掩码的作用"></a>子网掩码的作用</h2><p>子网掩码是一种与IP地址配合使用的32位二进制数字，用于确定网络部分和主机部分的边界。它的作用是告诉网络设备哪些位属于网络部分，哪些位属于主机部分。子网掩码通过使用1表示网络部分，0表示主机部分来实现这一目的。子网掩码允许网络管理员将一个大的IP地址块划分为多个子网络，以更有效地管理IP地址资源。</p><p>通过理解IP地址的基础概念、IPv4和IPv6的区别，以及IP地址的结构和子网掩码的作用，能够更深入地了解IP地址及其在网络中的作用。这为接下来探讨IP地址定位提供坚实的基础。</p><h1 id="ip地址定位原理"><a href="#ip地址定位原理" class="headerlink" title="ip地址定位原理"></a>ip地址定位原理</h1><h2 id="ip定位原理步骤与方法"><a href="#ip定位原理步骤与方法" class="headerlink" title="ip定位原理步骤与方法"></a>ip定位原理步骤与方法</h2><ol><li><p>IP地址和地理位置数据库：<strong>IP地址定位的核心是将IP地址映射到地理位置</strong>。为了实现这一目标，需要一个包含IP地址和相应地理位置信息的数据库。这个数据库通常称为IP地址地理位置数据库或IP地址地理位置映射数据库。这些数据库由各种组织维护，它们通过不断更新数据来确保准确性。</p></li><li><p>IP地址提取：在进行IP地址定位之前，首先需要获取要定位的设备的IP地址。这可以通过多种方式实现，包括服务器日志、网络流量监测、网站访问统计等。</p></li><li><p>IP地址查询：一旦获得了目标设备的IP地址，接下来的步骤是将该IP地址查询到IP地址地理位置数据库中。这个查询可以通过编程接口或查询工具来执行，以获取与IP地址相关联的地理位置信息。</p></li><li><p>地理位置解析：数据库返回的地理位置信息通常包括国家、地区、城市、经度和纬度等信息。这些信息可以用于精确定位设备的位置。</p></li><li><p>精确度和准确性：IP地址定位的精确度和准确性取决于使用的地理位置数据库的质量和更新频率。通常情况下，精确度较高的数据库会提供更准确的结果。然而，由于动态IP地址分配、代理服务器和虚拟专用网络（VPN）等因素的存在，IP地址定位可能不总是百分之百准确。</p></li></ol><h2 id="IP地理位置数据库的作用"><a href="#IP地理位置数据库的作用" class="headerlink" title="IP地理位置数据库的作用"></a>IP地理位置数据库的作用</h2><p>IP地址地理位置数据库是IP地址定位的关键组成部分。它的作用包括：</p><ol><li>存储IP地址与地理位置信息的映射。</li><li>提供查询接口，允许用户根据IP地址检索地理位置信息。</li><li>持续更新和维护以反映不断变化的IP地址分布和地理位置信息。</li><li>IP地址与地理位置的联系</li></ol><p>IP地址与地理位置之间的联系是通过地理位置数据库实现的。每个IP地址都与数据库中的一个或多个地理位置信息相关联。这种联系允许我们根据IP地址了解设备的大致地理位置，例如国家、地区、城市等。</p><blockquote><p>IP地址本身并不包含地理信息。地理位置信息是通过对大量IP地址进行分析和映射而获得的。</p></blockquote><h1 id="ip地址的应用领域"><a href="#ip地址的应用领域" class="headerlink" title="ip地址的应用领域"></a>ip地址的应用领域</h1><p>IP地址定位在各种应用领域中都有用武之地，包括但不限于：</p><ol><li>广告定向投放：根据用户的地理位置提供相关广告。</li><li>内容分发网络（CDN）：将内容服务器分布到接近用户的位置，提高内容传递速度。</li><li>网络安全：检测潜在的恶意活动或入侵尝试。</li><li>市场调研：了解特定地理区域的用户行为和偏好。</li><li>社交媒体定位服务：允许用户共享其实际位置。</li></ol><blockquote><p>IP地址定位并不总是可以精确到具体的街道地址，因为这通常需要更多的隐私敏感信息。然而，它在许多情况下可以提供有用的地理位置信息，以满足各种商业和技术需求。</p></blockquote><h1 id="应用方面的具体阐述"><a href="#应用方面的具体阐述" class="headerlink" title="应用方面的具体阐述"></a>应用方面的具体阐述</h1><h2 id="企业应用："><a href="#企业应用：" class="headerlink" title="企业应用："></a>企业应用：</h2><h3 id="市场定位："><a href="#市场定位：" class="headerlink" title="市场定位："></a>市场定位：</h3><p>企业可以使用IP地址定位来更好地理解其在线受众的地理分布。通过分析访问其网站或应用的用户的IP地址，企业可以确定用户所在的国家、地区或城市，从而优化产品定位、定价策略和市场推广活动。这有助于企业更精确地针对不同地理区域的潜在客户，提高市场营销效果。</p><h3 id="客户服务："><a href="#客户服务：" class="headerlink" title="客户服务："></a>客户服务：</h3><p>IP地址定位还可以用于改进客户服务。企业可以根据用户的地理位置提供地区特定的支持和服务。例如，根据用户的IP地址确定其所在城市，然后提供当地的联系信息、服务中心或特定地区的促销活动。这可以增强客户满意度，提高客户忠诚度。</p><h3 id="广告定向："><a href="#广告定向：" class="headerlink" title="广告定向："></a>广告定向：</h3><p>IP地址定位是广告定向的重要工具。企业可以根据用户的地理位置定向广告，以确保广告投放更有针对性和效果。例如，餐饮企业可以将特定地区的餐厅促销广告仅显示给当地用户，提高到店率。这种精确的广告定向可以帮助企业更有效地利用广告预算。</p><h2 id="网络安全："><a href="#网络安全：" class="headerlink" title="网络安全："></a>网络安全：</h2><h3 id="入侵检测："><a href="#入侵检测：" class="headerlink" title="入侵检测："></a>入侵检测：</h3><p>IP地址定位可用于增强网络安全。企业可以监测网络上的IP地址并与已知的恶意IP地址数据库进行比对，以识别潜在的入侵尝试。如果某个IP地址来自已知的恶意源，系统可以自动触发警报或采取其他安全措施来阻止入侵。</p><h3 id="反欺诈："><a href="#反欺诈：" class="headerlink" title="反欺诈："></a>反欺诈：</h3><p>在金融和电子商务领域，IP地址定位可用于反欺诈。通过分析用户的IP地址和地理位置信息，企业可以检测到异常的交易模式，例如异地登录或不寻常的购物行为。这有助于及早发现和防止欺诈活动。</p><h3 id="个人隐私："><a href="#个人隐私：" class="headerlink" title="个人隐私："></a>个人隐私：</h3><p>IP地址定位引发了有关个人隐私的重要讨论。尽管IP地址定位在商业和安全领域有很多有益的应用，但也可能对个人隐私构成威胁。个人的地理位置信息可能被滥用，导致隐私泄露和跟踪问题。</p><h1 id="IP地址定位的限制和挑战："><a href="#IP地址定位的限制和挑战：" class="headerlink" title="IP地址定位的限制和挑战："></a>IP地址定位的限制和挑战：</h1><ol><li><p>动态IP地址：许多互联网服务提供商使用动态IP地址，这些地址可能在不同的时间分配给不同的用户，使准确的定位变得更加困难。</p></li><li><p>代理服务器和VPN：用户可以使用代理服务器或虚拟专用网络（VPN）隐藏其真实IP地址，从而干扰IP地址定位的准确性。</p></li><li><p>精度限制：IP地址定位通常无法提供到具体街道级别的精确地理位置信息，这在某些应用场景下可能不够精确。</p></li><li><p>隐私考虑：使用IP地址定位时，需要考虑个人隐私权的问题。滥用地理位置信息可能导致隐私泄露和滥用问题。</p></li></ol><h1 id="ip探针与定位"><a href="#ip探针与定位" class="headerlink" title="ip探针与定位"></a>ip探针与定位</h1><h2 id="什么是ip探针"><a href="#什么是ip探针" class="headerlink" title="什么是ip探针"></a>什么是ip探针</h2><p>IP探针（IP probe）通常是指一种用于检测和监视计算机网络中IP地址的工具或程序。IP地址是用于在互联网上标识和定位计算机设备的数字标识符</p><h2 id="ip探针的功能"><a href="#ip探针的功能" class="headerlink" title="ip探针的功能"></a>ip探针的功能</h2><ol><li><p>可用性监测：IP探针可以定期发送请求到目标IP地址，以检查目标设备是否在线或可用。这有助于网络管理员快速识别网络故障或设备失效。</p></li><li><p>延迟测量：IP探针可以测量数据包从一个点到另一个点的传输延迟，从而帮助评估网络性能。</p></li><li><p>带宽利用率：通过监测IP地址上的流量，IP探针可以帮助管理员了解网络上的带宽利用情况，有助于优化网络资源分配。</p></li><li><p>数据包损失检测：IP探针可以检测到网络中发生的数据包丢失或错误，这对于排除网络问题非常有用。</p></li><li><p>安全审计：IP探针可以用于检测潜在的网络入侵或恶意活动，例如扫描或攻击。</p></li></ol><h2 id="ip获取与查询"><a href="#ip获取与查询" class="headerlink" title="ip获取与查询"></a>ip获取与查询</h2><p> 想查一个ip地址的相关信息之前，首先便是获取到ip地址，这时候就是利用常见的探针方式（钓鱼）来获取ip地址，常见的钓鱼获取对方IP地址的手段 ：有<strong>链接，图片，邮件，pdf</strong>等探针方式，最常用的便是链接；</p><p>基本步骤思路便是生成相应的东西，诱导想获取者去点击，便可获取，这里不做阐述</p><h2 id="ip探针类网站"><a href="#ip探针类网站" class="headerlink" title="ip探针类网站"></a>ip探针类网站</h2><p>列举几个：</p><ol><li><p><a href="https://www.ip-tracker.org/" target="_blank" rel="noopener">https://www.ip-tracker.org/</a><br>该网站提供IP地址追踪和详细的IP地址信息，包括位置、ISP（互联网服务提供商）、域名信息等。您可以在主页上输入要追踪的IP地址，并获取相关的详细信息。</p></li><li><p><a href="https://chaipip.com/" target="_blank" rel="noopener">https://chaipip.com/</a><br>Chaipip是一个简单易用的在线IP查询工具，可以查询IP地址的地理位置、所属国家和地区、运营商等信息。它还提供了一些其他实用的网络工具，如Ping、Traceroute等。</p></li><li><p><a href="https://www.sojson.com/ip/" target="_blank" rel="noopener">https://www.sojson.com/ip/</a><br>SOJSON的IP地址查询工具提供了IP地址相关的详细信息，包括所在城市、所属运营商、IP地址段等。您可以在页面上输入要查询的IP地址或域名，获取相应的信息。</p></li></ol><blockquote><p> 注意：使用这些工具时，请遵守相关法律法规，不要进行非法活动或侵犯他人隐私。 </p></blockquote><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>在这篇博客中，我们介绍了IP地址的基本概念和重要性，以及它在确定设备地理位置方面的超能力。我们探讨了IP地址定位在市场定位、网络安全和个人隐私等领域的应用。通过IP地址定位，我们可以更好地了解和利用数字世界带来的各种可能性。希望这篇博客对您有所启发，感谢阅读！</p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术分享 </tag>
            
            <tag> 网络安全 </tag>
            
            <tag> IP探针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逻辑推理的艺术：归纳与演绎</title>
      <link href="/ren-wen-she-ke-gui-na-yu-yan-yi.html"/>
      <url>/ren-wen-she-ke-gui-na-yu-yan-yi.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>​        当我们思考世界的运行规律时， 逻辑推理就像驾驭骏马一样成为我们的得力工具。它给予我们自由驰骋的能力，让我们能够有条不紊地探索真理的道路。 它是一种艺术，既犹如琴键上的技巧与和谐，又像画布上的色彩与构图。归纳与演绎，作为逻辑推理的两大支柱，将引领我们穿越思维的迷宫，揭示真理的面纱。</p><p>​        在此文中，我们将探索逻辑推理的艺术，解读归纳与演绎的要点和实践技巧，共同揭示它们背后的奥妙和应用。无论你是追求知识的学子，还是对逻辑思考充满好奇的探索者，都可以一起领略逻辑推理的魅力，开启思维的新旅程！ </p><h1 id="归纳"><a href="#归纳" class="headerlink" title="归纳"></a>归纳</h1><h2 id="什么是归纳？"><a href="#什么是归纳？" class="headerlink" title="什么是归纳？"></a>什么是归纳？</h2><p><strong>归纳的概念和含义</strong>：<u>归纳是一种从具体实例中抽象出普遍性规律的思维过程</u>。通过观察和研究多个具体实例，归纳能够发现其中的共同特征或者规律，并将其概括为更一般性的概念或者原则。归纳帮助我们从片面的、零散的信息中提取出普遍的信息和经验，为问题解决和决策提供有力的支持。</p><h2 id="归纳的重要性和应用领域"><a href="#归纳的重要性和应用领域" class="headerlink" title="归纳的重要性和应用领域"></a>归纳的重要性和应用领域</h2><p>归纳具有重要的认知和应用价值。首先，归纳在认知上能够帮助我们理解和把握事物的本质和规律，提升我们对世界的认识能力。其次，归纳在科学研究中具有重要地位，科学家需要从大量实验证据中归纳出理论和模型，推动学科的发展。此外，归纳也在日常生活中广泛应用于数据分析、市场调研、问题解决等领域。</p><h2 id="归纳法"><a href="#归纳法" class="headerlink" title="归纳法"></a>归纳法</h2><p><u>由结果出发， 通过观察、比对、分析，寻找事物之间的因果关联；</u> </p><h2 id="归纳可能出现的悖论：罗素的火鸡"><a href="#归纳可能出现的悖论：罗素的火鸡" class="headerlink" title="归纳可能出现的悖论：罗素的火鸡"></a>归纳可能出现的悖论：罗素的火鸡</h2><p>哲学家伯特兰·罗素的著名故事：</p><p>​    在一个火鸡饲养场里，一只聪明的火鸡发现每天上午9点钟主人都会给它喂食。这只火鸡不仅观察到了各种天气条件下的喂食时间，还记录了不同星期的情况。经过一段时间的观察和积累，它建立了一个准确的认知：“主人总是在上午9点钟给我喂食。”</p><p>​    火鸡对这个规律感到非常满意，因为它得以享受每天早晨的美味佳肴。然而，在圣诞节前一天的9点钟，主人却没有像往常那样给它喂食，而是把它带走了。</p><p> 尽管通过长时间的观察和积累可能得出一个看似稳定的规律，但我们不能忽视突发的异常情况。归纳推理的结论并不一定适用于所有情况，因为未来的事件可能会违反我们之前所建立的规律。我们要保持谨慎，不要太过依赖归纳法的结论。我们应该持开放态度，随时准备接受新的信息和观察，以免被意外情况所困扰。只有这样，我们才能更好地适应变化，并做出更准确、全面的判断。 </p><h2 id="如何提高归纳能力，不做“火鸡”"><a href="#如何提高归纳能力，不做“火鸡”" class="headerlink" title="如何提高归纳能力，不做“火鸡”"></a>如何提高归纳能力，不做“火鸡”</h2><p>​    在思考逻辑推理和解决问题时，归纳能力是一项至关重要的技能。它允许我们从特定观察中提炼出一般性的结论，帮助我们更好地理解世界。十九世纪英国逻辑学家穆勒提出了一套系统性的归纳方法，被称为”<strong>穆勒五法</strong>“，这些方法可以帮助我们训练和提高归纳能力。</p><h3 id="求同法"><a href="#求同法" class="headerlink" title="求同法"></a>求同法</h3><p><u>求同法是指，如果在被研究现象出现的若干个场合中，仅有一个共同的情况，那么这个共同的情况是被研究现象的原因（或结果）。</u>  </p><p>​    故事： 有一天，皮尔·居里的一位同事将装有镭试剂的小玻璃管放在内衣口袋里数小时。几天后，他发觉挨着内衣口袋的皮肤发红，其形状和装镭<a href="https://wiki.mbalib.com/wiki/样品" target="_blank" rel="noopener">样品</a>的玻璃管一样。又过了几天，皮肤开始破裂，成为溃疡。皮尔·居里也在自己身上作了一系列的实验，用镭射线对手上的皮肤作用数小时，几天后就出现同样的后果，发红、发炎。可见皮肤的损伤是由镭射线引起的。 </p><p>​     求同法是根据部分场合中所显示的关系来推论两现象间的因果联系，而且是以<a href="https://wiki.mbalib.com/wiki/相关" target="_blank" rel="noopener">相关</a>场合中有一个共同情况为基础的，因此，其前提与结论之间的联系不具有必然性。求同法的特点是：<strong>异中求同</strong>。 </p><h3 id="求异法"><a href="#求异法" class="headerlink" title="求异法"></a>求异法</h3><p><u>求异法是指，如果在被研究对象出现和不出现的两个场合中，仅有一个情况不同且仅出现在被研究现象存在的场合，那么，这个唯一不同的情况是被研究现象的原因(或结果)或必不可少的部分原因。</u> </p><p>​    故事： 加拿大洛文教授为了弄清候鸟迁徙之谜，曾将秋天捕捉的几只候鸟，在入冬后，一部分置于白昼一天短于一天的自然环境里，另外的置于日光灯照射之下的仿照白昼一天天延长的人工环境里。到了12月间，将两种环境里的候鸟全都放飞，结果发现，日光灯照射的候鸟像春天的候鸟一样而向北飞去，而未受El光灯照射的候鸟却留在原地。据此，洛文教授认为：候鸟迁徙的原因不是气温的升降，而是昼夜的长短。 </p><p>​      求异法是仅根据被研究现象出现与不出现的两种场合的情形来推论两现象间的因果联系的，尚未考察其他场合，并以当前情境中唯有一个情况不同为基础，因此，其前提与结论之间不具有必然性联系。 求异性的特点是：<strong>同中求异</strong>。 </p><h3 id="求同求异并用法"><a href="#求同求异并用法" class="headerlink" title="求同求异并用法"></a>求同求异并用法</h3><p>​     <u>求同求异并用法是指，如果仅有某一情况在被研究现象存在的若干场合中出现，而在被研究现象不存在的若干场合中不出现，那么这一情况是被研究现象的原因或结果或必不可少的部分原因。</u> </p><p>​    故事： 户外植物的叶子一般是绿色的。但把马铃薯、白薯、葱头、萝卜等放在地窖里，它们发芽长出的叶子都没有绿色。田里的韭菜、蒜都是绿叶，但在暗室里培养出来的韭菜、蒜都是黄色的。把一株在户外生长的有绿叶的植物移入暗室，它的绿色渐渐退去；若再把它移至户外，则绿色逐渐恢复。由此可见，阳光照射是植物叶子长成绿色的原因。 </p><p>​     求同求异并用法虽然包含了求同法和求异法的共同运用，但它的特点是两次求同，一次求异，即在对正，负两事例组分别求同的结果上，再次运用求异法进行推论。因而，求同求异并用法不是求同法与求异法的简单相继运用，而是一种相对独立的方法。 </p><h3 id="共变法"><a href="#共变法" class="headerlink" title="共变法"></a>共变法</h3><p>​     <u>共变法是指，如果在被研究现象发生变化的若干场合中，唯有一个情况也发生变化，那么，这个唯一变化的情况便是被研究现象的原因或结果。</u></p><p>​    故事： 1917年，美国的生理学家雅克洛布等人发现，在其他条件不变而气温正常变化的情况下，气温每降低8℃，果蝇的寿命可延长一倍。例如，果蝇在26℃的环境下活35～50天，在18℃的环境下大约活100天，在10℃的环境下可活200天。由此可断定，果蝇的寿命与气温有关。 </p><p>​     共变法适用于某种既定因素不能被消除但可以被减轻的情况，对此，求异法是无能为力的。共变法是根据部分场合中被研究现象与另一情况在数量或程度上的变化关系来推断现象问的因果联系的，这种量的变化虽呈现出一定的共变关系，但是，共变法的前提与结论之间不具有必然性联系。  共变法的特点是：<strong>同中求变</strong>。 </p><h3 id="剩余法"><a href="#剩余法" class="headerlink" title="剩余法"></a>剩余法</h3><p>​     <u>剩余法是指，如果已知某一复合的被研究现象中的部分是某情况作用的结果，那么这个复合现象的剩余部分就是其他情况作用的结果。</u> </p><p>​    故事：1885年，德国夫顿堡矿业学院的矿物学教授威斯巴克发现了一种新矿石。他首先请当时著名化学家李希特对矿石作定性分析，发现其中含有银、硫和微量的汞等。后来，他又请文克勒做一次精确的定量分析，一方面证明李希特对矿物成分的分析是正确的，但另一方面又发现，把各种化验出来的已知成分按百分比加起来，始终只得到93％，还有7％的含量找不到下落。文克勒认为，既然已知成分之和只得93％，那么剩余的7％必定是由矿物中含有的某种未知元素所构成。于是，他对矿石进行分离和提纯，终于得到了新元素。</p><p>​     剩余法的特点是：<strong>由余果求余因</strong>。但“余因”情况是比较复杂的，它可能是某种已知的原因中的某一部分，也可能是复合原因中的未知部分。由于通常所推论的“余因”大都是未知情况，因而剩余法是一种重要的发现方法。 </p><h1 id="演绎"><a href="#演绎" class="headerlink" title="演绎"></a>演绎</h1><h2 id="什么是演绎？"><a href="#什么是演绎？" class="headerlink" title="什么是演绎？"></a>什么是演绎？</h2><p><u>以一定的反映客观规律的理论认识为依据，从服从该认识的已知部分推知事物的未知部分的思维方法。其核心思想是从已知的前提或假设中，通过逻辑规则和推理步骤得出一个明确、确定的结论。</u></p><h2 id="演绎的重要性和应用领域"><a href="#演绎的重要性和应用领域" class="headerlink" title="演绎的重要性和应用领域"></a>演绎的重要性和应用领域</h2><p>​    演绎是逻辑证明的重要工具，它在思维过程中遵循确定性的逻辑规则，确保从前提中得出明确的结论。因此，只要我们选择可靠的前提，就可以有力地证明或反驳某个命题。</p><p>​    此外，演绎法还是作出科学预见的关键手段。通过运用演绎法，我们可以将一般理论应用于具体情境，从而进行准确的推断和预测。</p><p>​    在科学研究中，演绎法也扮演着重要的角色。它有助于形成新的概念，验证和发展科学理论。通过演绎思维方法，科学家能够建立起坚实的理论基础，推动科学知识的进一步发展。</p><h2 id="演绎法"><a href="#演绎法" class="headerlink" title="演绎法"></a>演绎法</h2><p>​    <u>由原因推向结果，由一般推向特殊的思维方法</u></p><h2 id="如何提高演绎能力：演绎法的形式"><a href="#如何提高演绎能力：演绎法的形式" class="headerlink" title="如何提高演绎能力：演绎法的形式"></a>如何提高演绎能力：演绎法的形式</h2><p>　　演绎推理有<strong>三段论、假言推理</strong>和<strong>选言推理</strong>等形式。</p><h3 id="三段论"><a href="#三段论" class="headerlink" title="三段论"></a>三段论</h3><p>​     <u>三段论，是指由两个简单判断作前提，和一个简单判断作结论组成的推理。三段论中包含三个部分：一是大前提；二是小前提；三是结论</u>。 </p><p>​    著名的亚里士多德三段论：</p><ul><li><p>大前提——所有的人都会死</p></li><li><p>小前提——苏格拉底是人</p></li><li><p>结论——所以苏格拉底会死。</p></li></ul><p>​     生活中有很多逻辑错误就是三段论汇总的 大前提或者小前提出了问题，他人在表达的时候，这些所谓的前提条件是被隐藏的，因果推论都符合三段论的形态， 当你能熟练运用三段论的眼光去看待这些推论的时候，就能很快的找到对方逻辑的谬误点。</p><h3 id="假言推理"><a href="#假言推理" class="headerlink" title="假言推理"></a>假言推理</h3><p>　　<u>假言推理是以假言判断为前提的推理。</u></p><p>　　假言推理分为<strong>充分条件假言推理</strong>和<strong>必要条件假言推理</strong>两种。</p><p>A、充分条件假言推理的基本原则是：小前提肯定大前提的前件，结论就肯定大前提的后件；小前提否定大前提的后件，结论就否定大前提的前件。如下面的两个例子：</p><p>　　如果一家公司想要在市场上获得成功，就必须提供高质量的产品和卓越的客户服务。某公司提供了高质量的产品和卓越的客户服务，因此，它在市场上取得了成功</p><p>　　如果一个图形是正方形，那么它的四边相等；这个图形四边不相等，所以，它不是正方形。</p><p>B、必要条件假言推理的基本原则是：小前提肯定大前提的后件，结论就要肯定大前提的前件；小前提否定大前提的前件，结论就要否定大前提的后件。如下面的两个例子：</p><p>只有当气温达到一定程度时，冰雪才会开始融化。今天的气温没有达到这个程度，因此，冰雪没有开始融化。</p><p>只有在电子设备的电池电量充足时，才能启动设备。这个设备无法启动，因此，电池电量不足。</p><h3 id="选言推理"><a href="#选言推理" class="headerlink" title="选言推理"></a>选言推理</h3><p>　　<u>选言推理是以选言判断为前提的推理。</u></p><p>　　选言推理分为<strong>相容的选言推理**</strong>和<strong>不相容的选言推理</strong>两种。</p><p>　　A、相容的选言推理的基本原则是：大前提是一个相容的选言判断，小前提否定了其中一个（或一部分）选言肢，结论就要肯定剩下的一个选言肢。</p><p>​        例如：这个三段论的错误，或者是前提不正确，或者是推理不符合规则；这个三段论的前提是正确的，所以，这个三段论的错误是推理不符合规则。</p><p>　　B、不相容的选言推理的基本原则是：大前提是个不相容的选言判断，小前提肯定其中的一个选言肢，结论则否定其它选言肢；小前提否定除其中一个以外的选言肢，结论则肯定剩下的那个选言肢。</p><p>　　例如：一个词，或者是褒义的、或者是贬义的，或者是中性的。“结果”是个中性词，所以，“结果”不是褒义词，也不是贬义词。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>​        逻辑推理，如同引言中的比喻，是我们思考世界运行规律的得力工具，驱使着我们穿越真理的迷雾。在逻辑的织网中，我们探索了归纳与演绎的要领，揭开了逻辑推理的神秘面纱。正如画布上的色彩与构图交织出壮丽画卷，逻辑推理在思维的广阔领域中为我们铺就通往智慧之路的康庄大道。</p><p>​        希望本文为你带来了更深入的逻辑洞见，不论你是求知若渴的学者，还是逻辑世界的冒险家，逻辑推理都将成为你探索未知的魔法钥匙。在逻辑的引导下，愿你的思维之旅永不止步，永远追寻真理的光芒，开启心灵的新旅程。</p>]]></content>
      
      
      <categories>
          
          <category> 人文社科 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人文社科 </tag>
            
            <tag> 思维工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RSS：简化信息获取的利器</title>
      <link href="/gong-ju-rss.html"/>
      <url>/gong-ju-rss.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>作为一个博客站长，一个喜欢博客且喜欢阅读其他博客的人来说，抛不开的一个就是RSS了； 一个来自上世纪的产物，一个曾经风光无限如今却快被多数人遗忘的东西… </p><p>在当今数字时代，信息爆炸性增长已成为常态，每天都有大量的新闻、博客文章、社交媒体更新、专业论坛等各种信息源涌现。人们常常感到不知从何处开始，如何追踪自己感兴趣的内容，以及如何避免信息过载。这种情况下，RSS（Really Simple Syndication）崭露头角，成为了简化信息获取的有力工具。</p><p>本文将介绍RSS的概念和作用，以及分析信息获取困扰的背景，为读者提供了解RSS并有效管理信息的基础知识。</p><h1 id="一、什么是RSS？"><a href="#一、什么是RSS？" class="headerlink" title="一、什么是RSS？"></a>一、什么是RSS？</h1><p>RSS，全称是Really Simple Syndication，即“真正简单的聚合”。<strong>它是一种基于XML格式的网站内容聚合和传输标准</strong>。通过RSS，网站的更新内容可以自动地推送给用户，使用户能够方便地浏览和订阅自己感兴趣的信息源。</p><blockquote><p> 简单点说：RSS是一个<strong>能让你在一个地方订阅</strong>各种感兴趣网站的工具 </p></blockquote><p>but…….知名在线 RSS 服务 Feedly（2018.11）、Inoreader（2020.4） 先后被墙，打着万物皆可RSS大旗的 RssHub 官方域名也被墙了（2020.3）， iOS 端最多好评的 RSS 阅读器 Reeder 也于不久前在国区被下架（2020.9）… </p><blockquote><p>目前个人使用的是“ RSS Feed Reader ” 谷歌浏览器插件</p></blockquote><h1 id="二、RSS的工作原理"><a href="#二、RSS的工作原理" class="headerlink" title="二、RSS的工作原理"></a>二、RSS的工作原理</h1><p>RSS的基本工作流程：</p><ol><li><p>发布者创建RSS文件：网站的所有者或发布者会创建一个包含网站最新内容的RSS文件。这个文件通常以XML格式编写，其中包括了文章标题、摘要、发布日期等信息。</p></li><li><p>发布者更新内容：当发布者在网站上发布新的内容，他们将相应的信息添加到RSS文件中。这可以手动完成，但也可以通过自动化工具来实现，这样一旦有新内容发布，RSS文件就会相应更新。</p></li><li><p>读者订阅RSS源：读者希望获取特定网站的更新时，他们可以使用RSS阅读器（也称为RSS客户端）来订阅该网站的RSS源。这通常涉及复制并粘贴RSS源的URL链接到阅读器中。</p></li><li><p>阅读器定期检查更新：一旦读者订阅了RSS源，他们的RSS阅读器会定期检查该源是否有新内容。这个检查频率可以由读者自行设置，通常是每隔几分钟或几小时检查一次。</p></li><li><p>新内容自动推送：当RSS阅读器发现有新的内容发布时，它会自动将这些内容从RSS源中提取出来，并以可阅读的格式显示给读者。这些新内容通常以标题、摘要和链接的形式呈现，读者可以选择点击链接以获取更多信息。</p></li></ol><p>通过这个简单而高效的工作原理，RSS使<strong>读者能够轻松访问多个网站的最新内容，而不必逐个网站进行查看</strong>。这不仅节省了时间，还减轻了信息过载的压力，让人们更加方便地跟踪他们感兴趣的主题和话题。</p><h1 id="三、为什么要使用RSS？"><a href="#三、为什么要使用RSS？" class="headerlink" title="三、为什么要使用RSS？"></a>三、为什么要使用RSS？</h1><p><strong><em>人的注意力是有限的</em></strong>，在这个信息爆炸和技术飞速发展的时代，我们经常会发现自己被推送式的内容所淹没，这可能会分散我们的注意力，让我们<strong>陷入信息过载的境地</strong>。</p><p><strong><u>“技术应当解放人的思想，而不是捆绑人的注意力；应当激发个体的创造力，而不是浪费宝贵的时光。”</u></strong></p><p>对于那些真正明白自己需要什么的人来说，使用RSS是一个非常明智的选择。因为RSS<strong>就是一个不一样的对抗平台推荐算法</strong>，让个人集中注意力的技术，它真正做到了<strong>“内容聚合”，“无推荐算法”</strong>；</p><p>首先，<strong>RSS能够真正给你一个自己决定看什么的机会</strong>。与社交媒体和推荐算法不同，RSS不会主动向你推送内容，而是等待你主动订阅感兴趣的网站和源。这意味着你可以完全掌握自己的信息流，不再受制于平台的算法，从而获得更多的自由。</p><p>其次，要使用RSS，你得承认：<strong>大多数人很容易陷入被毫无意义的推荐内容浪费了时间的处境</strong>。社交媒体和推荐算法往往会将大量无关紧要的信息呈现给你，而RSS则需要你主动选择和管理订阅源。这也正是RSS的魅力所在，它让你能够真正做到内容聚合，只看那些你真正感兴趣的内容，而不必受到无休止的推荐内容的干扰。</p><p>最后，使用<strong>RSS的一个重要优势是它不依赖于推荐算法</strong>。许多社交媒体和新闻应用依赖于复杂的算法来决定向你推送什么内容，而这些算法可能会受到商业利益的影响，导致你看到的内容不一定是最有价值或最相关的。RSS则避免了这个问题，它只是简单地将订阅源的最新内容传递给你，不加干扰，让你自己来判断内容的价值。</p><p>综上所述，使用RSS可以让你摆脱信息过载，获得更多自主权，真正掌握自己的信息获取过程。如果你希望在浩如烟海的信息中找到真正有价值的内容，并且不想被推荐算法所左右，那么RSS是一个强大的工具，它可以帮助你建立一个属于自己的信息阅读体验。</p><h1 id="四、如何使用RSS？"><a href="#四、如何使用RSS？" class="headerlink" title="四、如何使用RSS？"></a>四、如何使用RSS？</h1><ol><li><p>选择合适的RSS阅读器：选择一款适合自己的RSS阅读器应用或平台。有许多不同的RSS阅读器可供选择，包括桌面应用、移动应用和在线平台。一些受欢迎的RSS阅读器包括Feedly、Inoreader、Reeder（适用于iOS和macOS）、以及Google Reader（已停用）的替代品。个人使用的是谷歌浏览器的 RSS Feed Reader ，直接谷歌商店搜索便可</p></li><li><p>订阅感兴趣的网站或博客：一旦选择了RSS阅读器，就可以开始订阅感兴趣的网站、博客或新闻源。通常，网站的首页或文章页面会提供一个RSS订阅按钮或链接，你可以点击它来添加该源到你的RSS阅读器。</p></li><li><p>设置过滤器和标签：为了更好地组织和筛选内容，许多RSS阅读器提供了过滤器和标签功能。你可以创建标签，将相关的订阅源分类，以便更容易找到感兴趣的内容。此外，你还可以设置关键词过滤器，根据特定关键词或主题来筛选文章，确保只看到你关心的信息。</p></li><li><p>整理和管理订阅源：随着时间的推移，你可能会订阅越来越多的源。因此，定期整理和管理订阅源是很重要的。你可以删除不再感兴趣的源，添加新的源，或重新组织你的标签和分类，以确保你的RSS阅读器保持整洁和高效。</p></li></ol><h1 id="五、RSS未来可能的发展趋势"><a href="#五、RSS未来可能的发展趋势" class="headerlink" title="五、RSS未来可能的发展趋势"></a>五、RSS未来可能的发展趋势</h1><p>未来，RSS阅读器可能会<strong>更加强调跨平台和多设备支持</strong>。这意味着你可以在不同的设备上同步和访问你的RSS订阅，无论是在桌面电脑、平板电脑还是手机上。这将使用户更加灵活地获取他们的信息流，不受设备限制。</p><p>为了提供更丰富的用户体验，未来的RSS阅读器可能会<strong>更深入地整合社交媒体和推荐系统</strong>。这意味着你可以在一个应用中同时查看来自不同来源的内容，包括社交媒体帖子、博客文章和新闻。同时，推荐系统可以根据你的兴趣和行为习惯，向你推荐相关的内容，使你更容易发现新的信息源。</p><p>未来的RSS阅读器可能会<strong>更加注重个性化定制功能</strong>。这意味着用户可以更灵活地定制他们的阅读体验，包括字体大小、排版风格、主题颜色等。此外，用户还可以根据自己的需求，创建自定义的标签和过滤器，以更精确地筛选和组织内容。</p><p>这是我个人对未来RSS的发展的看法，希望它发展地更好^_^</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>作为一种简化信息获取的利器，为用户提供了自由、个性化、高效的信息订阅和阅读体验。通过了解RSS的定义、原理、应用领域、使用方法和未来发展，我们可以清晰地认识到它的价值和优点。</p><p>尝试和享受RSS带来的便利和效率，无论是在新闻、博客、社交网络、学术研究还是职业发展方面，RSS都将成为你的得力助手，帮助你更高效地获取所需信息，提升生活和工作的质量。时刻记住，技术应当是为了给人们带来自由和发展，而不是接管人们的注意力，浪费宝贵的时间。选择RSS，选择自主、高效和个性化的信息获取方式。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> RSS </tag>
            
            <tag> 信息聚合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>冥想之外：思绪归零的个人心理技巧</title>
      <link href="/ren-wen-she-ke-ji-xian-gui-ling.html"/>
      <url>/ren-wen-she-ke-ji-xian-gui-ling.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在现代繁忙的生活中，我们时常感到思绪纷乱，焦虑不安。在这种情况下，让自己平静下来，摆脱焦躁的情绪，让自己的注意力集中于此时此刻，显得尤为重要。众所周知的有“冥想”这个方法，冥想不得不说是一种方法，但是个人对其需要做的时间周期与深度，目标方法，感到有一定的局限性，于是自己摸索一种类似，但是又有所区别的方法，一种特别的心理技巧。</p><blockquote><p>冥想（Meditation）是一种精神修炼的技巧，通常通过定期练习来达到放松、专注、自我觉察和内心平静的状态。冥想的主要目标是促进身体和心灵的平衡，帮助个体减轻压力、焦虑、疲劳，提高心理健康和全面幸福感。</p></blockquote><p>冥想通常需要更长的时间来实现深度的内省和放松，能够快速而有效地调整我们的思绪状态，让思绪在一瞬间归为零，成为一项珍贵的技巧。这项我称之为 “极限归零” 的心理技巧，可以帮助我们摆脱杂乱的思绪，进入一种虚无的状态，并从这个虚无中的源点重新开始。它不仅仅是一种思维控制技巧，更是一种自我管理的工具，有助于提高专注力、减轻焦虑和增强心理平静。</p><h1 id="心理技巧"><a href="#心理技巧" class="headerlink" title="心理技巧"></a>心理技巧</h1><h2 id="极限归零"><a href="#极限归零" class="headerlink" title="极限归零"></a>极限归零</h2><p><strong><em>将思绪在一瞬间归为零，进入一种虚无的状态，在虚无中衍生一个源点，从这个虚无的状态中的源点重新开始，是一种思维控制的技巧，通常被用于提高专注力、减轻焦虑和增强心理平静，这个过程我称之为“极限归零”；</em></strong></p><h2 id="效果和用途"><a href="#效果和用途" class="headerlink" title="效果和用途"></a>效果和用途</h2><ol><li><p>提高专注力：”极限归零” 可以帮助你在需要集中注意力的时候摆脱干扰，快速进入专注状态。通过将思绪清空，你可以更轻松地专注于一项任务或问题。</p></li><li><p>减轻焦虑：这种技巧有助于减轻焦虑和紧张情绪。当你感到焦虑或不安时，通过 “极限归零”，你可以使自己平静下来，减轻心理压力。</p></li><li><p>提高心理平静：进入虚无状态并从源点重新开始有助于让你保持冷静和平静，特别是在面对紧急或高压的情况下。这有助于更好地应对挑战和压力。</p></li><li><p>提高创造力：清空思绪并从虚无状态开始可能有助于激发创造性思维。这可以为新想法和解决方案的涌现提供空间。</p></li><li><p>自我调整：”极限归零” 是一种自我调整技巧，可以帮助你在不同情境下更好地掌控自己的情绪和思维，从而更好地应对生活中的变化和挑战。</p></li></ol><h2 id="如何使用？"><a href="#如何使用？" class="headerlink" title="如何使用？"></a>如何使用？</h2><blockquote><p><strong>步骤：</strong></p><ol><li>自我觉察：在意识到自己需要思维转变和心理平静时，先停下来，意识到当前的思绪状态和情绪。</li><li>快速深呼吸：通过进行深呼吸来缓解紧张和焦虑情绪。深吸气，然后慢慢地呼气，专注于呼吸的过程，让自己感受到身体放松和思绪清空。</li><li>平静思维：闭上眼睛，尝试将注意力从外界转移到内心，让自己进入冥想或放松的状态。不要强迫自己去抵制思绪，而是接受它们的存在，并逐渐将注意力从思绪中分离出来。</li><li>虚无状态：在平静思维的基础上，想象自己置身于一个没有形式、没有界限的虚无状态中。将自己想象成一个空白的画布，没有任何思绪或干扰。</li><li>构建源点：在虚无状态中，将注意力集中在一个小的光点或源点上。这个源点代表着新的起点，纯粹和平静。感受它的存在和能量，并将自己的注意力完全投入其中。</li><li>重新开始：一旦你在虚无状态中找到了源点，将注意力集中在它上面，并开始重新思考、计划或执行你的任务。从这个源点出发，让自己进入全新的思维和行动状态。</li></ol></blockquote><p>每一个步骤都不是随随便便去做，而是需要一定的自我意识，去训练，去达到效果，接下来就是具体的实现方法，重点黑体为核心要点</p><h3 id="1自我察觉"><a href="#1自我察觉" class="headerlink" title="1自我察觉"></a>1自我察觉</h3><p>自我觉察是一种训练和习惯养成的过程。需要我们<strong><em>时刻保持警觉，观察自己的身体反应和思维模式</em></strong>，并通过<strong>调整思维方式</strong>和<strong>培养冷静思考</strong>的能力来控制自己的情绪和行为。 </p><ol><li>保持警觉：将自己保持在一种警觉状态下，时刻监控自己的情绪和思维，以便及时发现不良情绪或思维模式的出现。可以时不时地问自己：“我现在的感觉如何？我是否紧张、焦虑或激动？”</li><li>观察身体反应：情绪的出现会引起一系列的身体反应，例如心跳加速、面部肌肉紧绷等。通过观察自己的身体反应，可以更加准确地察觉到自己的不良情绪，从而及时进行调整和控制。可以时刻关注自己的呼吸、心跳和其他身体反应。</li><li>调整思维模式：负面情绪的产生往往与不良的思维模式有关。通过调整思维方式，可以减轻负面情绪的影响。可以将注意力转移到其他事物上，或者寻找解决问题的方法，从而减少情绪的干扰。</li><li>培养冷静思考的能力：在冷静的状态下，可以更好地控制自己的情绪和行为。通过训练，可以提高自己的处事能力和应对负面情绪的能力。将自己置身于一个冷静的环境中，或者进行冥想和放松练习，以帮助恢复内心的平静和冷静。</li></ol><p><strong>自我察觉尤为重要，这是将思绪归零必要的前提，察觉自己，然后才有拉回思绪的结果，保持警觉，不让自己被思绪“牵着走”</strong></p><h3 id="2快速深呼吸"><a href="#2快速深呼吸" class="headerlink" title="2快速深呼吸"></a>2快速深呼吸</h3><p>这个步骤，靠自己的感觉， <strong>快速深呼吸</strong>的原理在于通过调整呼吸来刺激迷走神经系统，从而降低交感神经系统的兴奋状态，使身体和心理得到放松和平静， 这点多尝试便可有一定的效果</p><h3 id="3平静思维"><a href="#3平静思维" class="headerlink" title="3平静思维"></a>3平静思维</h3><p>将<strong>注意力</strong>从<strong>外界转移到内心</strong>，<strong>人的注意力是有限的</strong>，注意力尤为珍贵，把注意力从外借转移到内心，便不再受外界干扰的影响，更加专注于自己内心的感受和情绪，这时候对它们进行有效的处理和调整是尤为容易。 原理在于通过专注和接受思绪的存在，逐渐将注意力从思绪中分离出来，使思维平静下来。例如，当你闭上眼睛，尝试将注意力集中在呼吸上，观察呼吸的流动，并接受任何出现的想法和感受。</p><h3 id="4虚无状态"><a href="#4虚无状态" class="headerlink" title="4虚无状态"></a>4虚无状态</h3><p>将自己<strong>想象</strong>成<strong>置身于</strong>一个<strong>没有形式和界限</strong>的<strong>虚无状态中</strong>；原理在于通过<strong>想象和视觉化</strong>来创造一种<strong>空白的感觉</strong>，以减少外界干扰和思绪的干扰。例如，你可以想象自己正在漂浮在太空中，并且<strong>周围没有任何物体或景象，只有宁静和空灵</strong>。此时此刻，你就是你，只有你自己</p><h3 id="5构建源点"><a href="#5构建源点" class="headerlink" title="5构建源点"></a>5构建源点</h3><p>这一步是在虚无状态中将<strong>注意力集中在一个小的光点或源点上</strong>。原理在于通过将注意力聚焦在一个特定的事物或形象上，帮助我们找到新的起点和集中注意力的焦点。例如，你可以想象在虚无状态中有一个光点，它代表着纯净和平静，然后将自己的注意力完全投入其中。从这个点，便可以发散开来，发散你想要思考的方向；</p><h3 id="6重新开始"><a href="#6重新开始" class="headerlink" title="6重新开始"></a>6重新开始</h3><p>在虚无状态中找到了源点，将注意力集中在它上面，并开始重新思考、计划或执行任务。这一步的原理是通过从源点出发，让自己进入全新的思维和行动状态。例如，当你在虚无状态中找到源点后，你可以将注意力集中在源点上，并开始制定新的计划或采取新的行动。</p><p>通过逐步执行上述步骤，可以更好地调整自己的思维和心理状态。这个过程有助于缓解紧张和焦虑，清空思绪，重新集中注意力，并提高工作效率。</p><h2 id="涉及的心理学知识"><a href="#涉及的心理学知识" class="headerlink" title="涉及的心理学知识"></a>涉及的心理学知识</h2><p>在这个过程中，涉及到了以下心理学知识与技巧：</p><ol><li><p>注意力调控：这个过程中需要将注意力从外界转移到内心，帮助你集中注意力并减少干扰。这是一种注意力调控的技巧，可以通过训练来提高。</p></li><li><p>深呼吸：深呼吸是一种放松身心的方法，可以通过刺激迷走神经系统来缓解紧张和焦虑。深呼吸有助于平静思维和放松身体，是放松和冥想的常用技巧。</p></li><li><p>冥想和放松：在平静思维和进入虚无状态之前，通过冥想和放松练习来提高自我觉察和自我控制的能力。冥想可以帮助培养专注力和内省的能力，同时也是一种缓解压力和焦虑的技巧。</p></li><li><p>想象和视觉化：在虚无状态中，通过想象和视觉化将自己置身于一个没有形式和界限的状态中。这种想象力和视觉化技巧有助于创造一种心理空间，并帮助你从思维和情绪的困扰中解脱出来。</p></li><li><p>心理平静和情绪调节：通过进入虚无状态和凝视源点，可以帮助你实现心理平静和情绪调节。这种技巧可以帮助你摆脱焦虑、烦躁和压力，提高心理的平静和稳定。</p></li><li><p>自我接受和无条件接纳：这个过程中强调了接受当前的思绪和情绪存在，并不试图去抵抗或改变它们。这是一种自我接纳和无条件接纳的心理技巧，可以帮助你放下内心的抗拒和战斗，更好地控制思维和情绪。</p></li></ol><h1 id="与冥想的异同"><a href="#与冥想的异同" class="headerlink" title="与冥想的异同"></a>与冥想的异同</h1><p><strong>相似之处</strong>：</p><ol><li><p><strong>集中注意力</strong>：两者都涉及到集中注意力和深度放松的过程。在两者中，你都需要努力排除杂念，将思绪带入一个更平静、宁静的状态。</p></li><li><p><strong>深呼吸</strong>：在练习过程中，深呼吸通常是一个共同的元素。深呼吸有助于放松身体和帮助你进入更集中的状态。</p></li><li><p><strong>减轻焦虑</strong>：无论是极限归零还是冥想，都可以帮助减轻焦虑、降低压力和增强心理平静。</p></li></ol><p><strong>差异之处</strong>：</p><ol><li><p><strong>目标和方法</strong>：<strong>极限归零是一种特定的思维控制技巧，其目标是在瞬间清空思绪并重新聚焦</strong>。它通常涉及到想象一个源点，并从那里重新开始。冥想，另一方面，通常是一种更广泛的练习，旨在深度冥想和自我觉察。冥想可以有多种方法和目标，不仅仅局限于思绪的清空。</p></li><li><p><strong>时间和深度</strong>：<strong>极限归零旨在在瞬间达到清空思绪的状态</strong>，而冥想通常需要更长的时间来实现深度的内省和放松。冥想可能会涉及到更长的练习时间和更深的冥想状态。</p></li><li><p><strong>正式性</strong>：冥想通常有一定的正式性和指导，包括特定的冥想技巧、位置和指导。极限归零可以更加自由和个人化，因为它是你自己发展的方法，可以根据需要进行调整。</p></li></ol><p>它与冥想有些相似之处，但它更侧重于快速的思维控制和专注，而不是深度的冥想状态。</p><blockquote><p>如果你发现极限归零对你有效，那么它可以成为你的自我管理工具，与冥想一起使用或独立使用，根据需要进行选择。重要的是找到适合你的方法来提高心理平静和专注力。</p></blockquote><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>依托于相关的心理学原理，做出该心理技巧；”极限归零” 这一心理技巧为我们在瞬间清空思绪、重新聚焦和提高专注力提供了一个有力的工具。与传统的冥想不同，这个方法更加迅速且灵活，可以在日常生活中应用，帮助我们处理压力、焦虑和思绪纷乱的情况。通过自我察觉、深呼吸、平静思维、虚无状态、构建源点以及重新开始这些步骤，我们可以更好地掌控自己的情绪和思维，进而提高心理平静和专注力。</p><p>在现代快节奏的生活中，我们经常需要迅速调整自己的状态，应对各种挑战。当你感到无所事事的时候，当你觉得有选择困难症的时候，当你面对将要到来的考试的时候……</p><p>“极限归零” 可以帮助我们在压力下保持冷静，提高创造力，以更加平和的心态面对生活。不同于冥想，它是一种个人化的技巧，可以根据需要进行调整和使用。通过不断练习和改进，我们可以更好地掌握这一技巧，使它成为我们生活中的有力伙伴，助力我们实现心理平静和全面幸福感。</p>]]></content>
      
      
      <categories>
          
          <category> 人文社科 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人文社科 </tag>
            
            <tag> 心理技巧 </tag>
            
            <tag> 自我管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>随笔-用英语思考</title>
      <link href="/sui-bi-yong-ying-yu-si-kao.html"/>
      <url>/sui-bi-yong-ying-yu-si-kao.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>经常看到一系列问题，为什么要学好英语？如何学好英语？英语学习的辅助有哪些？如何达到母语者的水平？</p><p>这是我个人在英语学习的过程中，通过社区，论坛等经常看到的问题，我也在学习中不断去思考这些问题，或多或少都有不少收益； 了解英语学习的方法论，并且利用学习辅助工具，这确实给英语的学习起到了莫大的帮助；</p><p>在不断的学习过程中，看了油管一位博主的视频 “<em>如何用英语思考</em>”，个人非常赞同其提到的六个步骤，且个人将运用到自己的英语学习当中。为此，总结其视频并写下该文章。</p><p>英语作为全球通用语言之一，掌握用英语思考的技巧不仅可以提升语言能力，还可以拓展思维能力。无论是用于日常交流、学习或职业发展，用英语思考都是一项非常有价值的技能。</p><h1 id="为什么要学习英语？"><a href="#为什么要学习英语？" class="headerlink" title="为什么要学习英语？"></a>为什么要学习英语？</h1><p>现在科技进步得这么快，各种翻译工具，翻译黑科技出现，学习英语还有必要嘛？这里引用一句：</p><p><strong><em>“学习一门外语并非只是学习一种工具，而是拥有了解别人的窗户和表达自己的途径。” - 尤金·韦伯</em></strong></p><p>不得不承认科技的进步给语言翻译方面提供了极其便捷与高效的方式，但是， <strong>人与人之间用语言进行直接交流的魅力和深度是无法被科技所完全取代的</strong>。</p><h2 id="1-这是针对人与人之间的交互："><a href="#1-这是针对人与人之间的交互：" class="headerlink" title="1.这是针对人与人之间的交互："></a>1.这是针对人与人之间的交互：</h2><p>当我们与他人面对面交流时，除了语言本身的含义，还能通过声音的音调、表情的变化、肢体语言的细微动作等多种方式传递更丰富的信息。这些非语言的元素在交流中起着重要的作用，能够帮助我们更好地理解对方的情感、意图和态度。利用工具的同时，将注意力平分给了翻译的过程，剩余的注意力才是人与人之间交流的信息互动，这将是一种”注意力的浪费”。</p><h2 id="2-这是针对人与其它媒介之间的交互："><a href="#2-这是针对人与其它媒介之间的交互：" class="headerlink" title="2.这是针对人与其它媒介之间的交互："></a>2.这是针对人与其它媒介之间的交互：</h2><p>逛社区，逛论坛，学习过程中阅览非母语资料，或者看一些非母语的视频； 是，这些同样可以使用翻译工具，浏览器插件也好，翻译软件也罢，这些大多数人也就是如此使用的。 但大多数人，总会遇到吃瘪的时候：</p><p><strong>1工具的触发：</strong>这关乎效率，在一次次的使用工具的过程中，所要做的触发动作，譬如点击，右键，移动，甚至复制等一系列操作， 这些操作可能会带来一定的不便，需要用户主动触发并进行相应的操作才能获取翻译结果。如果频繁使用，可能会降低效率并打断流畅的阅读或学习过程。 </p><p><strong>2工具的局限：</strong> 翻译工具可能存在一些局限性，无法完全准确地翻译所有内容。特别是对于复杂的句子结构、文化隐含意义或特定领域的术语，翻译工具可能无法提供准确的翻译。这可能导致误解或理解不完全。 </p><p><strong>3工具的场景：</strong> 使用电脑，或者手机浏览特定的论坛，社区的时候，此类社区并无提供翻译功能，该场景下，就是只能阅读该原文，这时候，去找所谓的屏幕翻译，属实是太累了…… Twitter，Reddit，Quora等，在手机上使用，其软件不带有翻译功能，手机上的翻译软件上的操作，需要花费两倍以上的时间，更何况查找的时候，是在不断地滑动屏幕的，不说了，亲身体验，该场景下属实心累┓(;´_｀)┏</p><p>有时候，学习一件技能的意义，是需要自己去亲身体验，去感受拥有与未拥有的时候的差异，更好理解学习此技能的意义；</p><blockquote><p> “Tell me and I forget, teach me and I may remember, involve me and I learn.” - Benjamin Franklin</p><p> “告诉我，我就会忘记;教我，我可能会记得;让我参与，我就会学习。”——本杰明·富兰克林</p></blockquote><h1 id="为什么要用英语思考？"><a href="#为什么要用英语思考？" class="headerlink" title="为什么要用英语思考？"></a>为什么要用英语思考？</h1><p>在全球化时代，英语已成为国际交流的主要工具。通过用英语思考，我们可以更自如地表达自己的想法，并更好地与他人进行沟通。此外，用英语思考还可以提升我们的语言能力，加深对英语语法、词汇和表达方式的理解。</p><p>个人觉得主要有以下三点：</p><p><strong>1.使用英语思考可以提供一种跨文化的思维方式。</strong>语言是我们思维的工具，不同的语言背后包含了不同的文化和认知模式。通过使用英语思考，我们可以接触到更广泛的信息和观点，并从不同的文化角度思考问题。这种跨文化思维可以培养我们的灵活性、开放性和全球视野，促进跨文化交流和理解。</p><p><strong>2.使用英语思考可以提升语言能力和思维的表达能力。</strong>语言与思维密切相关，它们相互作用并相互影响。当我们使用英语思考时，我们需要将想法、概念和信息转化为英语的词汇和句法结构。这个过程促使我们更加深入地理解和组织我们的思维，并通过语言表达出来。这种思维转化和语言表达的训练可以提升我们的语言能力和思维的逻辑性。</p><p><strong>3.语言对我们的思维和认知有着重要的影响。</strong>心理学中的一些研究表明，不同的语言有不同的词汇、语法和表达方式，它们可以塑造我们对世界的感知和理解方式。通过使用英语思考，我们可以接触到英语语境中的思维模式和概念框架，这有助于我们以不同的视角思考问题，发展多元化的思维能力。</p><h1 id="如何用英语思考？"><a href="#如何用英语思考？" class="headerlink" title="如何用英语思考？"></a>如何用英语思考？</h1><p>总结下来有以下六个阶段：</p><p>步骤1：在你周围的物体中用英语默念它们的名称。<br>步骤2：用简单的句子进行思考。<br>步骤3：与自己用英语进行小对话。<br>步骤4：将日常生活中的一个事物改为英语。<br>步骤5：保持记录，确保每天都这样做。<br>步骤6：用英语回顾你的一天。</p><p>此总结基于youtube上博主 Rachel’s English 的视频：<a href="https://youtu.be/SJOnhWiJArM?si=4gwLDKZzT_5JVcHB" target="_blank" rel="noopener">如何用英语思考</a></p><h2 id="步骤1：在你周围的物体中用英语默念它们的名称。"><a href="#步骤1：在你周围的物体中用英语默念它们的名称。" class="headerlink" title="步骤1：在你周围的物体中用英语默念它们的名称。"></a>步骤1：在你周围的物体中用英语默念它们的名称。</h2><p>当你看到一本书，你可以默念”book”（书），如果看到一杯咖啡，你可以默念”coffee”（咖啡）。 </p><p>这一步很有意义，用母语者的思维，看到的东西，脑子里的第一反应是对应的英语单词，跳过“翻译成中文”这个阶段。</p><blockquote><p>益处</p><ul><li>增加词汇量：通过默念物体名称的英文，可以扩展你的词汇量。</li><li>提高语音和发音：默念这些英文单词有助于提高你的语音和发音准确性。</li></ul></blockquote><h2 id="步骤2：用简单的句子进行思考。"><a href="#步骤2：用简单的句子进行思考。" class="headerlink" title="步骤2：用简单的句子进行思考。"></a>步骤2：用简单的句子进行思考。</h2><p>当你想知道时间时，用英语思考：”What time is it?”（现在几点了？）或者当你要选择午餐时，用英语思考：”What should I have for lunch?”（我应该吃什么午餐呢？）</p><p>英语离不开各种种简单句，那些长难句，很少在真实的英语交际上会使用，而更多的是书面上的。把简单句学好，脱口而出你想要表达的，清晰易懂。</p><blockquote><p>益处</p><ul><li>练习基本句子结构：用简单的句子思考可以帮助你熟悉英语的基本句子结构，加强语法的理解。</li><li>建立思维逻辑：用英语进行思考可以帮助你培养清晰的思维逻辑和表达能力。</li></ul></blockquote><h2 id="步骤3：与自己用英语进行小对话。"><a href="#步骤3：与自己用英语进行小对话。" class="headerlink" title="步骤3：与自己用英语进行小对话。"></a>步骤3：与自己用英语进行小对话。</h2><p>当你找手机时，你可以和自己用英语对话：”Where did I put my phone? I remember having it in the living room. Maybe it’s on the coffee table.”（我把手机放在哪里了？我记得我在客厅有看到它。也许它在咖啡桌上。） </p><p>与自己对话，感受英语的存在</p><blockquote><p>益处</p><ul><li>提高口语表达能力：与自己对话可以练习口语表达能力，提高流利度和自信心。</li><li>强化记忆和思维能力：回忆和思考解决问题的过程可以加强记忆和思维能力。</li></ul></blockquote><h2 id="步骤4：将日常生活中的一个事物改为英语。"><a href="#步骤4：将日常生活中的一个事物改为英语。" class="headerlink" title="步骤4：将日常生活中的一个事物改为英语。"></a>步骤4：将日常生活中的一个事物改为英语。</h2><p>当你坐在椅子上时，用英语思考：”I am sitting on a chair.”（我坐在一把椅子上。）；当你穿上衣服时，用英语思考：”I am putting on a shirt.”（我穿上一件衬衫。） </p><blockquote><p>益处</p><ul><li>学以致用：将日常事物命名为英文可以加深对词汇的记忆和理解，让你在实际生活中更自如地使用英文表达。</li></ul></blockquote><h2 id="步骤5：保持记录，确保每天都这样做。"><a href="#步骤5：保持记录，确保每天都这样做。" class="headerlink" title="步骤5：保持记录，确保每天都这样做。"></a>步骤5：保持记录，确保每天都这样做。</h2><p>在日记本中记录下你的英语思考过程，例如：”Today, when I was preparing breakfast, I thought in English about what ingredients I needed. It helped me practice my vocabulary and sentence structures.”（今天，当我准备早餐时，我用英语思考我需要什么食材。这帮助我练习了我的词汇和句子结构。） </p><blockquote><p>益处</p><ul><li>追踪进展：记录你的学习过程可以帮助你观察自己的进展并找出需要改进的地方。</li><li>建立学习习惯：坚持记录每天的学习经历可以培养良好的学习习惯，使你更有条理地学习英语。</li></ul></blockquote><h2 id="步骤6：用英语回顾你的一天。"><a href="#步骤6：用英语回顾你的一天。" class="headerlink" title="步骤6：用英语回顾你的一天。"></a>步骤6：用英语回顾你的一天。</h2><p> 在结束一天之前，用英语回顾你的一天，思考你做了什么以及你的感受。例如：”Today was a busy day at work. I had several meetings and completed important tasks. In the evening, I went for a walk in the park and enjoyed the beautiful weather.”（今天在工作上很忙碌。我有几个会议并完成了重要任务。晚上，我去公园散步，享受美好的天气。） </p><blockquote><p>益处</p><ul><li>强化应用能力：用英语回顾一天的经历可以让你将语言应用于实际情境，加深对词汇和句子的记忆和理解。</li><li>提高口语流利度：回顾一天的经历并用英语进行表达可以提高口语流利度和思维转换的能力。</li></ul></blockquote><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>用英语的方式去思考，获得英语思维，掌握用英语思考的技巧不仅可以提升语言能力，还可以拓展思维能力；语言的学习是潜移默化的，它并不像其他技能那样，循规蹈矩地去学习，而是在万千场景中，不断变化的事物中，学习与使用。当您意识到自己已经开始用英语思考时，这是非常令人激动的，我希望您能感受到！ 祝你也祝我^_^</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思维 </tag>
            
            <tag> 英语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PEST思维模型解析</title>
      <link href="/shu-fen-pest-fen-xi-mo-xing.html"/>
      <url>/shu-fen-pest-fen-xi-mo-xing.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="PEST分析模型"><a href="#PEST分析模型" class="headerlink" title="PEST分析模型"></a>PEST分析模型</h1><p>PEST分析法是一种战略管理工具，用于评估和分析外部环境中的关键因素，以便组织和企业可以更好地了解其所处的环境并做出更明智的决策。<strong>PEST代表了四个关键环境要素，分别是政治（Political）、经济（Economic）、社会（Social）和技术（Technological）</strong></p><h2 id="四要素含义"><a href="#四要素含义" class="headerlink" title="四要素含义"></a>四要素含义</h2><ol><li><p>政治（Political）：政治要素涉及政府政策、法规、政治稳定性、政府领导层的决策等。这些因素可以对企业的运营和发展产生直接影响，因此了解政治环境对业务决策至关重要。</p></li><li><p>经济（Economic）：经济要素考虑了国家和全球经济的状况，包括通货膨胀率、汇率、利率、就业率等。了解经济趋势和挑战对企业的财务健康和市场机会至关重要。</p></li><li><p>社会（Social）：社会要素关注人口、文化、社会价值观、消费者行为等。企业需要了解社会趋势，以适应不断变化的消费者需求和社会期望。</p></li><li><p>技术（Technological）：技术要素涉及科技创新、研发、数字化趋势以及技术基础设施。企业需要跟踪和采用新技术，以提高效率、创新产品和服务，并保持竞争力。</p></li></ol><h2 id="目的和意义"><a href="#目的和意义" class="headerlink" title="目的和意义"></a>目的和意义</h2><ol><li><p><strong>了解外部环境</strong>：PEST分析提供了一种系统性的方法，帮助企业全面了解其周围的外部环境。这包括政治、经济、社会和技术因素，这些因素可能会直接或间接地影响企业的运营和业务。</p></li><li><p><strong>及时发现变化</strong>：通过PEST分析，企业可以敏锐地捕捉外部环境中的变化和趋势。这包括政策法规的变化、市场需求的演变、竞争格局的变化等。及时发现这些变化使企业能够更迅速地适应，减少风险，抓住机遇。</p></li><li><p><strong>为决策提供依据</strong>：PEST分析为战略决策提供了可靠的依据。通过深入了解外部环境，企业可以更明智地规划未来的方向，资源分配，市场进攻策略和风险管理计划。</p></li><li><p><strong>预测趋势</strong>：PEST分析有助于企业预测政治、经济、社会和技术趋势。这有助于企业制定长期战略，使其更好地适应未来的发展和变化。</p></li><li><p><strong>发现机会和风险</strong>：PEST分析不仅有助于发现市场机会，还能帮助企业识别可能的风险和挑战。这使企业能够更有针对性地利用有利条件，同时有效地应对潜在威胁。</p></li></ol><h2 id="步骤和方法"><a href="#步骤和方法" class="headerlink" title="步骤和方法"></a>步骤和方法</h2><ol><li><p><strong>明确定义分析目标</strong>：明确为何需要进行PEST分析，确定分析目标和范围。这有助于集中注意力，确保分析是有针对性的。</p></li><li><p><strong>收集信息</strong>：<strong>这是关键步骤</strong>——收集关于政治、经济、社会和技术环境的信息。这可以包括政府政策文件、行业报告、市场调研数据、新闻报道、学术研究等。信息来源应多样化，以确保全面性。</p></li><li><p><strong>分析政治环境</strong>：</p><ul><li>了解国内和国际政治格局。</li><li>调查政府政策和法规的变化，以及它们对业务的潜在影响。</li><li>评估政府的稳定性和领导层的决策风格。</li></ul></li><li><p><strong>分析经济环境</strong>：</p><ul><li>研究国家和全球经济趋势，包括通货膨胀率、汇率、利率等。</li><li>分析劳动力市场、就业率和薪酬水平。</li><li>考虑消费者支出、需求和购买力的变化。</li></ul></li><li><p><strong>分析社会环境</strong>：</p><ul><li>研究人口数据，包括年龄结构、文化背景和社会价值观。</li><li>考虑社会趋势，如健康意识、可持续性、多元文化等。</li><li>了解消费者行为和购买习惯的变化。</li></ul></li><li><p><strong>分析技术环境</strong>：</p><ul><li>考虑科技创新和研发趋势。</li><li>评估数字化技术和信息通信技术的发展对业务的影响。</li><li>考虑竞争对手采用的技术。</li></ul></li><li><p><strong>信息整合和对比分析</strong>：将收集的信息整合在一起，进行对比分析。识别出政治、经济、社会和技术环境中的关键因素和主要影响。注意不同因素之间的相互作用和可能的交叉影响。</p></li><li><p><strong>制定战略决策</strong>：根据分析结果，制定战略计划，以适应外部环境的变化，抓住机会，减少风险。确保战略与PEST分析的发现相一致。</p></li><li><p><strong>定期更新分析</strong>：PEST分析不是一次性的工作，外部环境不断变化。因此，定期更新和重新评估分析是至关重要的，以确保战略的持续适应性。</p></li></ol><p>PEST分析的<strong>关键是信息收集</strong>，需要广泛查阅各种信息来源。政府发布的政策文件、行业报告、市场调研数据、学术研究和新闻报道都是有用的信息来源。同时，与专业人士、行业专家和利益相关者的互动也可以提供宝贵的见解。</p><h2 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h2><p>电动汽车（Electric Vehicle，EV）行业，以特斯拉（Tesla）公司为例进行PEST分析</p><p><strong>政治环境</strong>：</p><ul><li><p><strong>政府激励政策</strong>：政府的购车激励政策（如减税和免费许可）对电动汽车制造商，特别是特斯拉，具有重大影响。例如，美国联邦政府提供的电动汽车税收减免鼓励了更多消费者购买特斯拉汽车。</p></li><li><p><strong>排放标准</strong>：政府对排放标准的严格要求可能迫使汽车制造商加速电动汽车的生产和销售。特斯拉受益于欧洲等地的严格排放法规，因为其电动汽车可以帮助汽车制造商遵守这些标准。</p></li></ul><p><strong>经济环境</strong>：</p><ul><li><p><strong>油价</strong>：油价波动会直接影响电动汽车市场的需求。当油价上升时，消费者更有动力购买能源更便宜的电动汽车，从而有利于特斯拉的销售。</p></li><li><p><strong>经济衰退</strong>：在经济衰退期间，消费者购车支出可能减少，但特斯拉可以采取措施降低产品价格，以应对市场不景气。</p></li></ul><p><strong>社会环境</strong>：</p><ul><li><p><strong>环保趋势</strong>：社会对环保问题的日益关注使电动汽车变得更具吸引力。特斯拉因其出色的环保性能而受到欢迎，符合社会的环保趋势。</p></li><li><p><strong>消费者需求</strong>：特斯拉不断满足消费者对更长续航里程、更快充电速度和更多智能功能的需求。例如，特斯拉 Model S 具有出色的续航里程，满足了长途旅行的需求。</p></li></ul><p><strong>技术环境</strong>：</p><ul><li><p><strong>电池技术</strong>：电池技术的进步直接影响电动汽车的性能和成本。特斯拉不断改进其电池技术，以提高续航里程，减少充电时间，并降低电动汽车的成本。</p></li><li><p><strong>自动驾驶技术</strong>：特斯拉一直是自动驾驶技术的先驱者，这使其在技术环境中具有竞争优势。自动驾驶技术的进展将进一步影响特斯拉的产品和市场地位。</p></li></ul><p><strong>分析和建议</strong>：</p><ul><li><p>特斯拉应积极与政府合作，以争取更多的税收激励和支持政策，以推动电动汽车市场的发展。</p></li><li><p>在经济不景气时，特斯拉可以采取不同的定价和销售策略，以维持市场份额。</p></li><li><p>特斯拉应继续改进电池技术和自动驾驶技术，以提高产品性能和安全性。</p></li><li><p>充分借助社会的环保趋势，特斯拉可以加强其在可持续出行领域的市场地位。</p></li></ul><p>这个分析考虑了特斯拉的具体情况，强调政治、经济、社会和技术因素如何直接影响该公司，并提供更具针对性的建议和策略。这有助于特斯拉更好地应对外部环境的变化，实现可持续增长。</p><h2 id="PEST分析表"><a href="#PEST分析表" class="headerlink" title="PEST分析表"></a>PEST分析表</h2><table><thead><tr><th>分类</th><th>要素</th><th>影响因素</th><th>举例</th></tr></thead><tbody><tr><td>政治环境分析</td><td>政策法规</td><td>税收、监管</td><td>新税收政策会增加企业成本</td></tr><tr><td></td><td>政府政策</td><td>补贴、扶持</td><td>政府出台新的扶持措施，提升了企业竞争力</td></tr><tr><td></td><td>政治稳定性</td><td>政治风险</td><td>政治动荡使得企业难以开展业务</td></tr><tr><td>经济环境分析</td><td>宏观经济指标</td><td>GDP、通货膨胀率</td><td>经济低迷导致企业销售额下降</td></tr><tr><td></td><td>行业生命周期</td><td>成长期、衰退期</td><td>行业处于成熟期，竞争加剧</td></tr><tr><td></td><td>消费趋势</td><td>消费升级、消费习惯改变</td><td>消费者更注重品质，推动企业不断提升产品质量</td></tr><tr><td>社会环境分析</td><td>人口结构</td><td>年龄结构、性别比例</td><td>人口老龄化带动了医疗保健行业的快速增长</td></tr><tr><td></td><td>文化价值观</td><td>健康、环保、家庭观念</td><td>消费者越来越重视绿色环保，企业应该加强环保措施</td></tr><tr><td></td><td>消费者行为</td><td>购买习惯、消费心理</td><td>互联网普及推动了以年轻人为主体的线上购物</td></tr><tr><td>技术环境分析</td><td>技术创新</td><td>5G、AI、大数据</td><td>企业投入更多的资源开发智能化产品</td></tr><tr><td></td><td>产业链变革</td><td>渠道变化、供应链改变</td><td>互联网技术改变了传统企业的营销模式</td></tr><tr><td></td><td>数字化转型</td><td>电商、自媒体营销</td><td>数字化转型提升了企业经营效率和市场竞争力</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思维工具 </tag>
            
            <tag> PEST </tag>
            
            <tag> 数据分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法探究</title>
      <link href="/bian-cheng-python-jing-dian-pai-xu-suan-fa.html"/>
      <url>/bian-cheng-python-jing-dian-pai-xu-suan-fa.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><h2 id="背景介绍："><a href="#背景介绍：" class="headerlink" title="背景介绍："></a>背景介绍：</h2><p>排序算法是计算机科学中一个非常重要的领域，它涉及将一组数据元素按照特定顺序重新排列的方法。排序是许多计算机科学和软件开发任务的基础，它在数据分析、数据库查询、搜索算法、图形渲染等众多应用中发挥着关键作用。不同的排序算法有不同的优势和适用场景，因此了解它们的原理和性能是非常重要的。</p><h2 id="目的说明："><a href="#目的说明：" class="headerlink" title="目的说明："></a>目的说明：</h2><p>本文的目的是深入剖析一些经典的排序算法，以帮助读者更好地理解它们的原理和应用。我们将关注一些最常见的排序算法，如冒泡排序、插入排序、选择排序、快速排序、归并排序等，并提供每种算法的详细描述、时间复杂度分析、示例代码以及适用场景的讨论。通过本文，读者将能够更好地理解排序算法的工作方式，选择合适的算法来满足特定需求，并优化其在实际应用中的性能。</p><p>接下来，我们将深入研究这些排序算法的原理和应用，从而更好地理解它们的优势和限制。</p><blockquote><p>本文算法均以python实现</p></blockquote><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><h2 id="基本思想："><a href="#基本思想：" class="headerlink" title="基本思想："></a>基本思想：</h2><p>   冒泡排序是一种简单的排序算法，它的基本思想是通过不断比较相邻的元素并交换它们的位置，将最大（或最小）的元素逐步”冒泡”到数组的一端。在每一轮排序中，比较相邻的两个元素，如果它们的顺序不正确（例如，前一个元素大于后一个元素），则交换它们的位置。这个过程一直重复，直到整个数组变得有序。</p><h2 id="算法过程："><a href="#算法过程：" class="headerlink" title="算法过程："></a>算法过程：</h2><p>   冒泡排序的算法过程如下：</p><ol><li>从数组的第一个元素开始，比较它与下一个元素。</li><li>如果当前元素大于下一个元素，交换它们的位置。</li><li>移动到下一个相邻元素，重复步骤1和2，直到到达数组的末尾。此时，数组中的最大元素已经”冒泡”到了最后一个位置。</li><li>重复步骤1-3，但这次不考虑已经排序好的最后一个元素，将次大的元素”冒泡”到倒数第二个位置。</li><li>重复这个过程，直到整个数组有序。</li></ol><h2 id="时间复杂度分析："><a href="#时间复杂度分析：" class="headerlink" title="时间复杂度分析："></a>时间复杂度分析：</h2><ul><li>最好情况：如果输入数组已经是有序的，冒泡排序只需要进行一趟比较，不需要交换元素，时间复杂度为O(n)。</li><li>最坏情况：如果输入数组是逆序的，每一趟排序都需要比较和交换元素，需要进行n-1趟排序，时间复杂度为O(n^2)。</li><li>平均情况：在平均情况下，冒泡排序的时间复杂度也是O(n^2)。因此，冒泡排序并不是一个高效的排序算法。</li></ul><h2 id="示例和应用场景："><a href="#示例和应用场景：" class="headerlink" title="示例和应用场景："></a>示例和应用场景：</h2><p>   <strong>示例：</strong><br>   假设有一个整数数组：[5, 2, 9, 3, 4, 6]。使用冒泡排序进行排序：</p><ul><li><p>第一轮排序：[2, 5, 3, 4, 6, 9]</p></li><li><p>第二轮排序：[2, 3, 4, 5, 6, 9]</p><p>最终数组有序，冒泡排序完成。</p></li></ul><p>   <strong>应用场景</strong>：<br>   冒泡排序是一个简单的排序算法，通常不用于处理大规模数据集，因为它的时间复杂度较高。它可以用于以下情况：</p><ol><li>教学和学习：冒泡排序通常用于教育和学习排序算法的基本原理。</li><li>当数据集较小，性能要求不高时，可以使用冒泡排序。</li><li>冒泡排序在实际应用中不常见，因为更高效的排序算法（如快速排序和归并排序）通常被优先选用，特别是对于大型数据集。</li></ol><p>冒泡排序虽然简单，但效率低下，不适合处理大规模数据，更适合用于教育和理解排序算法的基本原理</p><h2 id="python示例代码"><a href="#python示例代码" class="headerlink" title="python示例代码"></a>python示例代码</h2><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    冒泡排序函数    :param arr: 待排序的列表    :return: 排序后的列表    """</span>    n <span class="token operator">=</span> len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 遍历所有元素</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 最后i个元素已经排好序，不需要再比较</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> n<span class="token operator">-</span>i<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># 如果当前元素比下一个元素大，则交换它们</span>            <span class="token keyword">if</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span>    <span class="token keyword">return</span> arr<span class="token comment" spellcheck="true"># 测试用例</span>arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">64</span><span class="token punctuation">,</span> <span class="token number">34</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">90</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"排序前："</span><span class="token punctuation">,</span> arr<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"排序后："</span><span class="token punctuation">,</span> bubbleSort<span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><h2 id="基本思想：-1"><a href="#基本思想：-1" class="headerlink" title="基本思想："></a>基本思想：</h2><p>   选择排序是一种简单的排序算法，其基本思想是每次从待排序序列中选择最大（或最小）的元素，然后将它放置到已排序部分的末尾。这个过程不断重复，直到整个序列变得有序。</p><h2 id="算法过程：-1"><a href="#算法过程：-1" class="headerlink" title="算法过程："></a>算法过程：</h2><p>   选择排序的算法过程如下：</p><ol><li>初始时，整个序列被分为两部分：已排序部分和待排序部分。初始时，已排序部分为空，而待排序部分包含所有元素。</li><li>在待排序部分中找到最小（或最大）的元素。</li><li>将找到的最小（或最大）元素与待排序部分的第一个元素交换位置，将其放置到已排序部分的末尾。</li><li>已排序部分增加一个元素，待排序部分减少一个元素。</li><li>重复步骤2-4，直到待排序部分为空。此时，整个序列已排序完成。</li></ol><h2 id="时间复杂度分析：-1"><a href="#时间复杂度分析：-1" class="headerlink" title="时间复杂度分析："></a>时间复杂度分析：</h2><ul><li>最好情况：无论什么情况，选择排序的外层循环都需要执行n-1次。内层循环需要执行n次比较，但交换次数较少（最多n-1次）。因此，最好情况、最坏情况和平均情况下的时间复杂度都是O(n^2)。</li></ul><h2 id="示例和应用场景：-1"><a href="#示例和应用场景：-1" class="headerlink" title="示例和应用场景："></a>示例和应用场景：</h2><p>   <strong>示例：</strong><br>   假设有一个整数数组：[5, 2, 9, 3, 4, 6]。使用选择排序进行排序：</p><ul><li>第一轮排序：找到最小的元素2，并与第一个元素5交换位置，序列变为：[2, 5, 9, 3, 4, 6]</li><li>第二轮排序：在剩下的序列中找到最小的元素3，并与第二个元素5交换位置，序列变为：[2, 3, 9, 5, 4, 6]</li><li>以此类推，继续进行选择排序，直到整个数组有序。</li></ul><p>   <strong>应用场景：</strong></p><ol><li>选择排序是一种直观易懂的排序算法，适合用于教学和学习排序算法的基本原理。</li><li>当数据集较小，性能要求不高时，可以使用选择排序。</li><li>选择排序在实际应用中相对较少，因为它的时间复杂度较高，尤其在大型数据集的情况下，更高效的排序算法（如快速排序或归并排序）更为常见。</li></ol><p>选择排序是一种简单的排序算法，但在性能方面较差。它主要用于教学和小型数据集，而在实际应用中，通常会选择更高效的排序算法。</p><h2 id="python示例代码-1"><a href="#python示例代码-1" class="headerlink" title="python示例代码"></a>python示例代码</h2><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">selection_sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">:</span>    n <span class="token operator">=</span> len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 遍历数组</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 找到未排序部分中的最小元素的索引</span>        min_index <span class="token operator">=</span> i        <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>min_index<span class="token punctuation">]</span><span class="token punctuation">:</span>                min_index <span class="token operator">=</span> j        <span class="token comment" spellcheck="true"># 将最小元素与当前位置交换</span>        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>min_index<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>min_index<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span>    <span class="token keyword">return</span> arr<span class="token comment" spellcheck="true"># 测试</span>arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">64</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">]</span>sorted_arr <span class="token operator">=</span> selection_sort<span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"排序后的数组:"</span><span class="token punctuation">,</span> sorted_arr<span class="token punctuation">)</span></code></pre><h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><h2 id="基本思想：-2"><a href="#基本思想：-2" class="headerlink" title="基本思想："></a>基本思想：</h2><p>   插入排序是一种简单的排序算法，其基本思想是通过构建有序子序列，将未排序的元素逐个插入到合适的位置。在整个排序过程中，已排序部分总是位于数组的前部，而未排序部分位于后部。</p><h2 id="算法过程：-2"><a href="#算法过程：-2" class="headerlink" title="算法过程："></a>算法过程：</h2><p>   插入排序的算法过程如下：</p><ol><li>初始时，整个序列被分为两部分：已排序部分和待排序部分。初始时，已排序部分只包含第一个元素，而待排序部分包含其余元素。</li><li>从待排序部分取出第一个元素，称为当前元素。</li><li>将当前元素与已排序部分的元素依次比较，找到当前元素在已排序部分中的合适位置。这通常涉及到多次比较和移动元素的过程。</li><li>插入当前元素到已排序部分的合适位置。</li><li>已排序部分增加一个元素，待排序部分减少一个元素。</li><li>重复步骤2-5，直到待排序部分为空。此时，整个序列已排序完成。</li></ol><h2 id="时间复杂度分析：-2"><a href="#时间复杂度分析：-2" class="headerlink" title="时间复杂度分析："></a>时间复杂度分析：</h2><ul><li>最好情况：在最好情况下，如果输入序列已经有序，插入排序只需要进行n-1次比较，没有交换操作，时间复杂度为O(n)。</li><li>最坏情况：在最坏情况下，如果输入序列是逆序的，插入排序需要进行n-1次比较和n-1次交换操作，时间复杂度为O(n^2)。</li><li>平均情况：平均情况下，插入排序的时间复杂度也是O(n^2)。</li></ul><h2 id="示例和应用场景：-2"><a href="#示例和应用场景：-2" class="headerlink" title="示例和应用场景："></a>示例和应用场景：</h2><p>   <strong>示例：</strong><br>   假设有一个整数数组：[5, 2, 9, 3, 4, 6]。使用插入排序进行排序：</p><ul><li>第一轮排序：已排序部分：[5]，待排序部分：[2, 9, 3, 4, 6]。取出2，插入到已排序部分中，结果为：[2, 5]，[9, 3, 4, 6]。</li><li>第二轮排序：已排序部分：[2, 5]，待排序部分：[9, 3, 4, 6]。取出9，插入到已排序部分中，结果为：[2, 5, 9]，[3, 4, 6]。</li><li>以此类推，继续进行插入排序，直到整个数组有序。</li></ul><p>   <strong>应用场景：</strong></p><ol><li>插入排序是一种稳定的排序算法，适用于小型数据集，尤其在数据基本有序的情况下表现良好。</li><li>它在实际应用中常用于对小型数组或部分已排序的数据进行排序，如在线扑克牌游戏中对手中的牌进行排序。</li><li>插入排序还可以用作其他排序算法的一部分，例如希尔排序中的子过程。</li></ol><p>插入排序是一种简单但有效的排序算法，适用于小规模数据集和特定情况下。它的时间复杂度较低，但在大规模数据集上性能不如快速排序或归并排序等高效排序算法。</p><h2 id="python示例代码-2"><a href="#python示例代码-2" class="headerlink" title="python示例代码"></a>python示例代码</h2><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">insertion_sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">:</span>    n <span class="token operator">=</span> len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 从第2个元素开始遍历数组，将其插入已排序的部分</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>        key <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span>    <span class="token comment" spellcheck="true"># 当前待插入的元素</span>        j <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span>       <span class="token comment" spellcheck="true"># 已排序部分的最后一个元素的索引</span>        <span class="token comment" spellcheck="true"># 将大于待插入元素的元素向右移动</span>        <span class="token keyword">while</span> j <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">and</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> key<span class="token punctuation">:</span>            arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span>            j <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token comment" spellcheck="true"># 将待插入元素放入正确的位置</span>        arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> key    <span class="token keyword">return</span> arr<span class="token comment" spellcheck="true"># 测试</span>arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">64</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">]</span>sorted_arr <span class="token operator">=</span> insertion_sort<span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"排序后的数组:"</span><span class="token punctuation">,</span> sorted_arr<span class="token punctuation">)</span></code></pre><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><h2 id="基本思想：-3"><a href="#基本思想：-3" class="headerlink" title="基本思想："></a>基本思想：</h2><p>   快速排序是一种分治排序算法，其基本思想是通过一趟排序将待排序序列分割为两个独立的子序列，再递归地对这两个子序列进行排序。这个分割过程依赖于选择一个枢纽元素，将小于枢纽元素的元素放在它的左边，大于枢纽元素的元素放在它的右边。</p><h2 id="算法过程：-3"><a href="#算法过程：-3" class="headerlink" title="算法过程："></a>算法过程：</h2><p>   快速排序的算法过程如下：</p><ol><li>选择一个枢纽元素（通常选择待排序序列的第一个元素）。</li><li>划分（Partitioning）：将序列中小于枢纽元素的元素放在枢纽元素的左边，大于枢纽元素的元素放在右边，枢纽元素自身已经在正确的位置。</li><li>递归地对枢纽元素左边和右边的子序列进行快速排序。</li><li>重复步骤1-3，直到所有子序列有序。</li></ol><h2 id="时间复杂度分析：-3"><a href="#时间复杂度分析：-3" class="headerlink" title="时间复杂度分析："></a>时间复杂度分析：</h2><ul><li>最好情况：当每次划分都能均匀地将序列分成大致相等的两部分时，快速排序的性能最好。在这种情况下，时间复杂度为O(n*log(n))。</li><li>最坏情况：当每次划分都将序列分为一个较小的子序列和一个较大的子序列时，快速排序的性能最差。最坏情况下的时间复杂度为O(n^2)。但通过选择合适的枢纽元素，可以避免最坏情况的发生。</li><li>平均情况：在平均情况下，快速排序的时间复杂度为O(n*log(n))。</li></ul><h2 id="示例和应用场景：-3"><a href="#示例和应用场景：-3" class="headerlink" title="示例和应用场景："></a>示例和应用场景：</h2><p>   <strong>示例</strong>：<br>   假设有一个整数数组：[5, 2, 9, 3, 4, 6]。使用快速排序进行排序：</p><ul><li>选择枢纽元素，通常选择第一个元素，如5。</li><li>划分序列，将小于5的元素放在左边，大于5的元素放在右边：[2, 3, 4], [5], [9, 6]。</li><li>递归对左右两个子序列进行快速排序：[2, 3, 4] 和 [9, 6]。</li><li>重复上述过程，直到整个数组有序。</li></ul><p>   <strong>应用场景：</strong></p><ol><li>快速排序是一种高效的排序算法，通常用于大规模数据集的排序，因为它的平均时间复杂度较低。</li><li>它在各种编程语言的标准库中常用于排序操作，如C++中的<code>std::sort</code>和Python中的<code>sorted</code>。</li><li>快速排序还用于各种应用场景，包括数据库查询优化、图像处理、文件系统等需要高性能排序的领域。</li></ol><p>快速排序是一种常用且高效的排序算法，特别适合处理大型数据集。通过选择合适的枢纽元素，可以提高其性能，避免最坏情况的发生。</p><h2 id="python示例代码-3"><a href="#python示例代码-3" class="headerlink" title="python示例代码"></a>python示例代码</h2><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">partition</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">:</span>    i <span class="token operator">=</span> low <span class="token operator">-</span> <span class="token number">1</span>   <span class="token comment" spellcheck="true"># 小于等于pivot的元素的最右索引</span>    pivot <span class="token operator">=</span> arr<span class="token punctuation">[</span>high<span class="token punctuation">]</span>   <span class="token comment" spellcheck="true"># 选择最后一个元素作为pivot</span>    <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>low<span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> pivot<span class="token punctuation">:</span>            i <span class="token operator">+=</span> <span class="token number">1</span>            arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span>    arr<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>high<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span>    <span class="token keyword">return</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token keyword">def</span> <span class="token function">quick_sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> low <span class="token operator">&lt;</span> high<span class="token punctuation">:</span>        pi <span class="token operator">=</span> partition<span class="token punctuation">(</span>arr<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">)</span>        quick_sort<span class="token punctuation">(</span>arr<span class="token punctuation">,</span> low<span class="token punctuation">,</span> pi<span class="token number">-1</span><span class="token punctuation">)</span>        quick_sort<span class="token punctuation">(</span>arr<span class="token punctuation">,</span> pi<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 测试</span>arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">64</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">]</span>n <span class="token operator">=</span> len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span>quick_sort<span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n<span class="token number">-1</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"排序后的数组:"</span><span class="token punctuation">,</span> arr<span class="token punctuation">)</span></code></pre><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><h2 id="基本思想：-4"><a href="#基本思想：-4" class="headerlink" title="基本思想："></a>基本思想：</h2><p>   归并排序是一种分治排序算法，其基本思想是将待排序序列递归地分割为单个元素，然后合并相邻的有序子序列，直到整个序列有序。</p><h2 id="算法过程：-4"><a href="#算法过程：-4" class="headerlink" title="算法过程："></a>算法过程：</h2><p>   归并排序的算法过程如下：</p><ol><li>分割（Divide）：将待排序序列递归地分割为单个元素或长度为1的子序列。</li><li>合并（Conquer）：将相邻的有序子序列合并为较大的有序子序列。这一过程重复进行，直到整个序列有序。</li><li>归并（Merge）：在合并过程中，将两个有序子序列合并为一个更大的有序序列。这个合并过程通常需要借助额外的空间来存储中间结果。</li></ol><h2 id="时间复杂度分析：-4"><a href="#时间复杂度分析：-4" class="headerlink" title="时间复杂度分析："></a>时间复杂度分析：</h2><ul><li>最好情况、最坏情况和平均情况下的时间复杂度都是O(n*log(n))。归并排序的性能稳定，不受输入数据的顺序影响，因此在各种情况下都表现良好。</li></ul><h2 id="示例和应用场景：-4"><a href="#示例和应用场景：-4" class="headerlink" title="示例和应用场景："></a>示例和应用场景：</h2><p>   <strong>示例：</strong><br>   假设有一个整数数组：[5, 2, 9, 3, 4, 6]。使用归并排序进行排序：</p><ul><li>分割过程：将序列分割为单个元素的子序列：[5], [2], [9], [3], [4], [6]。</li><li>合并过程：依次将相邻的子序列合并，生成较大的有序子序列。最终，整个数组有序。</li></ul><p>   <strong>应用场景：</strong></p><ol><li>归并排序是一种高效的排序算法，适用于各种规模的数据集。它通常用于外部排序，例如对磁盘上的大型数据文件进行排序。</li><li>归并排序常用于处理链表数据结构，因为它天然适合链表的特点，不需要额外的存储空间。</li><li>在许多编程语言的标准库中，归并排序也用于排序操作，例如Python中的<code>sorted</code>函数。</li></ol><p>归并排序是一种高效且稳定的排序算法，适用于各种数据规模和数据类型。它具有良好的性能和可读性，适用于多种应用场景，尤其是需要稳定性和预测性能的情况。</p><h2 id="python示例代码-4"><a href="#python示例代码-4" class="headerlink" title="python示例代码"></a>python示例代码</h2><pre class=" language-Python"><code class="language-Python">def merge_sort(arr):    if len(arr) > 1:        mid = len(arr) // 2   # 将数组分为两半        L = arr[:mid]         # 左半部分        R = arr[mid:]         # 右半部分        merge_sort(L)         # 递归地将左半部分排序        merge_sort(R)         # 递归地将右半部分排序        i = j = k = 0        # 合并两个已排序的数组        while i < len(L) and j < len(R):            if L[i] < R[j]:                arr[k] = L[i]                i += 1            else:                arr[k] = R[j]                j += 1            k += 1        # 处理剩余的元素        while i < len(L):            arr[k] = L[i]            i += 1            k += 1        while j < len(R):            arr[k] = R[j]            j += 1            k += 1    return arr# 测试arr = [64, 25, 12, 22, 11]sorted_arr = merge_sort(arr)print("排序后的数组:", sorted_arr)</code></pre><h1 id="排序算法对比"><a href="#排序算法对比" class="headerlink" title="排序算法对比"></a>排序算法对比</h1><table><thead><tr><th>排序算法</th><th>平均情况时间复杂度</th><th>最好情况时间复杂度</th><th>最坏情况时间复杂度</th><th>辅助空间复杂度</th><th>稳定性</th></tr></thead><tbody><tr><td>冒泡排序</td><td>O(n^2)</td><td>O(n)</td><td>O(n^2)</td><td>O(1)</td><td>稳定</td></tr><tr><td>选择排序</td><td>O(n^2)</td><td>O(n^2)</td><td>O(n^2)</td><td>O(1)</td><td>不稳定</td></tr><tr><td>插入排序</td><td>O(n^2)</td><td>O(n)</td><td>O(n^2)</td><td>O(1)</td><td>稳定</td></tr><tr><td>快速排序</td><td>O(nlogn)</td><td>O(nlogn)</td><td>O(n^2)</td><td>O(logn)</td><td>不稳定</td></tr><tr><td>归并排序</td><td>O(nlogn)</td><td>O(nlogn)</td><td>O(nlogn)</td><td>O(n)</td><td>稳定</td></tr></tbody></table><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><strong>《算法图解》</strong>：这本书以图解的方式阐述了各种算法，使复杂的概念更容易理解。它适合那些希望更深入了解算法的人，无论是初学者还是有经验的开发人员。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 编程 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法</title>
      <link href="/bian-cheng-shu-ju-jie-gou-yu-suan-fa-python.html"/>
      <url>/bian-cheng-shu-ju-jie-gou-yu-suan-fa-python.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>数据结构和算法是计算机科学领域中的两个核心概念，它们在计算机程序设计和问题解决中扮演着至关重要的角色。数据结构与算法之美体现在它们的智慧设计和精巧实现。通过合理选择数据结构，可以提高程序的性能，减少资源消耗。通过巧妙运用算法，可以解决复杂的问题，从图像处理到自然语言处理，从网络路由到机器学习。数据结构和算法之美在于它们的智慧和创造力，以及它们的广泛应用。它们是计算机科学的杰作，是技术的艺术，是解决世界难题的工具，更是人类智慧的结晶。学习数据结构与算法，感受下它的魅力吧^_^</p><blockquote><p>此文内容均以python实现</p></blockquote><h1 id="一、算法"><a href="#一、算法" class="headerlink" title="一、算法"></a>一、算法</h1><p> <strong>算法是独立存在的一种解决问题的方法和思想。</strong> </p><blockquote><p> 对于算法而言，实现的语言并不重要，重要的是思想。 </p></blockquote><h2 id="算法的五大特性"><a href="#算法的五大特性" class="headerlink" title="算法的五大特性"></a>算法的五大特性</h2><ol><li><strong>输入</strong>: 算法具有0个或多个输入</li><li><strong>输出</strong>: 算法至少有1个或多个输出</li><li><strong>有穷性</strong>: 算法在有限的步骤之后会自动结束而不会无限循环，并且每一个步骤可以在可接受的时间内完成</li><li><strong>确定性</strong>：算法中的每一步都有确定的含义，不会出现二义性</li><li><strong>可行性</strong>：算法的每一步都是可行的，也就是说每一步都能够执行有限的次数完成</li></ol><h2 id="算法效率衡量"><a href="#算法效率衡量" class="headerlink" title="算法效率衡量"></a>算法效率衡量</h2><p> <strong>实现算法程序的执行时间可以反应出算法的效率，即算法的优劣。</strong> </p><p> <strong>单纯依靠运行的时间来比较算法的优劣并不一定是客观准确的！</strong> </p><h2 id="时间复杂度与“大O记法”"><a href="#时间复杂度与“大O记法”" class="headerlink" title="时间复杂度与“大O记法”"></a>时间复杂度与“大O记法”</h2><p><strong>官方术语解释</strong>：</p><p><strong>“大O记法”</strong>：对于单调的整数函数f，如果存在一个整数函数g和实常数c&gt;0，使得对于充分大的n总有f(n)&lt;=c*g(n)，就说函数g是f的一个渐近函数（忽略常数），记为f(n)=O(g(n))。也就是说，在趋向无穷的极限意义下，函数f的增长速度受到函数g的约束，亦即函数f与函数g的特征相似。</p><p><strong>时间复杂度</strong>：假设存在函数g，使得算法A处理规模为n的问题示例所用时间为T(n)=O(g(n))，则称O(g(n))为算法A的渐近时间复杂度，简称时间复杂度，记为T(n)</p><p>“大O记法”是一种简洁、通用的算法时间复杂度表示法，它可以描述算法的时间复杂度的增长趋势。具体来说，假设 n 表示输入数据的大小，算法所需执行的基本操作次数为 f(n)，则我们可以用 O(g(n)) 表示算法的时间复杂度，其中 g(n) 是一个函数，它描述了算法执行时间与输入数据大小 n 之间的增长关系。</p><p><strong>大O记法的核心思想是找到算法执行时间的上界，即算法在最坏情况下的执行时间。</strong>例如，对于一个线性搜索算法，无论输入数据的大小是多少，最坏情况下都需要对每个数据进行遍历，因此其时间复杂度为 O(n)。而对于一个排序算法，其时间复杂度通常与数据规模的对数成正比，因此其时间复杂度为 O(log n)。</p><h2 id="最坏时间复杂度"><a href="#最坏时间复杂度" class="headerlink" title="最坏时间复杂度"></a>最坏时间复杂度</h2><p>分析算法时，存在几种可能的考虑：</p><ul><li>最优时间复杂度：表示在最理想的情况下，算法完成工作所需要的最少操作次数。由于这个复杂度很难实现且对我们的分析没有太多帮助，因此一般不太重要。</li><li>最坏时间复杂度：表示在最坏情况下，算法完成工作所需要的最大操作次数。它是算法复杂度的上界，为保证算法的稳定性和可靠性，我们通常使用最坏时间复杂度来评估算法的复杂度。</li><li>平均时间复杂度：表示在所有可能输入实例的情况下，算法完成工作所需要的操作次数的期望值。它可以更加全面地反映算法的性能，但计算过程比较复杂，需要利用概率论和数学知识进行分析。</li></ul><h2 id="时间复杂度的几条基本计算规则"><a href="#时间复杂度的几条基本计算规则" class="headerlink" title="时间复杂度的几条基本计算规则"></a>时间复杂度的几条基本计算规则</h2><ol><li>顺序结构：对于顺序结构，其复杂度是各个语句复杂度之和。</li><li>循环结构：对于循环结构，假设循环次数为 n，则其复杂度为循环体执行次数乘以循环次数。例如，一个 for 循环内部执行了 k 条语句，则其复杂度为 O(kn)。</li><li>条件结构：对于条件结构，我们需要考虑最坏情况下两个分支的复杂度，取最大值作为整个条件结构的复杂度。</li><li>递归结构：对于递归结构，其复杂度要考虑递归函数被调用的次数和每次调用的复杂度。通常情况下，在递归函数中会涉及到多次递归调用，此时可以使用递推公式或者主定理来计算复杂度。</li><li>多重循环嵌套：对于多个循环嵌套，可以依次计算每层循环的时间复杂度，并将它们乘起来。例如，一个二重循环的复杂度为 O(n^2)，一个三重循环的复杂度为 O(n^3)。</li></ol><blockquote><p>在没有特殊说明时，所分析的算法的时间复杂度都是指<strong>最坏时间复杂度</strong></p></blockquote><h2 id="常见时间复杂度"><a href="#常见时间复杂度" class="headerlink" title="常见时间复杂度"></a>常见时间复杂度</h2><p> <strong>O(1)常数型；O(log n)对数型，O(n)线性型，O(nlog n)线性对数型，O(n2)平方型，O(n3)立方型，O(nk)k次方型，O(2n)指数型</strong>。 </p><p>所消耗的时间从小到大</p><p><strong>O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n2) &lt; O(n3) &lt; O(2n) &lt; O(n!) &lt; O(nn)</strong></p><h1 id="二、数据结构"><a href="#二、数据结构" class="headerlink" title="二、数据结构"></a>二、数据结构</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>数据</strong>是一个抽象的概念，将其进行分类后得到程序设计语言中的基本类型。如：int，float，char等。数据元素之间不是独立的，存在特定的关系，这些关系便是结构。数据结构指数据对象中数据元素之间的关系。</p><p><strong>数据</strong>:是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。数据不仅仅包括整型、实型等数值类型，还包括字符及声音、图像、视频等非数值类型。</p><p><strong>数据元素</strong>：:是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理。也被称为记录。</p><p><strong>数据项</strong>:一个数据元素可以由若干个数据项组成。数据项是数据不可分割的最小单位。</p><h2 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h2><p><strong>数据类型</strong>:是指一组性质相同的值的集合及定义在此集合上的一些操作的总称。</p><blockquote><p>抽象是指抽取出事物具有的普遍性的本质。</p></blockquote><h2 id="基本特点"><a href="#基本特点" class="headerlink" title="基本特点"></a>基本特点</h2><ul><li><p>存储方式：数据结构可以在内存或外部存储设备中存储数据。内存中的数据结构通常用于临时性数据操作，而外部存储数据结构用于永久存储数据。</p></li><li><p>操作方式：数据结构定义了可对其中数据进行的操作，如插入、删除、查找、排序等。</p></li><li><p>性能特征：不同的数据结构对于各种操作具有不同的性能特征，包括时间复杂度和空间复杂度。这些特征影响着数据结构的选择和使用。</p></li></ul><h2 id="常见的数据结构类型"><a href="#常见的数据结构类型" class="headerlink" title="常见的数据结构类型"></a>常见的数据结构类型</h2><p>线性结构和非线性结构是数据结构中常见的两种分类方式，它们描述了数据元素之间的关系和组织方式。</p><h3 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h3><p>线性结构是指数据元素之间存在一对一的相邻关系，即每个数据元素只有一个直接前驱和一个直接后继。线性结构中的数据元素排列有序，可以按照线性顺序进行访问。常见的线性结构有线性表、数组、栈、队列等。</p><ul><li>线性表：线性表中的数据元素按照插入的顺序排列，可以通过线性索引来访问和操作。</li><li>数组：数组使用连续的内存空间来存储数据元素，可以通过下标来访问和操作元素。</li><li>栈：栈是一种”先进后出”的数据结构，只能在一端进行插入和删除操作，通常用于函数调用、表达式求值等场景。</li><li>队列：队列是一种”先进先出”的数据结构，只能在一端进行插入，在另一端进行删除，常用于模拟排队、任务调度等场景。</li></ul><h3 id="非线性结构"><a href="#非线性结构" class="headerlink" title="非线性结构"></a>非线性结构</h3><p>非线性结构是指数据元素之间不存在一对一的相邻关系，数据元素之间可能存在多对多的关系。非线性结构中的数据元素排列无序，访问和操作需要通过特定的方式和算法。常见的非线性结构有树、图等。</p><ul><li>树：树是一种分层的数据结构，由节点和边组成，每个节点可能有多个子节点。树结构常用于组织层次关系的数据，如文件系统、组织架构等。</li><li>图：图是由节点和边组成的数据结构，节点之间的关系可以是任意的，图结构常用于描述网络、社交关系等复杂的关联数据。</li></ul><h2 id="不同数据结构的优缺点和适用场景"><a href="#不同数据结构的优缺点和适用场景" class="headerlink" title="不同数据结构的优缺点和适用场景"></a>不同数据结构的优缺点和适用场景</h2><p>数组：适用于需要随机访问元素的情况，但不适合频繁插入/删除操作的场景。</p><p>链表：适用于频繁插入/删除操作的情况，但不适合随机访问元素。</p><p>栈：通常用于管理函数调用、表达式求值等情况，其中后进先出的特性很重要。</p><p>队列：通常用于排队、任务调度等情况，其中先进先出的特性很重要。</p><p>树：适用于组织层次性数据，例如文件系统、数据库索引等。</p><p>图：适用于表示复杂关系，如社交网络、路径规划、最短路径等问题。</p><h1 id="三、常用数据结构和算法详解"><a href="#三、常用数据结构和算法详解" class="headerlink" title="三、常用数据结构和算法详解"></a>三、常用数据结构和算法详解</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p><strong>数组</strong>是一种线性数据结构，它由相同类型的元素按照一定的顺序排列而成。数组的基本特点包括：</p><ul><li><strong>定义</strong>：数组是一个有序的数据集合，每个元素通过索引来访问。元素类型通常相同。</li><li><strong>基本操作</strong>：数组支持元素的访问、插入、删除和更新操作。访问元素的时间复杂度为O(1)，但插入/删除元素的时间复杂度为O(n)。</li><li><strong>常见应用</strong>：数组用于存储和操作有序的数据集，如整数、浮点数、字符串等。它在算法和数据处理中广泛应用，如排序算法、搜索算法、动态规划等。</li><li><strong>代码示例：</strong></li></ul><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 创建一个整数数组</span>my_array <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 访问数组元素</span><span class="token keyword">print</span><span class="token punctuation">(</span>my_array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 输出 1</span><span class="token comment" spellcheck="true"># 插入元素</span>my_array<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 删除元素</span><span class="token keyword">del</span> my_array<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 修改元素</span>my_array<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">7</span></code></pre><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p><strong>链表</strong>是一种线性数据结构，其中元素以节点的形式连接，每个节点包含数据和指向下一个节点的指针。链表的基本特点包括：</p><ul><li><strong>定义</strong>：链表是一种有序的数据结构，节点之间通过指针连接。链表可以分为单链表、双链表和循环链表等变体。</li><li><strong>基本操作</strong>：链表支持元素的插入、删除和遍历操作。插入和删除元素的时间复杂度通常为O(1)。</li><li><strong>常见应用</strong>：链表常用于需要频繁插入和删除操作的场景，如动态内存分配、高级数据结构的实现等。</li><li><strong>示例代码</strong></li></ul><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>data <span class="token operator">=</span> data        self<span class="token punctuation">.</span>next <span class="token operator">=</span> None<span class="token comment" spellcheck="true"># 定义了一个Node类，表示链表的节点。每个节点包含一个data属性存储数据，一个next属性指向下一个节点或None。</span><span class="token keyword">class</span> <span class="token class-name">LinkedList</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>head <span class="token operator">=</span> None    <span class="token comment" spellcheck="true"># 初始化一个空链表，头节点默认为None。</span>    <span class="token keyword">def</span> <span class="token function">insert</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">:</span>        new_node <span class="token operator">=</span> Node<span class="token punctuation">(</span>data<span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token operator">not</span> self<span class="token punctuation">.</span>head<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>head <span class="token operator">=</span> new_node        <span class="token keyword">else</span><span class="token punctuation">:</span>            current <span class="token operator">=</span> self<span class="token punctuation">.</span>head            <span class="token keyword">while</span> current<span class="token punctuation">.</span>next<span class="token punctuation">:</span>                current <span class="token operator">=</span> current<span class="token punctuation">.</span>next            current<span class="token punctuation">.</span>next <span class="token operator">=</span> new_node    <span class="token comment" spellcheck="true"># 在链表末尾插入新节点。如果链表为空，则将新节点设置为头节点；否则，遍历链表找到最后一个节点，并将其next指向新节点。</span>    <span class="token keyword">def</span> <span class="token function">delete</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">:</span>        current <span class="token operator">=</span> self<span class="token punctuation">.</span>head        <span class="token keyword">if</span> current <span class="token operator">and</span> current<span class="token punctuation">.</span>data <span class="token operator">==</span> data<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>head <span class="token operator">=</span> current<span class="token punctuation">.</span>next            <span class="token keyword">return</span>        <span class="token keyword">while</span> current <span class="token operator">and</span> current<span class="token punctuation">.</span>next<span class="token punctuation">:</span>            <span class="token keyword">if</span> current<span class="token punctuation">.</span>next<span class="token punctuation">.</span>data <span class="token operator">==</span> data<span class="token punctuation">:</span>                current<span class="token punctuation">.</span>next <span class="token operator">=</span> current<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next                <span class="token keyword">return</span>            current <span class="token operator">=</span> current<span class="token punctuation">.</span>next    <span class="token comment" spellcheck="true"># 从链表中删除指定数据的节点。如果头节点就是要删除的节点，则直接将头节点指向下一个节点；否则，遍历链表找到要删除节点的前一个节点，并修改其next指向下一个节点的next。</span>    <span class="token keyword">def</span> <span class="token function">display</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        current <span class="token operator">=</span> self<span class="token punctuation">.</span>head        <span class="token keyword">while</span> current<span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span>current<span class="token punctuation">.</span>data<span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">" -> "</span><span class="token punctuation">)</span>            current <span class="token operator">=</span> current<span class="token punctuation">.</span>next        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"None"</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 遍历链表并打印每个节点的数据，以箭头形式连接。最后打印None表示结束。</span><span class="token comment" spellcheck="true"># 以上是LinkedList类的定义，包含了插入、删除和显示链表的方法。</span></code></pre><h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><p><strong>栈</strong>和<strong>队列</strong>都是线性数据结构，具有特定的插入和删除规则。</p><ul><li><strong>栈</strong>是一种后进先出（LIFO）的数据结构，只能在栈顶进行插入和删除操作。它常用于函数调用、表达式求值和回退操作等场景。</li><li><strong>队列</strong>是一种先进先出（FIFO）的数据结构，只能在队首进行删除操作，在队尾进行插入操作。它通常用于排队、任务调度等场景。</li><li><strong>示例代码</strong></li></ul><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Stack</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>items <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token comment" spellcheck="true"># 初始化一个空栈，使用列表来存储栈中的元素。</span>    <span class="token keyword">def</span> <span class="token function">push</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> item<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>items<span class="token punctuation">.</span>append<span class="token punctuation">(</span>item<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 将元素压入栈顶，即将元素添加到列表的末尾。</span>    <span class="token keyword">def</span> <span class="token function">pop</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> self<span class="token punctuation">.</span>is_empty<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> self<span class="token punctuation">.</span>items<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> None    <span class="token comment" spellcheck="true"># 弹出栈顶元素并返回该元素。如果栈为空，则返回None。</span>    <span class="token keyword">def</span> <span class="token function">is_empty</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> len<span class="token punctuation">(</span>self<span class="token punctuation">.</span>items<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span>    <span class="token comment" spellcheck="true"># 判断栈是否为空，即栈中是否没有元素。</span>    <span class="token keyword">def</span> <span class="token function">peek</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> self<span class="token punctuation">.</span>is_empty<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> self<span class="token punctuation">.</span>items<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>    <span class="token comment" spellcheck="true"># 返回栈顶元素的值，但不移除该元素。如果栈为空，则返回None。</span>    <span class="token keyword">def</span> <span class="token function">size</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> len<span class="token punctuation">(</span>self<span class="token punctuation">.</span>items<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 返回栈中元素的个数。</span><span class="token comment" spellcheck="true"># 以上是Stack类的定义，实现了基本的栈数据结构的操作方法。</span></code></pre><p>队列示例代码</p><pre class=" language-python"><code class="language-python">    <span class="token keyword">from</span> collections <span class="token keyword">import</span> deque<span class="token keyword">class</span> <span class="token class-name">Queue</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>items <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 初始化一个空队列，使用双端队列deque来存储队列中的元素。</span>    <span class="token keyword">def</span> <span class="token function">enqueue</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> item<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>items<span class="token punctuation">.</span>append<span class="token punctuation">(</span>item<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 将元素入队，即将元素添加到队列的末尾。</span>    <span class="token keyword">def</span> <span class="token function">dequeue</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> self<span class="token punctuation">.</span>is_empty<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> self<span class="token punctuation">.</span>items<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> None    <span class="token comment" spellcheck="true"># 出队操作，弹出队列中的第一个元素并返回。如果队列为空，则返回None。</span>    <span class="token keyword">def</span> <span class="token function">is_empty</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> len<span class="token punctuation">(</span>self<span class="token punctuation">.</span>items<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span>    <span class="token comment" spellcheck="true"># 判断队列是否为空，即队列中是否没有元素。</span>    <span class="token keyword">def</span> <span class="token function">size</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> len<span class="token punctuation">(</span>self<span class="token punctuation">.</span>items<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 返回队列中元素的个数。</span><span class="token comment" spellcheck="true"># 以上是Queue类的定义，使用双端队列deque实现了基本的队列数据结构的操作方法。</span></code></pre><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p><strong>树</strong>是一种非线性数据结构，由节点和边组成，用于表示层次结构。常见的树结构包括：</p><ul><li><strong>二叉树</strong>：每个节点最多有两个子节点，分为二叉搜索树、平衡树等变体。</li><li><strong>平衡树</strong>：确保树的高度平衡，提高查找、插入和删除操作的性能。</li><li><strong>堆</strong>：用于高效地查找最大值或最小值，分为最大堆和最小堆。</li></ul><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><p><strong>图</strong>是一种非线性数据结构，由节点和边组成，用于表示复杂关系。图可以是有向的或无向的，有权重的或无权重的。基本概念包括：</p><ul><li><strong>节点</strong>：图中的数据元素。</li><li><strong>边</strong>：节点之间的连接。</li><li><strong>有向图</strong>：边具有方向。</li><li><strong>权重图</strong>：边具有权重。</li></ul><p>图的遍历算法包括深度优先搜索（DFS）和广度优先搜索（BFS）。图的最短路径算法包括Dijkstra算法和Bellman-Ford算法，用于找到两个节点之间的最短路径。</p><p>图常用于解决复杂的关系型问题，如社交网络分析、路径规划等。</p><p>这些常用的数据结构和算法在计算机科学和软件工程中扮演着关键的角色，它们是解决各种问题的有力工具，也是计算机程序的基础构建块。理解它们的定义、操作和应用对于编写高效和可维护的代码至关重要。</p><h1 id="四、实例分析"><a href="#四、实例分析" class="headerlink" title="四、实例分析"></a>四、实例分析</h1><p>涉及到数据结构和算法的实际应用时，通过具体示例问题来演示它们的应用和效果，并对不同方法的优缺点和适用场景进行比较。</p><h3 id="示例问题：查找数组中的最大元素"><a href="#示例问题：查找数组中的最大元素" class="headerlink" title="示例问题：查找数组中的最大元素"></a>示例问题：查找数组中的最大元素</h3><p>假设我们有一个整数数组，我们需要找到其中的最大元素。</p><h4 id="使用数组"><a href="#使用数组" class="headerlink" title="使用数组"></a>使用数组</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">find_max_with_array</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">:</span>    max_value <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true"># 假设数组的第一个元素为最大值</span>    <span class="token keyword">for</span> element <span class="token keyword">in</span> arr<span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># 遍历数组中的每个元素</span>        <span class="token keyword">if</span> element <span class="token operator">></span> max_value<span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># 如果当前元素大于最大值</span>            max_value <span class="token operator">=</span> element  <span class="token comment" spellcheck="true"># 更新最大值</span>    <span class="token keyword">return</span> max_value  <span class="token comment" spellcheck="true"># 返回最大值</span></code></pre><ul><li>优点：简单，容易实现。</li><li>缺点：需要遍历整个数组，时间复杂度为O(n)。</li></ul><h4 id="使用堆栈"><a href="#使用堆栈" class="headerlink" title="使用堆栈"></a>使用堆栈</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">find_max_with_stack</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">:</span>    stack <span class="token operator">=</span> Stack<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 创建一个栈对象</span>    <span class="token keyword">for</span> element <span class="token keyword">in</span> arr<span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># 将数组中的每个元素依次入栈</span>        stack<span class="token punctuation">.</span>push<span class="token punctuation">(</span>element<span class="token punctuation">)</span>    max_value <span class="token operator">=</span> float<span class="token punctuation">(</span><span class="token string">"-inf"</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 假设最大值为负无穷</span>    <span class="token keyword">while</span> <span class="token operator">not</span> stack<span class="token punctuation">.</span>is_empty<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># 当栈不为空时循环</span>        item <span class="token operator">=</span> stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 弹出栈顶元素</span>        <span class="token keyword">if</span> item <span class="token operator">></span> max_value<span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># 如果弹出的元素大于当前最大值</span>            max_value <span class="token operator">=</span> item  <span class="token comment" spellcheck="true"># 更新最大值</span>    <span class="token keyword">return</span> max_value  <span class="token comment" spellcheck="true"># 返回最大值</span></code></pre><ul><li>优点：在遍历数组时使用栈，不需要额外的空间。</li><li>缺点：时间复杂度仍为O(n)。</li></ul><p>示例问题演示了不同数据结构和算法的应用和效果。选择合适的数据结构和算法取决于问题的要求和复杂性。在实际应用中，我们需要综合考虑时间复杂度、空间复杂度和问题规模来选择最适合的方法。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>怀着敬畏和好奇的心，深入研究数据结构与算法，感受它们的魅力，不断探索，不断学习，为创造更美好的计算机科学未来努力前行。学无止境，探索无穷，数据结构与算法永远是我们不竭的源泉，也是人类智慧的永恒结晶。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><p><strong>《大话数据结构》</strong>：这是一本经典的书籍，以通俗易懂的方式介绍了数据结构和算法的基本概念。它适合初学者，提供了对数据结构和算法的良好入门。</p></li><li><p><strong>《算法图解》</strong>：这本书以图解的方式阐述了各种算法，使复杂的概念更容易理解。它适合那些希望更深入了解算法的人，无论是初学者还是有经验的开发人员。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 编程 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker:容器技术应用与常用命令</title>
      <link href="/ji-zhu-fen-xiang-docker-rong-qi-ji-zhu-ying-yong-yu-chang-yong-ming-ling.html"/>
      <url>/ji-zhu-fen-xiang-docker-rong-qi-ji-zhu-ying-yong-yu-chang-yong-ming-ling.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>个人基于hexo做了个博客网站，同时基于hugo做了一个导航网站；两者都基于一定的环境依赖，需要配置一定的环境，才能做一些操作；</p><p>Hexo博客每次的生成和部署都需要环境、依赖资源和所有博客文件，所以如果我们要换一台电脑写博客，则需要配置相同的环境、依赖和所有博客文件，最简单的方法就是用U盘或者其他存储方式拷贝；或者使用GitHub仓库； 更高级的方法是使用 Docker，它可以更方便地打包整个 Hexo 环境和依赖，以便在任何支持 Docker 的计算机上运行，无需重新配置 </p><h1 id="迁移的三种方式"><a href="#迁移的三种方式" class="headerlink" title="迁移的三种方式"></a>迁移的三种方式</h1><p>当你想在另一台电脑上继续管理和开发Hexo网站时，电脑A为原电脑，电脑B为一台没有任何环境的电脑，以下是三种常用的方法：</p><ol><li><p>使用U盘拷贝：</p><ul><li>在电脑A上将Hexo网站的文件和依赖项复制到U盘中。</li><li>将U盘连接到电脑B，将文件和依赖项复制到电脑B上。</li><li>在电脑B上安装Git和Node.js。</li><li>进入Hexo网站根目录，执行<code>npm install</code>安装依赖项。</li></ul><p>使用U盘拷贝的优点：</p><ul><li>便捷：U盘是一种常见的便携式存储设备，可以轻松地将文件和依赖项从一台电脑复制到另一台电脑。</li><li>简单：整个过程相对简单，不需要涉及复杂的工具或网络连接。</li></ul><p>使用U盘拷贝的缺点：</p><ul><li>繁琐：每次更新网站时都需要手动复制文件和依赖项，如果经常需要更新则会比较繁琐。</li><li>可能会存在版本差异：如果电脑A和电脑B的环境配置有所不同，可能会导致一些依赖项无法正常工作。</li></ul></li></ol><ol start="2"><li><p>使用GitHub仓库：</p><ul><li>在电脑A上创建一个GitHub仓库，并将Hexo网站的文件和依赖项推送到该仓库。</li><li>在电脑B上克隆该GitHub仓库的代码。</li><li>在电脑B上安装Git和Node.js。</li><li>进入Hexo网站根目录，执行<code>npm install</code>安装依赖项。</li><li>可以在电脑B上继续使用Hexo开发和管理网站了。每次在电脑B上进行更改后，可以将更改推送到GitHub仓库，以便在其他设备上同步。</li></ul><p>使用GitHub仓库的优点：</p><ul><li>版本控制：GitHub仓库可以方便地进行版本控制，记录每次提交的更改并提供协作功能。</li><li>管理方便：可以在不同设备上同步Hexo网站，并方便地进行代码管理和共享。</li></ul><p>使用GitHub仓库的缺点：</p><ul><li>需要网络连接：使用GitHub需要良好的网络连接，如果没有网络连接则无法进行同步和推送更改。</li><li>需要学习Git：使用GitHub仓库需要一定程度上的Git使用知识，对于初学者可能需要一些时间来适应。</li></ul></li></ol><ol start="3"><li><p>使用Docker镜像：</p><ul><li>在电脑A上构建一个包含Git和Node.js环境的Docker镜像，并将Hexo网站的文件和依赖项包含在镜像中。</li><li>将该Docker镜像导出为tar文件。</li><li>将tar文件传输到电脑B，并在电脑B上导入Docker镜像。</li><li>在电脑B上运行容器，以启动Hexo网站。</li><li>通过访问主机的4000端口在电脑B上访问Hexo网站</li></ul><p>使用Docker镜像的优点：</p><ul><li>环境一致性：Docker镜像能够提供相同的开发环境，确保在不同电脑上运行Hexo网站时，所需的环境一致。</li><li>可移植性：Docker容器可以在不同机器上轻松部署，减少了配置和安装的麻烦。</li></ul><p>使用Docker镜像的缺点：</p><ul><li>需要学习Docker：使用Docker需要一定的学习曲线，对于不熟悉Docker的用户来说，可能需要花费一些时间来学习和理解Docker的使用。</li><li>资源消耗：Docker容器需要一定的系统资源，包括内存和存储空间。</li></ul></li></ol><p>这三种方法各有优劣，取决于具体需求和使用场景。如果只需要简单地将Hexo网站文件复制到另一台电脑，使用U盘拷贝可能是最方便的方法。如果需要在多台设备之间同步和版本控制，使用GitHub仓库是一个不错的选择。而如果希望封装整个开发环境并在不同的机器上快速部署，使用Docker镜像可能更适合。</p><h1 id="什么是docker？"><a href="#什么是docker？" class="headerlink" title="什么是docker？"></a>什么是docker？</h1><h2 id="官方解释"><a href="#官方解释" class="headerlink" title="官方解释"></a>官方解释</h2><p>Docker是一种轻量级的容器化技术，可以帮助开发人员更有效地构建、部署和管理应用程序。下面是一些常见的Docker实用例子：</p><ol><li>应用程序打包和交付：Docker可以将应用程序及其所有依赖项打包到一个容器中，形成一个独立、可移植的单元。这使得应用程序在不同的环境中更容易部署和交付，并且能够确保应用程序在不同平台上具有一致的行为。</li><li>快速环境搭建和测试：Docker容器可以帮助快速创建和销毁开发、测试和演示环境。开发人员可以使用包含所需软件和配置的Docker镜像来快速搭建开发环境，而无需手动安装和配置各种依赖项。同时，Docker容器的隔离性确保了环境之间的互相隔离，避免了互相干扰。</li><li>扩展和负载均衡：使用Docker容器，可以很容易地创建多个相同的容器实例，形成一个应用程序的集群。这样可以实现应用程序的水平扩展和负载均衡，以提高性能和可靠性。</li><li>微服务架构：Docker可以配合微服务架构使用，将一个大型应用程序拆分为多个小型的、独立部署的服务。每个服务都可以打包为一个独立的容器，使得每个服务可以独立地进行开发、测试和部署，并且可以根据需要进行扩展和升级。</li><li>持续集成和持续部署：Docker容器可以与持续集成和持续部署工具集成，帮助实现快速、可靠的软件交付流程。容器化的应用程序可以更容易地在不同的环境中进行测试和部署，从而加速软件交付的速度和质量。</li></ol><h2 id="通俗化理解"><a href="#通俗化理解" class="headerlink" title="通俗化理解"></a>通俗化理解</h2><ul><li>dockerfile： image的源代码 </li><li>image： 可执行程序 </li><li>container： 运行起来的进程</li><li>docker：编译器</li></ul><p>在dockerfile中指定需要哪些程序、依赖什么样的配置，之后把dockerfile交给“编译器”docker进行“编译”，也就是docker build命令，生成的可执行程序就是image，之后就可以运行这个image了，这就是docker run命令，image运行起来后就是docker container。 </p><h1 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h1><ol><li><p>Docker镜像（Images）：理解Docker镜像的概念，它是用于构建容器的模板。镜像包含了运行应用程序所需的一切，如操作系统、库、依赖项等。</p></li><li><p>Docker容器（Containers）：容器是基于Docker镜像创建的运行实例。容器是可执行、可移植且可隔离的，可以在不同的环境中运行。</p></li><li><p>Dockerfile：Dockerfile是用于构建Docker镜像的文本文件。它描述了一系列指令，用于定义镜像的构建步骤和配置。</p></li><li><p>构建镜像：使用Dockerfile和docker build命令构建自定义的Docker镜像。通过指定Dockerfile路径和镜像名称，运行docker build命令来构建镜像。</p></li><li><p>运行容器：使用docker run命令来创建和运行容器。通过指定镜像名称和其他选项，比如端口映射、环境变量等，可以创建一个新的容器实例。</p></li><li><p>容器生命周期管理：了解常用的Docker命令，如docker start、docker stop、docker restart等，用于启动、停止和重启容器。</p></li><li><p>容器网络：学习如何在Docker中配置容器之间的网络连接，以及如何将容器暴露给主机或外部网络。</p></li><li><p>Docker Compose：学习使用Docker Compose来定义和管理多个容器组成的应用程序。使用YAML文件描述应用程序的不同服务，然后使用docker-compose命令启动、停止和管理这些服务。</p></li><li><p>数据卷（Volumes）：了解数据卷的概念，它是用于持久化存储容器数据的方法。数据卷可以在容器之间共享和重用，并且对宿主机和其他容器都是可访问的。</p></li><li><p>Docker Hub：熟悉Docker Hub，它是一个公共的Docker镜像仓库。可以从Docker Hub上获取现有的镜像，也可以上传自己构建的镜像到Docker Hub进行分享和存储。</p></li></ol><h1 id="常用的Docker命令"><a href="#常用的Docker命令" class="headerlink" title="常用的Docker命令"></a>常用的Docker命令</h1><ol><li><p>构建镜像：</p><pre><code>docker build -t &lt;image_name&gt; &lt;dockerfile_path&gt;</code></pre></li><li><p>运行容器：</p><pre><code>docker run -d --name &lt;container_name&gt; &lt;image_name&gt;</code></pre></li><li><p>列出正在运行的容器：</p><pre><code>docker ps</code></pre></li><li><p>列出所有容器（包括已停止的）：</p><pre><code>docker ps -a</code></pre></li><li><p>停止容器：</p><pre><code>docker stop &lt;container_name&gt;</code></pre></li><li><p>启动已停止的容器：</p><pre><code>docker start &lt;container_name&gt;</code></pre></li><li><p>删除容器：</p><pre><code>docker rm &lt;container_name&gt;</code></pre></li><li><p>列出镜像：</p><pre><code>docker images</code></pre></li><li><p>删除镜像：</p><pre><code>docker rmi &lt;image_name&gt;</code></pre></li><li><p>查看容器日志：</p><pre><code>docker logs &lt;container_name&gt;</code></pre></li><li><p>进入容器的交互式模式：</p><pre><code>docker exec -it &lt;container_name&gt; bash</code></pre></li><li><p>复制文件到/从容器：</p><pre><code>docker cp &lt;local_path&gt; &lt;container_name&gt;:&lt;container_path&gt;docker cp &lt;container_name&gt;:&lt;container_path&gt; &lt;local_path&gt;</code></pre></li><li><p>构建并启动Compose定义的服务：</p><pre><code>docker-compose up -d</code></pre></li><li><p>关闭已启动的Compose服务：</p><pre><code>docker-compose down</code></pre></li></ol><h1 id="docker-pull"><a href="#docker-pull" class="headerlink" title="docker pull"></a>docker pull</h1><p><code>docker pull</code>命令用于从Docker镜像仓库中拉取（下载）一个镜像到本地。以下是<code>docker pull</code>命令的使用方式：</p><pre><code>docker pull &lt;image_name&gt;</code></pre><p>其中，<code>&lt;image_name&gt;</code>指定了要拉取的镜像名称，可以是官方仓库中的镜像，也可以是自定义的仓库中的镜像。</p><p>例如，要拉取官方的Ubuntu镜像，可以运行以下命令：</p><pre><code>docker pull ubuntu</code></pre><p>如果要拉取指定版本的镜像，可以在镜像名称后面添加<code>:&lt;tag&gt;</code>，如下所示：</p><pre><code>docker pull ubuntu:20.04</code></pre><p>这将拉取Ubuntu 20.04版本的镜像。</p><p>执行<code>docker pull</code>命令后，Docker将开始下载镜像并保存到本地。你可以使用<code>docker images</code>命令查看已下载的镜像列表。</p><blockquote><p>使用<code>docker pull</code>命令需要联网，并且要确保本地环境可以连接到Docker镜像仓库。如果你使用的是私有仓库，还需要提供相应的身份验证信息。</p></blockquote><h1 id="docker实践"><a href="#docker实践" class="headerlink" title="docker实践"></a>docker实践</h1><h2 id="使用Docker将Hexo网站打包为一个镜像"><a href="#使用Docker将Hexo网站打包为一个镜像" class="headerlink" title="使用Docker将Hexo网站打包为一个镜像"></a>使用Docker将Hexo网站打包为一个镜像</h2><p>创建一个Dockerfile：在你Hexo网站根目录下创建一个名为Dockerfile的文件，并使用文本编辑器打开它。</p><ol start="2"><li>编写Dockerfile：在Dockerfile中，指定基础镜像以及构建和运行过程所需的命令</li></ol><pre class=" language-dockerfile"><code class="language-dockerfile"># 使用Node.js作为基础镜像FROM node:14-alpine# 设置工作目录WORKDIR /app# 复制网站文件到容器中COPY . .# 安装依赖RUN npm install# 执行Hexo命令生成静态网站RUN npx hexo generate# 暴露Hexo服务的端口EXPOSE 4000# 启动Hexo服务CMD ["npx", "hexo", "server"]</code></pre><p>以上Dockerfile使用了Node.js 14的Alpine版本作为基础镜像。它先将当前目录下的所有文件复制到容器的/app目录中，然后安装Hexo所需的依赖、生成静态网站并暴露4000端口，最后启动Hexo服务。</p><ol start="3"><li>构建镜像：在终端中进入Dockerfile所在的目录，并执行以下命令来构建镜像：</li></ol><pre><code>docker build -t &lt;image_name&gt; .    #使用当前目录作为上下文进行构建</code></pre><p>其中，<code>&lt;image_name&gt;</code>镜像起的名称，自定义；这个命令会在当前目录下根据Dockerfile构建一个镜像，并使用指定的名称标记它。</p><ol start="4"><li>运行容器：构建完成后，你可以使用以下命令来创建并运行一个容器：</li></ol><pre><code>docker run -d --name &lt;container_name&gt; -p 4000:4000 &lt;image_name&gt;</code></pre><p><code>&lt;container_name&gt;</code>为容器起的名称，可以自定义；<code>&lt;image_name&gt;</code>之前构建的镜像的名称。</p><p>此命令将创建一个后台运行的容器，将主机的4000端口映射到容器的4000端口，通过主机的4000端口可以访问Hexo网站。</p><h2 id="将Docker镜像部署到一台没有任何环境的电脑上运行"><a href="#将Docker镜像部署到一台没有任何环境的电脑上运行" class="headerlink" title="将Docker镜像部署到一台没有任何环境的电脑上运行"></a>将Docker镜像部署到一台没有任何环境的电脑上运行</h2><ol><li>将镜像导出：在已经构建好的Docker镜像所在的电脑上，使用以下命令将镜像导出为一个tar文件：</li></ol><pre><code>docker save -o &lt;image_file_name&gt;.tar &lt;image_name&gt;</code></pre><p><code>&lt;image_file_name&gt;</code>导出的镜像文件的名称，自定义；<code>&lt;image_name&gt;</code>是你之前构建的镜像的名称。</p><ol start="2"><li><p>将镜像移动到目标电脑：将导出的镜像文件（tar文件）通过移动、复制等方式传输到目标电脑上。</p></li><li><p>导入镜像：在目标电脑上，在终端中进入存放镜像文件的目录，并执行以下命令将镜像导入Docker中：</p></li></ol><pre><code>docker load -i &lt;image_file_name&gt;.tar</code></pre><p>其中，<code>&lt;image_file_name&gt;</code>是你导出的镜像文件的名称，可以自定义。这个命令会将镜像文件加载到Docker中，使得你可以在目标电脑上使用该镜像。</p><ol start="4"><li>运行容器：在目标电脑上，创建并运行一个容器：</li></ol><pre><code>docker run -d --name &lt;container_name&gt; -p 4000:4000 &lt;image_name&gt;</code></pre><p>其中，<code>&lt;container_name&gt;</code>是你为容器起的名称，可以自定义；<code>&lt;image_name&gt;</code>是你导入的镜像的名称。</p><p>这个命令将创建一个后台运行的容器，将主机的4000端口映射到容器的4000端口，使得你可以通过主机的4000端口访问Hexo网站。Hexo网站便可在目标电脑上成功部署并运行了。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p> Docker是一项流行的容器化技术，它帮助开发人员和运维团队更轻松地构建、部署和管理应用程序。使用Docker，可以将应用程序及其所有依赖项打包到一个可移植的容器中，然后在任何支持Docker的环境中运行；</p>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> 技术分享 </tag>
            
            <tag> 容器技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git:分布式版本控制系统的入门指南</title>
      <link href="/gong-ju-git-fen-bu-shi-ban-ben-kong-zhi-xi-tong-de-ru-men-zhi-nan.html"/>
      <url>/gong-ju-git-fen-bu-shi-ban-ben-kong-zhi-xi-tong-de-ru-men-zhi-nan.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Git是什么？"><a href="#Git是什么？" class="headerlink" title="Git是什么？"></a>Git是什么？</h1><h2 id="1-git简介"><a href="#1-git简介" class="headerlink" title="1.git简介"></a>1.git简介</h2><p>Git是一个分布式版本控制系统，用于跟踪文件和项目的变化。它可以帮助开发人员在多人协作的项目中管理代码，记录每一次修改，并且能够方便地回退到任何历史版本。Git还提供了分支管理功能，使得开发人员能够同时处理多个功能或修复不同的 bug，而不会相互干扰。</p><h2 id="2-目前世界上最先进的分布式版本控制系统"><a href="#2-目前世界上最先进的分布式版本控制系统" class="headerlink" title="2.目前世界上最先进的分布式版本控制系统"></a>2.<strong>目前世界上最先进的分布式版本控制系统</strong></h2><p>版本控制系统是一种记录和管理文件或项目的变化的工具。它允许开发人员追踪文件的每一次修改、添加或删除，并记录这些变化的详细信息，包括时间、作者和具体修改内容等。  <strong>版本控制系统使得文件或项目的修改和协作变得更加有序、可追溯和高效。</strong> </p><p>假设你正在编写一个文本文件，并使用版本控制系统进行管理。</p><p>你开始编写一个名为 “example.txt” 的文件，内容是 “Hello, World!”。你将这个文件添加到版本控制系统中，并提交它。</p><p>接下来，你修改了该文件的内容，将其改为 “Hello, Universe!”。你再次将修改后的文件添加到版本控制系统，并提交。</p><p>现在，假设你意识到之前的修改有问题，你想回退到初始状态。通过版本控制系统，你可以轻松地切换回之前的版本，即 “Hello, World!”。</p><p>如果有其他人与你协作在同一个项目中，版本控制系统可以帮助你合并彼此的修改。如果你的合作者将文件内容改为了 “Hello, Galaxy!”，你可以使用版本控制系统将两个不同的修改整合在一起，得到最新的版本。</p><p>总结来说，版本控制系统可以帮助你跟踪和管理文件的变化，并允许你在需要时轻松地切换、合并和恢复不同版本的文件。</p><h2 id="3-git的诞生"><a href="#3-git的诞生" class="headerlink" title="3.git的诞生"></a>3.git的诞生</h2><p>Linus在1991年创建了开源的Linux，从此，Linux系统不断发展，已经成为最大的服务器系统软件，作为开源软件，全世界的人都可以参与编写，管理linux的代码就成为一个重要的事情了；<br>在那个时候，Linux 内核开发团队使用一个名为 BitKeeper 的商业版本控制系统来管理代码。然而，由于某些原因，BitKeeper 的免费使用权被撤销，迫使 Linux 内核开发团队需要寻找一个新的版本控制系统。 </p><p>遇到问题，大佬们的做法真就是那么简单粗暴，大佬亲自出手， 花了两周时间， 用C写了一个分布式版本控制系统 ，于是，Git就此诞生了，Git 的开发历时约两周左右的时间完成初版。Linus Torvalds 在2005年4月7日开始编写 Git 的原型，并在两周后的4月19日发布了第一个公开版本 ；</p><blockquote><p>大佬们的世界就是不一样，很佩服，膜拜！！！！！！！！！！！！！！！</p></blockquote><h2 id="4-集中式与分布式版本控制系统的区别"><a href="#4-集中式与分布式版本控制系统的区别" class="headerlink" title="4.集中式与分布式版本控制系统的区别"></a>4.集中式与分布式版本控制系统的区别</h2><p>集中式版本控制系统（Centralized Version Control System，简称 CVCS）和分布式版本控制系统（Distributed Version Control System，简称 DVCS）是两种不同的代码管理工具。</p><p>在集中式版本控制系统中，存在一个中央服务器，所有开发者都通过客户端连接到这个中央服务器来获取最新的代码版本，并将自己的修改提交到中央服务器。开发者之间的协作都是通过与中央服务器进行交互完成的。典型的 CVCS 包括 SVN（Subversion）和 CVS（Concurrent Versions System）。</p><p>而分布式版本控制系统则没有中央服务器的概念，每个开发者都拥有完整的代码仓库副本。开发者可以在本地进行代码修改、提交和版本管理的操作，同时也可以将自己的修改推送给其他开发者，实现分布式的协作。常见的 DVCS 包括 Git 和 Mercurial。</p><p>简单来说，集中式版本控制系统的核心是中央服务器，所有操作都需要与中央服务器进行交互；而分布式版本控制系统允许每个开发者都拥有完整的代码副本，并且可以在本地进行操作，方便离线工作和并行开发。</p><p>举个通俗易懂的例子，可以将集中式版本控制系统比作图书馆，每个人需要去图书馆借书并归还，大家必须通过图书馆来查找和管理图书，而分布式版本控制系统就像是每个人都有自己的图书库，可以独立地借阅和归还书籍，同时也可以互相分享自己的书籍。这样的话，即使图书馆关闭了，每个人仍然可以在自己的图书库中继续阅读和管理书籍。</p><h1 id="Git的安装"><a href="#Git的安装" class="headerlink" title="Git的安装"></a>Git的安装</h1><p> Git可以在Linux、Unix、Mac和Windows等安装运行</p><h2 id="在Linux上安装Git"><a href="#在Linux上安装Git" class="headerlink" title="在Linux上安装Git"></a>在Linux上安装Git</h2><p> Debian或Ubuntu Linux </p><pre class=" language-linux"><code class="language-linux">sudo apt-get install git</code></pre><p> 其他Linux版本，通过源码安装，先从Git官网下载源码，然后解压，依次输入：<code>./config</code>，<code>make</code>，<code>sudo make install</code>这几个命令即可</p><h2 id="在windows上安装"><a href="#在windows上安装" class="headerlink" title="在windows上安装"></a>在windows上安装</h2><p>直接官网安装包，下载安装，成功安装后，做以下操作：</p><pre><code>$ git config --global user.name &quot;Your Name&quot;$ git config --global user.email &quot;email@example.com&quot;</code></pre><p> 在使用 Git 进行版本控制的过程中，配置用户姓名和电子邮件是非常重要的步骤。这样做的目的是为了标识代码的提交者，并为项目的历史记录提供准确的身份信息。 <strong>global参数</strong>： 通过配置全局用户姓名和电子邮件，您无需每次都手动输入这些信息，而是在首次设置后自动应用于所有的 Git 仓库和操作中。这样可以节省时间并确保一致性。 </p><h1 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h1><h2 id="什么是版本库？"><a href="#什么是版本库？" class="headerlink" title="什么是版本库？"></a>什么是版本库？</h2><p> 版本库又名仓库，英文名<strong>repository</strong>，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。 </p><h2 id="创建步骤"><a href="#创建步骤" class="headerlink" title="创建步骤:"></a>创建步骤:</h2><p>创建 Git 版本库的步骤如下：</p><ol><li><p>初始化版本库：打开命令行终端或 Git Bash，<strong>导航到您希望创建版本库的目录中</strong>。然后运行以下命令初始化一个新的 Git 版本库：</p><pre class=" language-git"><code class="language-git">git init</code></pre><blockquote><p>初始化后有个隐藏的 .git 目录， 这个目录是Git来跟踪管理版本库的 ，非必要不要修改它，乱了的话会破坏git仓库</p></blockquote></li></ol><ol start="2"><li><p>添加文件到版本库：将要跟踪和管理的文件添加到版本库中。可以使用以下命令将文件添加到暂存区：</p><pre><code>git add &lt;文件名&gt;</code></pre><p>或者使用以下命令将所有修改的文件添加到暂存区：</p><pre><code>git add .</code></pre></li><li><p>提交更改：当您已经将文件添加到暂存区后，可以使用以下命令提交更改到版本库：</p><pre><code>git commit -m &quot;提交描述&quot;</code></pre><p>将 “提交描述” 替换为简洁明了的提交描述信息，用于说明此次提交的目的和内容。</p></li><li><p>可选步骤：关联远程仓库（如果需要）：如果您打算将代码托管到远程仓库（如 GitHub、GitLab等），则可以执行以下操作关联远程仓库：</p><pre><code>git remote add origin &lt;远程仓库地址&gt;</code></pre><p>将 “&lt;远程仓库地址&gt;” 替换为实际的远程仓库地址。</p></li><li><p>将代码推送到远程仓库（如果需要）：如果您已经关联了远程仓库，并且想要将本地代码推送到远程仓库，可以使用以下命令：</p><pre><code>git push origin &lt;分支名称&gt;</code></pre><p>将 “&lt;分支名称&gt;” 替换为要推送的分支名称（通常是 “master” 或 “main”）。</p></li></ol><p>至此，已经成功创建了一个 Git 版本库，并将文件添加、提交到版本库中。根据需要，还可以执行其他操作，如创建和切换分支，合并分支等，以充分利用 Git 的强大功能。</p><h1 id="Git配置ssh"><a href="#Git配置ssh" class="headerlink" title="Git配置ssh"></a>Git配置ssh</h1><h2 id="1-生成SSH密钥对："><a href="#1-生成SSH密钥对：" class="headerlink" title="1 生成SSH密钥对："></a>1 生成SSH密钥对：</h2><pre class=" language-bash"><code class="language-bash">ssh-keygen -t rsa -C <span class="token string">"your_email@example.com"</span></code></pre><h2 id="2-添加SSH密钥到代理（可选）："><a href="#2-添加SSH密钥到代理（可选）：" class="headerlink" title="2 添加SSH密钥到代理（可选）："></a>2 添加SSH密钥到代理（可选）：</h2><p> 可以将SSH密钥添加到代理中以方便使用。运行以下命令来启动SSH代理： </p><pre class=" language-bash"><code class="language-bash"><span class="token function">eval</span> <span class="token string">"<span class="token variable"><span class="token variable">$(</span>ssh-agent -s<span class="token variable">)</span></span>"</span></code></pre><p> 将私钥添加到代理： </p><pre class=" language-bash"><code class="language-bash">ssh-add ~/.ssh/id_rsa</code></pre><h2 id="3将公钥添加到Git托管平台："><a href="#3将公钥添加到Git托管平台：" class="headerlink" title="3将公钥添加到Git托管平台："></a>3将公钥添加到Git托管平台：</h2><p>打开使用的Git托管平台（如GitHub、GitLab等），到个人设置或账户设置页面。找到SSH密钥的选项。将公钥（位于<code>~/.ssh/id_rsa.pub</code>文件中）复制并粘贴到该页面的适当位置。保存并添加该SSH密钥。 </p><h2 id="4-测试SSH连接"><a href="#4-测试SSH连接" class="headerlink" title="4 测试SSH连接"></a>4 测试SSH连接</h2><pre class=" language-bash"><code class="language-bash"><span class="token function">ssh</span> -T git@github.com<span class="token comment" spellcheck="true">#成功则显示</span>Hi <span class="token punctuation">{</span>username<span class="token punctuation">}</span><span class="token operator">!</span> You've successfully authenticated, but GitHub does not provide shell access.</code></pre><p> Git已经配置为使用SSH进行身份验证。当你克隆或推送存储库时，Git将使用SSH密钥进行认证。这样，可以安全地与Git托管平台进行交互，而无需每次都输入用户名和密码。 </p><h1 id="Git终端模拟过程"><a href="#Git终端模拟过程" class="headerlink" title="Git终端模拟过程"></a>Git终端模拟过程</h1><pre class=" language-bash"><code class="language-bash">Welcome to the Git Terminal Simulator<span class="token operator">!</span>Type <span class="token string">'help'</span> to see a list of available commands.<span class="token operator">></span> <span class="token function">help</span>Available commands:- <span class="token function">git</span> init: Create a new Git repository/创建一个新的 Git 仓库- <span class="token function">git</span> add <span class="token punctuation">[</span>file<span class="token punctuation">]</span>: Add a <span class="token function">file</span> to the staging area/将文件添加到暂存区- <span class="token function">git</span> commit -m <span class="token punctuation">[</span>message<span class="token punctuation">]</span>: Commit changes with a message/提交带有消息的更改- <span class="token function">git</span> status: Show the current status of the repository/显示仓库当前状态- <span class="token function">git</span> log: Show the commit history/显示提交历史记录- <span class="token function">git</span> checkout <span class="token punctuation">[</span>commit hash<span class="token punctuation">]</span>: Switch to a specific commit/切换到特定的提交- <span class="token function">git</span> branch: List all branches <span class="token keyword">in</span> the repository/列出仓库中的所有分支- <span class="token function">git</span> branch <span class="token punctuation">[</span>branch name<span class="token punctuation">]</span>: Create a new branch/创建一个新的分支- <span class="token function">git</span> branch -d <span class="token punctuation">[</span>branch name<span class="token punctuation">]</span>: Delete a branch/删除一个分支- <span class="token function">git</span> merge <span class="token punctuation">[</span>branch name<span class="token punctuation">]</span>: Merge a branch into the current branch/将一个分支合并到当前分支- <span class="token function">git</span> remote add <span class="token punctuation">[</span>remote name<span class="token punctuation">]</span> <span class="token punctuation">[</span>remote URL<span class="token punctuation">]</span>: Add a remote repository/添加一个远程仓库- <span class="token function">git</span> push <span class="token punctuation">[</span>remote name<span class="token punctuation">]</span> <span class="token punctuation">[</span>branch name<span class="token punctuation">]</span>: Push changes to a remote repository/将更改推送到远程仓库- <span class="token function">git</span> pull <span class="token punctuation">[</span>remote name<span class="token punctuation">]</span> <span class="token punctuation">[</span>branch name<span class="token punctuation">]</span>: Pull changes from a remote repository/从远程仓库拉取更改- exit: Exit the simulator<span class="token operator">></span> <span class="token function">git</span> initInitialized empty Git repository.<span class="token operator">></span> <span class="token function">git</span> add file.txtAdded file.txt to the staging area.<span class="token operator">></span> <span class="token function">git</span> commit -m <span class="token string">"Initial commit"</span>Committed changes with message: Initial commit.<span class="token operator">></span> <span class="token function">git</span> statusOn branch masterNo uncommitted changes.<span class="token operator">></span> <span class="token function">git</span> logCommit 4eeb3a9 <span class="token punctuation">(</span>HEAD -<span class="token operator">></span> master<span class="token punctuation">)</span>: Initial commitAuthor: User <span class="token operator">&lt;</span>user@example.com<span class="token operator">></span>Date:   Mon Jul 25 11:41:35 2023 +0000<span class="token operator">></span> <span class="token function">git</span> branch featureCreated branch <span class="token string">'feature'</span><span class="token keyword">.</span><span class="token operator">></span> <span class="token function">git</span> branch* master  feature<span class="token operator">></span> <span class="token function">git</span> checkout featureSwitched to branch <span class="token string">'feature'</span><span class="token keyword">.</span><span class="token operator">></span> <span class="token function">git</span> add new_file.txtAdded new_file.txt to the staging area.<span class="token operator">></span> <span class="token function">git</span> commit -m <span class="token string">"Add new_file.txt"</span>Committed changes with message: Add new_file.txt.<span class="token operator">></span> <span class="token function">git</span> merge featureMerged branch <span class="token string">'feature'</span> into <span class="token string">'master'</span><span class="token keyword">.</span><span class="token operator">></span> <span class="token function">git</span> remote add origin https://github.com/user/repo.gitAdded remote repository <span class="token string">'origin'</span> at https://github.com/user/repo.git.<span class="token operator">></span> <span class="token function">git</span> push origin masterPushed changes to remote repository <span class="token string">'origin'</span> <span class="token keyword">in</span> branch <span class="token string">'master'</span><span class="token keyword">.</span><span class="token operator">></span> <span class="token keyword">exit</span>Goodbye<span class="token operator">!</span></code></pre><h1 id="Git常用命令"><a href="#Git常用命令" class="headerlink" title="Git常用命令"></a>Git常用命令</h1><p>以下是一些常用的Git命令及其功能的简要介绍：</p><ol><li><p>git init：在当前目录初始化一个新的Git代码库。</p></li><li><p>git clone \<repository>：从远程仓库克隆一个完整的副本到本地。</repository></p></li><li><p>git add \<file>：将文件添加到暂存区，准备提交。</file></p></li><li><p>git commit -m “\<message>“：将暂存区的文件提交到本地仓库，并附带一条描述性消息。</message></p></li><li><p>git status：查看工作区、暂存区和本地仓库的状态。</p></li><li><p>git log：查看提交历史记录。</p></li><li><p>git pull：从远程仓库拉取最新的更改。</p></li><li><p>git push：将本地仓库的更改推送到远程仓库。</p></li><li><p>git branch：列出所有分支。</p></li><li><p>git checkout \<branch>：切换到指定分支。</branch></p></li><li><p>git merge \<branch>：将指定分支合并到当前分支。</branch></p></li><li><p>git remote add \<name> \<url>：将远程仓库关联到本地仓库。</url></name></p></li><li><p>git remote -v：查看远程仓库的详细信息。</p></li><li><p>git diff：查看当前工作区与暂存区之间的差异。</p></li><li><p>git reset \<file>：从暂存区中移除文件，但保留本地修改。</file></p></li><li><p>git rm \<file>：从版本控制系统中删除文件。</file></p></li></ol><h1 id="Git进阶命令"><a href="#Git进阶命令" class="headerlink" title="Git进阶命令"></a>Git进阶命令</h1><p>一些进阶的Git命令和技巧：</p><ol><li>git branch -d \<branch>：删除指定的分支。</branch></li><li>git checkout -b \<branch>：创建一个新的分支并切换到该分支。</branch></li><li>git merge –no-ff \<branch>：执行非快进合并，保留分支的历史记录。</branch></li><li>git stash：将当前未提交的修改暂存起来，以便可以在其他分支上切换。</li><li>git remote show \<remote>：查看远程仓库的详细信息，包括分支、标签等。</remote></li><li>git fetch：从远程仓库下载最新的提交，但不进行合并。</li><li>git rebase \<branch>：将当前分支的提交应用到目标分支上，产生线性的提交历史。</branch></li><li>git cherry-pick \<commit>：选择一个或多个提交，并将其应用到当前分支上。</commit></li><li>git tag \<tag>：创建一个标签，并将其关联到当前的提交。</tag></li><li>git blame \<file>：显示文件的每一行是由谁提交的。</file></li><li>git reset –hard \<commit>：将当前分支的HEAD指针重置到指定的提交，并将工作区和暂存区同步。</commit></li><li>git revert \<commit>：创建一个新的提交，撤销指定的提交。</commit></li><li>git log –graph：以图形化的方式展示提交历史。</li><li>git config：配置Git的各种选项，如用户名、邮箱等。</li><li>git grep \<pattern>：在版本库中搜索匹配指定模式的文件和行。</pattern></li></ol><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p> Git是一个强大而受欢迎的版本控制系统，无论你是个人开发者还是团队，都可以受益于它的功能和特性。通过使用Git，你可以更好地管理和追踪项目的代码变更，轻松地协作开发，并且能够回溯和恢复历史状态。  使用Git能够更好地管理代码、提升开发效率，并且享受到Git带来的诸多好处 ~~</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> 工具 </tag>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Metasploit信息收集</title>
      <link href="/shen-tou-metasploit-xin-xi-shou-ji.html"/>
      <url>/shen-tou-metasploit-xin-xi-shou-ji.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>信息收集有：主动信息收集和被动信息收集；基于各类工具，这次利用渗透框架Metasploit进行目标信息收集，，这个过程包含了前面所有的方式以及多了一些更加极端的获取信息方式，比如获取服务器的<strong>硬件信息，系统用户信息、进程信息</strong>等。</p><h1 id="基于tcp协议收集主机信息"><a href="#基于tcp协议收集主机信息" class="headerlink" title="基于tcp协议收集主机信息"></a>基于tcp协议收集主机信息</h1><h2 id="使用Nmap进行端口扫描"><a href="#使用Nmap进行端口扫描" class="headerlink" title="使用Nmap进行端口扫描"></a><strong>使用Nmap进行端口扫描</strong></h2><p> 启动Metasploit并在msfconsole中输入以下命令来加载nmap模块： </p><pre class=" language-bash"><code class="language-bash">db_nmap -sS -T4 -A -v <span class="token operator">&lt;</span>target-ip<span class="token operator">></span></code></pre><p>将会使用TCP SYN扫描(-sS)以及操作系统和版本检测(-A)，并设置扫描速度为4 (-T4)。这个扫描会返回主机的开放端口、服务详情以及可能的操作系统版本等信息; 如下例子</p><pre class=" language-bash"><code class="language-bash">mfs<span class="token operator">></span> db_nmap -sS -T4 -A -v 192.168.1.23Starting Nmap 7.80 <span class="token punctuation">(</span> https://nmap.org <span class="token punctuation">)</span> at <span class="token punctuation">[</span>current timestamp<span class="token punctuation">]</span>Nmap scan report <span class="token keyword">for</span> 192.168.1.23Host is up <span class="token punctuation">(</span>0.0020s latency<span class="token punctuation">)</span>.Not shown: 997 closed portsPORT   STATE SERVICE VERSION22/tcp <span class="token function">open</span>  <span class="token function">ssh</span>     OpenSSH 7.9p1 Debian 10+deb10u2 <span class="token punctuation">(</span>protocol 2.0<span class="token punctuation">)</span><span class="token operator">|</span> ssh-hostkey: <span class="token operator">|</span>   2048 cc:4f:bf:79:35:58:42:a5:a0:6c:83:30:44:fe:18:db <span class="token punctuation">(</span>RSA<span class="token punctuation">)</span><span class="token operator">|</span>   256 73:07:d3:70:8b:13:6e:8d:06:6f:56:fd:fc:36:c7:71 <span class="token punctuation">(</span>ECDSA<span class="token punctuation">)</span><span class="token operator">|</span>_  256 a3:a0:17:e5:78:b9:ba:20:43:76:60:77:ab:28:53:ef <span class="token punctuation">(</span>ED25519<span class="token punctuation">)</span>80/tcp <span class="token function">open</span>  http    Apache httpd 2.4.38 <span class="token variable"><span class="token punctuation">((</span>Debian<span class="token punctuation">))</span></span><span class="token operator">|</span>_http-server-header: Apache/2.4.38 <span class="token punctuation">(</span>Debian<span class="token punctuation">)</span><span class="token operator">|</span>_http-title: Did not follow redirect to http://192.168.1.23/MAC Address: 00:11:22:33:44:55 <span class="token punctuation">(</span>Unknown<span class="token punctuation">)</span>Device type: general purposeRunning: Linux 3.X<span class="token operator">|</span>4.XOS CPE: cpe:/o:linux:linux_kernel:3 cpe:/o:linux:linux_kernel:4OS details: Linux 3.2 - 4.9Network Distance: 1 hopTRACEROUTEHOP RTT      ADDRESS1   2.00 ms  192.168.1.23OS and Service detection performed. Please report any incorrect results at https://nmap.org/submit/ <span class="token keyword">.</span>Nmap done: 1 IP address <span class="token punctuation">(</span>1 host up<span class="token punctuation">)</span> scanned <span class="token keyword">in</span> 5.69 seconds</code></pre><h2 id="使用ARP-Sweep获取主机列表"><a href="#使用ARP-Sweep获取主机列表" class="headerlink" title="使用ARP Sweep获取主机列表"></a><strong>使用ARP Sweep获取主机列表</strong></h2><pre><code>use auxiliary/scanner/discovery/arp_sweepset RHOSTS &lt;IP range&gt;set THREADS 50run</code></pre><p>如下例子</p><pre class=" language-bash"><code class="language-bash">msf6 auxiliary<span class="token punctuation">(</span>scanner/discovery/arp_sweep<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token keyword">set</span> RHOSTS 192.168.1.23RHOSTS <span class="token operator">=</span><span class="token operator">></span> 192.168.1.23msf6 auxiliary<span class="token punctuation">(</span>scanner/discovery/arp_sweep<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token keyword">set</span> THREADS 50THREADS <span class="token operator">=</span><span class="token operator">></span> 50msf6 auxiliary<span class="token punctuation">(</span>scanner/discovery/arp_sweep<span class="token punctuation">)</span> <span class="token operator">></span> run<span class="token punctuation">[</span>*<span class="token punctuation">]</span> Running module against 192.168.1.23<span class="token punctuation">[</span>*<span class="token punctuation">]</span> Auxiliary module execution completedmsf6 auxiliary<span class="token punctuation">(</span>scanner/discovery/arp_sweep<span class="token punctuation">)</span> <span class="token operator">></span> show optionModule options <span class="token punctuation">(</span>auxiliary/scanner/discovery/arp_sweep<span class="token punctuation">)</span>:   Name     Current Setting  Required  Description   ----     ---------------  --------  -----------   RHOSTS   192.168.1.23     <span class="token function">yes</span>       The target address range or CIDR identifier   THREADS  50               <span class="token function">yes</span>       The number of concurrent threads <span class="token punctuation">(</span>max one per host<span class="token punctuation">)</span></code></pre><h1 id="基于SNMP协议收集主机信息"><a href="#基于SNMP协议收集主机信息" class="headerlink" title="基于SNMP协议收集主机信息"></a>基于SNMP协议收集主机信息</h1><p>简单网络管理协议 (SNMP，Simple Network Management Protocol)，由一组网络管理的标准组成，包含一个应用层协议 (application layer protocol)、数据库模型 (database schema) 和组资源对象。该协议能够支持网络管理系统，用以监测连接到网络上的设备是否有任何引起管理上关注的情况。</p><p>在Metasploit中，你可以使用SNMP枚举模块对使用SNMP协议的主机进行信息收集。</p><p>示例：</p><pre class=" language-bash"><code class="language-bash">use auxiliary/scanner/snmp/snmp_enum<span class="token keyword">set</span> RHOSTS <span class="token operator">&lt;</span>target-ip<span class="token operator">></span>run</code></pre><h1 id="基于SMB协议收集信息"><a href="#基于SMB协议收集信息" class="headerlink" title="基于SMB协议收集信息"></a>基于SMB协议收集信息</h1><p>SMB概述:服务器消息块 (Server Message Block，缩写为 SMB)，又称网络文件共享系统(Common lnternet File System，缩写为CIFS)，一种应用层网络传输协议，由微软开发，主要功能是使网络上的机器能够共享计算机文件、打印机、串行端口和通讯等资源。<br>经过Unix 服务器厂商重新开发后，它可以用于连接Unix 服务器和 Windows 客户机，执行打印和文件共享等任务。</p><p>Metasploit有许多用于从SMB服务收集信息的模块。一个常见的例子是<code>smb_version</code>模块，可以用于获取目标主机的SMB版本信息。</p><p>示例：</p><pre class=" language-bash"><code class="language-bash">use auxiliary/scanner/smb/smb_version<span class="token keyword">set</span> RHOSTS <span class="token operator">&lt;</span>target-ip<span class="token operator">></span>run</code></pre><h1 id="基于SSH协议收集信息"><a href="#基于SSH协议收集信息" class="headerlink" title="基于SSH协议收集信息"></a>基于SSH协议收集信息</h1><p> SSH (Secure Shell) 是一种网络协议，用于通过不安全的网络安全地访问网络服务。它为数据通信提供了强大的加密和安全验证，使得数据能够在服务器和客户端之间安全地传输。SSH常用于远程命令执行和远程文件传输，并且是管理网络设备和系统的重要工具。 </p><p>Metasploit中的<code>ssh_version</code>模块可以帮助我们获取SSH服务器的版本信息。</p><p>示例：</p><pre class=" language-bash"><code class="language-bash">use auxiliary/scanner/ssh/ssh_version<span class="token keyword">set</span> RHOSTS <span class="token operator">&lt;</span>target-ip<span class="token operator">></span>run</code></pre><h1 id="基于FTP协议收集信息"><a href="#基于FTP协议收集信息" class="headerlink" title="基于FTP协议收集信息"></a>基于FTP协议收集信息</h1><p>FTP (文件传输协议) 是一种网络协议，它允许两台计算机之间在互联网上进行文件传输。FTP 是TCP/IP协议的一部分，因此它在互联网上广泛使用。</p><p>FTP 是一种客户端-服务器协议，这意味着用户（客户端）连接到运行 FTP 服务的服务器上，并通过发送命令来请求文件传输和其他相关操作。服务器根据这些命令响应，返回相关的状态和错误信息。</p><p>Metasploit中的<code>ftp_version</code>模块可以用于从目标FTP服务器获取版本信息。</p><p>示例：</p><pre class=" language-bash"><code class="language-bash">use auxiliary/scanner/ftp/ftp_version<span class="token keyword">set</span> RHOSTS <span class="token operator">&lt;</span>target-ip<span class="token operator">></span>run</code></pre><h1 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h1><p>Metasploit作为一款强大的渗透测试工具，其在信息收集方面的能力对于渗透测试过程至关重要。有效的信息收集能够为渗透测试人员提供关于目标系统的重要信息，从而找出系统中的潜在脆弱性，进一步增强网络安全防护力量。使用Metasploit进行信息收集，无疑可以提高渗透测试的效率和成功率。</p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
            <tag> Metasploit </tag>
            
            <tag> 渗透测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Metasploit渗透测试框架：基础应用与安全防护</title>
      <link href="/shen-tou-metasploit-shen-tou-ce-shi-kuang-jia.html"/>
      <url>/shen-tou-metasploit-shen-tou-ce-shi-kuang-jia.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="引言："><a href="#引言：" class="headerlink" title="引言："></a>引言：</h1><p>在网络安全领域，Metasploit无疑是最强大、最广泛使用的渗透测试框架。它提供了大量的工具和模块，可以帮助安全研究人员和渗透测试人员对目标进行详细的攻击模拟和漏洞利用。通过深入了解和熟练使用Metasploit，我们可以更好地理解网络攻击的运作方式，进而更有效地防御这些攻击。 </p><h1 id="Metasploit-渗透测试框架介绍"><a href="#Metasploit-渗透测试框架介绍" class="headerlink" title="Metasploit 渗透测试框架介绍"></a>Metasploit 渗透测试框架介绍</h1><h2 id="Metasploit-简介"><a href="#Metasploit-简介" class="headerlink" title="Metasploit 简介"></a>Metasploit 简介</h2><p>Metasploit 是一个渗透测试平台，使您能够查找，利用和验证漏洞。该平台包括 Metasploit 框架及其商业对手，如 Metasploit Pro。</p><p>Metasploit 是一个免费的、可下载的框架，通过它可以很容易对计算机软件漏洞实施攻击。它本身附带数百个已知软件漏洞的专业级漏洞攻击工具。当H.D.Moore 在2003 年发布 Metasploit 时，计算机安全状况也被永久性地改变了。仿佛一夜之间，任何人都可以成为黑客，每个人都可以使用攻击工具来攻击那些未打过补丁或者刚刚打过补丁的漏洞。软件厂商再也不能推迟发布针对已公布漏洞的补丁了，这是因为 Metasploit 团队一直都在努力开发各种攻击工具，并将它们贡献给所有 Metasploit 用户。</p><h2 id="Postgresql概述"><a href="#Postgresql概述" class="headerlink" title="Postgresql概述:"></a>Postgresql概述:</h2><p>Metasploit 程序需要使用 Postgresql数据库。</p><p>PostgreSQL是一种特性非常齐全的自由软件的对象-关系型数据库管理系统(ORDBMS)，是以加州大学计算机系开发的POSTGRES4.2版本为基础的对象关系型数据库管理系统</p><blockquote><p>注:PostgreSQL: 世界上最先进的开源关系数据库</p><p>扩展: PostgreSQL和 MySQL数据的应用场景区别:</p><p>从应用场景来说，PostgreSQL 更加适合严格的企业应用场景(比如金融、电信、ERP、CRM)，而MySQL更加适合业务逻辑相对简单、数据可靠性要求较低的互联网场景</p></blockquote><pre><code>systemctl start postgresqlsystemctl enable postgresql    </code></pre><h1 id="Metasploit-基本使用方法"><a href="#Metasploit-基本使用方法" class="headerlink" title="Metasploit 基本使用方法"></a>Metasploit 基本使用方法</h1><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="命令类型"><a href="#命令类型" class="headerlink" title="命令类型"></a>命令类型</h3><pre><code>kali@kali:~$ msfconsole        #进入msf</code></pre><blockquote><p>注:通过 help 查看帮助，可以对 msf 有个整体认识，可以看到 msf 相关命令可以分成以下类型:<br><strong>Core Commands</strong>    #核心命令<br><strong>Module Commands</strong>    #模块命令<br><strong>Job Commands</strong>    #后台任务命令<br>Resource Script Commands    #资源脚本命令<br>Database Backend Commands    #数据库后端命令<br>Credentials Backend Commands     #证书/凭证后端命令<br>Developer Commands     #开发人员命令</p></blockquote><h4 id="Core-Commands"><a href="#Core-Commands" class="headerlink" title="Core Commands"></a><strong>Core Commands</strong></h4><pre class=" language-bash"><code class="language-bash">msf <span class="token operator">></span> <span class="token function">help</span>Core Commands<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span>    Command       Description    -------       -----------    ?             Help menu    back          Move back from the current context    banner        Display an awesome metasploit banner    <span class="token function">cd</span>            Change the current working directory    color         Toggle color    connect       Communicate with a host    <span class="token keyword">exit</span>          Exit the console    get           Gets the value of a context-specific variable    getg          Gets the value of a global variable    <span class="token function">grep</span>          Grep the output of another <span class="token function">command</span>    <span class="token function">help</span>          Help menu    <span class="token function">history</span>       Show <span class="token function">command</span> <span class="token function">history</span>    load          Load a framework plugin    quit          Exit the console    repeat        Repeat a list of commands    route         Route traffic through a session    save          Saves the active datastores    sessions      Dump session listings and display information about sessions    <span class="token keyword">set</span>           Sets a context-specific variable to a value    setg          Sets a global variable to a value    show          Displays modules of a given type, or all modules    <span class="token function">sleep</span>         Do nothing <span class="token keyword">for</span> the specified number of seconds    unload        Unload a framework plugin    unset         Unsets one or <span class="token function">more</span> context-specific variables    unsetg        Unsets one or <span class="token function">more</span> global variables    use           Selects a module by name    version       Show the framework and console library version numbers</code></pre><h4 id="Module-Commands"><a href="#Module-Commands" class="headerlink" title="Module Commands"></a><strong>Module Commands</strong></h4><pre class=" language-bash"><code class="language-bash">Module Commands<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span>Command           Description-------           -----------advanced          Displays advanced options <span class="token keyword">for</span> one or <span class="token function">more</span> modulesback              Move back from the current contextcreds             List all credentials <span class="token keyword">in</span> the databaseinfo              Displays information about one or <span class="token function">more</span> modulesload              Load a framework pluginoptions           Displays global options or <span class="token keyword">for</span> one or <span class="token function">more</span> modulespayload           Set the payload to usepenumbra          Alias <span class="token keyword">for</span> <span class="token string">"run post/windows/gather/enum_powershell_env"</span>precision         Alias <span class="token keyword">for</span> <span class="token string">"run post/multi/manage/shell_to_meterpreter"</span>previous          Sets the previously loaded module as the current modulereload            Reloads the modules from the databaseremove            Unloads a module from memoryrename_command    Rename a core <span class="token function">command</span>route             Route traffic through a sessionrun               Executes the loaded modulesave              Saves the active datastoressearch            Searches module names and descriptionsshow              Displays modules of a given type, or all modules<span class="token function">sleep</span>             Do nothing <span class="token keyword">for</span> the specified number of secondsuse               Selects a module by name</code></pre><h4 id="Job-Commands"><a href="#Job-Commands" class="headerlink" title="Job Commands"></a><strong>Job Commands</strong></h4><pre class=" language-bash"><code class="language-bash">Job Commands<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span>Command           Description-------           -----------<span class="token function">jobs</span>              Displays and manages background <span class="token function">jobs</span><span class="token function">kill</span>              Kill a jobrename_job        Rename a job</code></pre><h3 id="模块相关的命令-connect使用方法"><a href="#模块相关的命令-connect使用方法" class="headerlink" title="模块相关的命令 connect使用方法"></a>模块相关的命令 connect使用方法</h3><p>connect 命令主要用于远程连接主机。一般用于内网渗透；该命令允许你连接到目标主机并执行一些与连接相关的操作。</p><pre class=" language-bash"><code class="language-bash">msf <span class="token operator">></span> connect --helpUsage: connect <span class="token punctuation">[</span>options<span class="token punctuation">]</span> <span class="token operator">&lt;</span>host<span class="token operator">></span> <span class="token operator">&lt;</span>port<span class="token operator">></span>Communicate with a host, similar to interacting via netcat, taking advantage offramework features like SSL. For full-featured client interfaces see the <span class="token string">'sessions'</span>command.OPTIONS:  -c <span class="token operator">&lt;</span>opt<span class="token operator">></span>  Try to use <span class="token string">'opt'</span> character <span class="token keyword">for</span> EOL instead of $/  -i <span class="token operator">&lt;</span>opt<span class="token operator">></span>  The number of seconds to <span class="token function">wait</span> before interaction with the server  -p <span class="token operator">&lt;</span>opt<span class="token operator">></span>  The local port to listen on.  -s <span class="token operator">&lt;</span>opt<span class="token operator">></span>  SSL/TLS support: <span class="token string">'true'</span>, <span class="token string">'false'</span>, or <span class="token string">'sslv2'</span>  -t <span class="token operator">&lt;</span>opt<span class="token operator">></span>  The number of seconds to <span class="token function">wait</span> before disconnect  -v        Show verbose output</code></pre><h3 id="模块相关的命令-show-使用方法"><a href="#模块相关的命令-show-使用方法" class="headerlink" title="模块相关的命令 show 使用方法"></a>模块相关的命令 show 使用方法</h3><p>“show”命令的有效参数是: all,encoders,nops,exploits,payloads,auxiliary, postplugins, info, optionse</p><blockquote><p>show exploits    #列出 metasploit 框架中的所有渗透攻击模块。该命令列出数据较多，较为<strong>耗费时间</strong></p><p>msf6 &gt; show payloads    #列出metasploit 框架中的所有攻击载荷。</p><p>msf6 &gt; show auxiliary    #列出 metasploit 框架中的所有辅助攻击载荷。</p><p><strong>注：使用show命令会执行很慢</strong></p></blockquote><h3 id="模块相关的命令-search-使用方法"><a href="#模块相关的命令-search-使用方法" class="headerlink" title="模块相关的命令 search 使用方法"></a>模块相关的命令 search 使用方法</h3><p>search命令用于搜索与指定关键字相关的模块。该命令可以帮助你查找与你当前任务或目标相关的模块</p><pre><code>search keyword参数：关键字</code></pre><blockquote><p>metasploit 支持模糊查找，不区分大小写，这样大家查找时更方便</p></blockquote><h4 id="通过名字参数name进行查找"><a href="#通过名字参数name进行查找" class="headerlink" title="通过名字参数name进行查找"></a>通过名字参数name进行查找</h4><pre class=" language-bash"><code class="language-bash">msf <span class="token operator">></span> serach name：mysqlMatching Modules<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span>   <span class="token comment" spellcheck="true">#  Name                                         Disclosure Date  Rank    Check  Description</span>   -  ----                                         ---------------  ----    -----  -----------   1  auxiliary/admin/mysql/mysql_version                         normal  No     MySQL Server Version Enumeration   2  auxiliary/analyze/jtr_mysql_fast                           normal  No     John the Ripper MySQL Password Cracker <span class="token punctuation">(</span>Fast Mode<span class="token punctuation">)</span></code></pre><blockquote><p>#：编号    Name：名称  </p><p>Disclosure Date：披露日期    Rank：排名</p><p>check：检查    Description：说明</p></blockquote><h4 id="通过路径参数path进行查找"><a href="#通过路径参数path进行查找" class="headerlink" title="通过路径参数path进行查找"></a>通过路径参数path进行查找</h4><p>当我们只记得模块的路径，但是却忘记了模块的名称。那么就可以用 path: 命令查找在该路径下的所有模块</p><pre><code>search path:mysql</code></pre><h4 id="通过参数platform进行查找"><a href="#通过参数platform进行查找" class="headerlink" title="通过参数platform进行查找"></a>通过参数platform进行查找</h4><p>作用: Modules affecting this platform 即: 列出可以影响此平台的模块，也就是比较好的漏洞</p><p>有时候我们会搜索到大量的模块，那么可以用 platform: 命今来缩小查询范围。使用 platform 命令后，<strong>所查询的结果会列出 rank 比较高的模块</strong>。</p><pre><code>search platform:mysql</code></pre><h4 id="通过类型参数type进行查找"><a href="#通过类型参数type进行查找" class="headerlink" title="通过类型参数type进行查找"></a>通过类型参数type进行查找</h4><p>这里要使用到 type:命令。type:特定类型的模块(exploit, payload,auxiliary, encoder, evasion, post, or nop)</p><pre><code> search type:mysql</code></pre><h4 id="联合查找"><a href="#联合查找" class="headerlink" title="联合查找"></a>联合查找</h4><p>可以使用上面的参数自行搭配使用</p><pre><code>search name:mysql type:exploite</code></pre><h4 id="根据-CVE搜索exploit-相关模块"><a href="#根据-CVE搜索exploit-相关模块" class="headerlink" title="根据 CVE搜索exploit 相关模块"></a>根据 CVE搜索exploit 相关模块</h4><p>CVE概述:CVE 的英文全称是“Common Vulnerabilities &amp; Exposures”公共漏洞和暴露；<strong>CVE 就好像是一个字典表，为广泛认同的信息安全漏洞或者已经暴露出来的弱点给出一个公共的名称</strong>。使用一个共同的名字，可以帮助用户在各自独立的各种漏洞数据库中和漏洞评估工具中共享数据，虽然这些工具很难整合在一起。这样就使得 CVE 成为了安全信息共享的“关键字”。如果在一个漏洞报告中指明的一个漏洞，<strong>如果有 CVE 名称，你就可以快速地在任何其它 CVE 兼容的数据库中找到相应修补的信息解决安全问题</strong>。</p><h3 id="模块相关的命令-use-的使用方法"><a href="#模块相关的命令-use-的使用方法" class="headerlink" title="模块相关的命令 use 的使用方法"></a>模块相关的命令 use 的使用方法</h3><p>use 使用参数。如你要使用到某个模块，就要使用到 use 命令</p><pre class=" language-bash"><code class="language-bash">use 模块的名字msf6 <span class="token operator">></span> use auxiliary/scanner/portscan/tcpmsf6 auxiliary<span class="token punctuation">(</span>scanner/portscan/tcp<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token keyword">set</span> RHOSTS <span class="token operator">&lt;</span>目标主机<span class="token operator">></span>msf6 auxiliary<span class="token punctuation">(</span>scanner/portscan/tcp<span class="token punctuation">)</span> <span class="token operator">></span> run<span class="token punctuation">[</span>*<span class="token punctuation">]</span> TCP - 192.168.0.1:22 - Open<span class="token punctuation">[</span>*<span class="token punctuation">]</span> TCP - 192.168.0.1:80 - Open<span class="token punctuation">[</span>*<span class="token punctuation">]</span> TCP - 192.168.0.1:443 - Openmsf6 auxiliary<span class="token punctuation">(</span>scanner/portscan/tcp<span class="token punctuation">)</span> <span class="token operator">></span> use auxiliary/scanner/portscan/udpmsf6 auxiliary<span class="token punctuation">(</span>scanner/portscan/udp<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token keyword">set</span> RHOSTS <span class="token operator">&lt;</span>目标主机<span class="token operator">></span>msf6 auxiliary<span class="token punctuation">(</span>scanner/portscan/udp<span class="token punctuation">)</span> <span class="token operator">></span> run<span class="token punctuation">[</span>*<span class="token punctuation">]</span> UDP - 192.168.0.1:53 - Open</code></pre><pre class=" language-bash"><code class="language-bash">msf<span class="token operator">></span> back    <span class="token comment" spellcheck="true">#back 退出当前调用的模块</span><span class="token comment" spellcheck="true"># 注:不要使用exit，exit 会直接退出 Metasploit 程序</span></code></pre><h3 id="模块相关的命令-info-的使用方法"><a href="#模块相关的命令-info-的使用方法" class="headerlink" title="模块相关的命令 info 的使用方法"></a>模块相关的命令 info 的使用方法</h3><pre><code>info 模块名称use装载模块后直接使用infoshow option 查看设置的值</code></pre><h3 id="session命令"><a href="#session命令" class="headerlink" title="session命令"></a>session命令</h3><p>sessions命令用于管理与目标主机建立的会话。该命令允许你查看当前活动的会话列表、选择特定会话以进行操作，并提供一些选项用于管理会话。</p><pre><code>sessions [options] or sessions [id]</code></pre><h2 id="rank字段解释"><a href="#rank字段解释" class="headerlink" title="rank字段解释"></a>rank字段解释</h2><p>每一个漏洞利用模块基于它们对目标系统的潜在影响都被标记了一个 Rank 字段。用户可以基于 Rank 对漏洞利用模块进行搜索，分类以及排序。<br>Rank 按照可靠性降序排列:</p><ul><li><strong>excellent</strong>     漏洞利用程序绝对坏会使目标服务崩溃，就像 SQL 注入、命令执行、远程文件包含本地文件包含等等。除非有特殊情况，典型的内存破坏利用程序不可以被评估为该级别。</li><li><strong>great</strong>      该漏洞利用程序有一个默认的目标系统，并且可以自动检测适当的目标系统，或者在目标服务的版本检查之后可以返回到一个特定的返回地址。</li><li><strong>good</strong>      该漏洞利用程序有一个默认目标系统，并且是这种类型软件的“常见情况”(桌面应用程序的Windows 7，服务器的2012等)</li><li><strong>normal</strong>    该漏洞利用程序是可靠的，但是依赖于特定的版本，并且不能或者不能可靠地自动检测。</li><li><strong>average</strong>     该漏洞利用程序不可靠或者难以利用。</li><li><strong>low</strong>     对于通用的平台而言，该漏洞利用程序几乎不能利用 (或者低于 50% 的利用成功率)</li><li><strong>manual</strong>     该漏洞利用程序不稳定或者难以利用并且基于拒绝服务(DOS)。如果一个模块只有在用户特别配置该模块的时候才会被用到，否则该模块不会被使用到，那么也可以评为该等级</li></ul><h1 id="使用msf渗透攻击Win7主机并远程执行命令"><a href="#使用msf渗透攻击Win7主机并远程执行命令" class="headerlink" title="使用msf渗透攻击Win7主机并远程执行命令"></a>使用msf渗透攻击Win7主机并远程执行命令</h1><p><a href="https://docs.microsoft.com/zh-cn/security-updates/securitybulletins/2017/ms17-010" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/security-updates/securitybulletins/2017/ms17-010</a></p><p>永恒之蓝相关病毒，其实是利用了微软的 MS17-010 漏洞。MS17-010是Windows 系统一个底层服务的漏洞，恶意代码会扫描开放445 文件共享端口的 Windows机器，无需用户任何操作，只要开机上网，不法分子就能在电脑和服务器中植入勒索软件、远程控制木马、虚拟货币挖矿机等恶意程序。</p><blockquote><p>这里展示主要流程，具体践行过程就不展示了^_^    os：复现小累了哈哈哈</p></blockquote><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><pre class="mermaid">graph TB    已知漏洞MS17-010 --> 查找模块    查找模块 --> 配置程序    配置程序 --> exploit    exploit</pre><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><h3 id="查找模块"><a href="#查找模块" class="headerlink" title="查找模块"></a>查找模块</h3><ol><li>搜索exploit–</li><li>search MS17-010</li><li>show exploits</li><li>show payloads</li><li>show auxiliary</li></ol><h3 id="配置参数"><a href="#配置参数" class="headerlink" title="配置参数"></a>配置参数</h3><h4 id="显示参数"><a href="#显示参数" class="headerlink" title="显示参数"></a>显示参数</h4><ol><li>show options</li><li>show targets</li><li>show encoders</li><li>show advanced</li><li>info xxx</li></ol><h4 id="设置参数"><a href="#设置参数" class="headerlink" title="设置参数"></a>设置参数</h4><ol><li>use xxx (exploit)</li><li>set xxx (payload)</li><li>set xxx xxx (参数)</li></ol><h3 id="exploit"><a href="#exploit" class="headerlink" title="exploit"></a>exploit</h3><ol><li>执行exploit</li><li>exploit(命令)</li><li>run (命令)</li></ol><h2 id="总结使用metasploit攻击"><a href="#总结使用metasploit攻击" class="headerlink" title="总结使用metasploit攻击"></a>总结使用metasploit攻击</h2><ol><li>查找CVE公布的漏洞</li><li>查找对应的exploit 模块</li><li>配置模块参数</li><li>添加 payload 后门</li><li>执行exploit开始攻击</li></ol><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>Metasploit是一个强大的工具，但也需要谨慎使用。未经许可的渗透测试可能会触法，因此在使用Metasploit时，一定要确保你的行为是合法且得到了适当的授权。此外，Metasploit也需要不断更新，以应对新的威胁和漏洞。只有通过持续学习和实践，我们才能充分利用Metasploit的潜力，提高我们的网络安全水平。 </p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
            <tag> Metasploit </tag>
            
            <tag> 渗透测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NESSUS：网络安全的守护神</title>
      <link href="/shen-tou-nessus.html"/>
      <url>/shen-tou-nessus.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p> 在网络安全的领域中，漏洞扫描工具扮演着至关重要的角色。其中，NESSUS漏洞扫描工具以其全面和有效的扫描能力脱颖而出。本文将详细介绍NESSUS的基本功能和操作流程，以期帮助读者更好地理解和使用这款工具。 </p><h1 id="NESSUS简介"><a href="#NESSUS简介" class="headerlink" title="NESSUS简介"></a>NESSUS简介</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>1998年，Nessus 的创办人Renaud Deraison 展开了一项名为”Nessus”的计划，其计划目的是希望能为互联网社群提供一个免费、威力强大、更新频繁并简易使用的远端系统安全扫描程式。2002年时，Renaud与Ron Gula,Jack Huffard 创办了一个名为Tenable Network Security机构。在第三版的 Nessus释出之时，该机构收回了 Nessus 的版权与程式源代码 (原本为开放源代码)，并注册了nessus.org 成为该机构的网站。目前此机构位于美国马里兰州的哥伦比亚。</p><p>Nessus号称是世界上最流行的漏洞扫描程序，全世界有超过75000个组织在使用它。该工具提供完整的电脑漏洞扫描服务，并随时更新其漏洞数据库。Nessus不同于传统的漏洞扫描软件，Nessus可同时在本机或远端上遥控，进行系统的漏洞分析扫描。Nessus也是渗透测试重要工具之一。 </p><h2 id="ESSUS的功能："><a href="#ESSUS的功能：" class="headerlink" title="ESSUS的功能："></a>ESSUS的功能：</h2><p>NESSUS可以用来检测大范围的安全漏洞，这包括软件缺陷、配置错误、不安全的网络协议设置等等。不仅如此，NESSUS还可以根据已知的威胁模式进行主动的网络攻击模拟，以此评估网络的防护能力。</p><h2 id="NESSUS的工作原理："><a href="#NESSUS的工作原理：" class="headerlink" title="NESSUS的工作原理："></a>NESSUS的工作原理：</h2><p>NESSUS通过发起一系列的网络请求来探测目标系统或网络，然后根据收到的响应来判断可能存在的安全漏洞。在扫描过程中，NESSUS会尽可能地收集目标系统或网络的各类信息，以便更准确地判断其安全状况</p><h2 id="NESSUS的优势："><a href="#NESSUS的优势：" class="headerlink" title="NESSUS的优势："></a>NESSUS的优势：</h2><p>NESSUS的主要优势在于其高度灵活和全面。用户可以根据需要对NESSUS的扫描行为进行详细的定制，以适应不同的网络环境和安全需求。而且，NESSUS的扫描结果不仅包括详细的漏洞信息，还会给出修复建议，使得用户可以迅速地对安全问题进行修复。</p><h1 id="NESSUS的安装和配置"><a href="#NESSUS的安装和配置" class="headerlink" title="NESSUS的安装和配置"></a>NESSUS的安装和配置</h1><blockquote><p>此为Nessus Pro10.3.1最新破解版，此安装与配置借鉴，windows下安装包——详见：</p></blockquote><h2 id="windows下"><a href="#windows下" class="headerlink" title="windows下"></a>windows下</h2><ul><li><p>运行Nessus-10.3.1-x64.msi</p><ul><li>安装完成后会自动打开浏览器</li><li>在浏览器中<strong>managed scanner</strong>&gt;<strong>tenable.sc</strong>&gt;输入要注册的账户和密码</li></ul></li><li><p>运行_crack.bat （打开终端后需要回车确认，不要一直等着）</p></li><li><p>然后访问</p><p><a href="https://localhost:11123/" target="_blank" rel="noopener">https://localhost:11123/</a></p><ul><li>上述过程可能会需要较长时间，请耐心等待</li><li>插件编译完成后，就可以访问后台了</li></ul></li></ul><h2 id="linux下"><a href="#linux下" class="headerlink" title="linux下"></a>linux下</h2><p>创建Nessus_install_LINUX.sh文件，文件内容如下：</p><pre class=" language-sh"><code class="language-sh">bash Nessus_install_LINUX.sh    #运行脚本就可以自动完成下载安装包、插件包、破解等一系列的操作</code></pre><pre class=" language-sh"><code class="language-sh">#!/bin/bashif [[ $(id -u) -ne 0 ]] ; then echo "Please run as root" ; exit 1 ; fiecho //===============================================================echo //  Nessus 8.15.6 DOWNLOAD, INSTALL, and CRACK //echo //===============================================================echo  o making sure we have prerequisites..apt update &>/dev/nullapt -y install curl dpkg &>/dev/nullecho  o downloading Nessus..#curl -A Mozilla --request GET \#  --url 'https://www.tenable.com/downloads/api/v2/pages/nessus/files/Nessus-10.3.1-ubuntu1404_amd64.deb' \#  --output 'Nessus-10.3.1-ubuntu1404_amd64.deb' &>/dev/null# WORKS WITH 10.3.1 BUT THEY TOOK THAT VERSION DOWN, BOTH ARE CURRENT RELEASES.. same plugins.curl --request GET \  --url 'https://www.tenable.com/downloads/api/v2/pages/nessus/files/Nessus-8.15.6-ubuntu910_amd64.deb' \  --output 'Nessus-8.15.6-ubuntu910_amd64.deb' &>/dev/nullecho  o installing Nessus..#dpkg -i Nessus-10.3.1-ubuntu1404_amd64.deb &>/dev/null{ if [ ! -f Nessus-8.15.6-ubuntu910_amd64.deb ]; then  echo  o nessus download failed :/ exiting. get copy of it from t.me/pwn3rzs  exit 0fi }echo  o installing Nessus..dpkg -i Nessus-8.15.6-ubuntu910_amd64.deb &>/dev/nullecho  o starting service../bin/systemctl start nessusd.service &>/dev/nullechoecho ======================  STOP HERE  ===========================echo At this point you have to configure Nessus to work in managed mode,echo and you need to pick Nessus.SC from the selector list of options, echo then set a login/email and password.  Only after you have doneecho this and let the plugins load once can you continue.  Otherwiseecho IF you skip these manual steps THIS WILL NOT WORK.echo OPEN THIS URL AND CONFIGURE IT NOW https://127.0.01:8834/echo   1. PICK MANAGEDecho   2. PICK TENABLE.SCecho   3. SET A USER+PASSecho   4. LET IT SAVE SETTINGS AND START PROCESSING,echo   5. AFTER FEW SECONDS IT IS OK TO HIT ENTER HERE..echo ======================  STOP HERE  ===========================echo#xdg-open https://127.0.01:8834/      #sensible-browser https://127.0.01:8834/#x-www-browser https://127.0.01:8834/   #gnome-open https://127.0.01:8834/read -p "Press enter to continue"echo  o stopping the nessus service../bin/systemctl stop nessusd.service &>/dev/nullecho  o changing nessus port to 11127/opt/nessus/sbin/nessuscli fix --set xmlrpc_listen_port=11127 &>/dev/nullecho  o downloading new plugins..curl -A Mozilla -o all-2.0.tar.gz \  --url 'https://plugins.nessus.org/v2/nessus.php?f=all-2.0.tar.gz&u=4e2abfd83a40e2012ebf6537ade2f207&p=29a34e24fc12d3f5fdfbb1ae948972c6' &>/dev/null{ if [ ! -f all-2.0.tar.gz ]; then  echo  o plugins all-2.0.tar.gz download failed :/ exiting. get copy of it from t.me/pwn3rzs  exit 0fi }echo  o installing plugins../opt/nessus/sbin/nessuscli update all-2.0.tar.gz &>/dev/nullecho  o fetching version number..vernum=$(curl https://plugins.nessus.org/v2/plugins.php 2> /dev/null)echo  o building plugin feed last time this hack works..cat > /opt/nessus/var/nessus/plugin_feed_info.inc <<EOFPLUGIN_SET = "${vernum}";PLUGIN_FEED = "ProfessionalFeed (Direct)";PLUGIN_FEED_TRANSPORT = "Tenable Network Security Lightning";EOFechochattr -i /opt/nessus/lib/nessus/plugins/plugin_feed_info.inc &>/dev/nullcp /opt/nessus/var/nessus/plugin_feed_info.inc /opt/nessus/lib/nessus/plugins/plugin_feed_info.inc &>/dev/nullecho  o let\'s set everything immutable...chattr +i /opt/nessus/var/nessus/plugin_feed_info.inc &>/dev/nullchattr +i -R /opt/nessus/lib/nessus/plugins &>/dev/nullecho  o but unsetting key files..chattr -i /opt/nessus/lib/nessus/plugins/plugin_feed_info.inc &>/dev/nullchattr -i /opt/nessus/lib/nessus/plugins  &>/dev/nullecho  o starting service../bin/systemctl start nessusd.service &>/dev/nullecho  o Done!echoecho               Visit https://localhost:11127/echoread -p "Press enter to continue"</code></pre><p>之后操作步骤就和Windows几乎没有区别了</p><ul><li><p>然后访问</p><p><a href="https://localhost:11127/" target="_blank" rel="noopener">https://localhost:11127/</a></p><ul><li>在浏览器中<strong>managed scanner</strong>&gt;<strong>tenable.sc</strong>&gt;输入要注册的账户和密码</li><li>等待插件编译（需要较长时间）</li><li>然后登录就可以使用了</li></ul></li></ul><h1 id="NESSUS基本步骤"><a href="#NESSUS基本步骤" class="headerlink" title="NESSUS基本步骤"></a>NESSUS基本步骤</h1><ol><li><p><strong>安装与配置</strong>：首先需要在你的设备上安装 Nessus。安装过程根据操作系统的不同会有所不同。安装完成后，通过网页浏览器访问 Nessus 并完成初次配置，包括创建用户账号等。</p></li><li><p><strong>启动 Nessus</strong>：在你的设备上启动 Nessus 服务。你可以通过在终端输入 <code>systemctl start nessusd</code> 来启动服务。</p></li><li><p><strong>登录 Nessus</strong>：在网页浏览器中输入 Nessus 的地址（默认是 <a href="https://localhost:8834/）并使用在配置过程中创建的账号进行登录。" target="_blank" rel="noopener">https://localhost:8834/）并使用在配置过程中创建的账号进行登录。</a></p></li><li><p><strong>创建与配置扫描任务</strong>：在 Nessus 的界面中，点击左侧的 “New Scan” 按钮来创建一个新的扫描任务。你需要为任务设定目标（可以是 IP 地址或者域名）、扫描策略等信息。Nessus 提供了许多预设的扫描策略，如基本网络扫描、深度网络扫描、恶意软件扫描等。</p></li><li><p><strong>运行扫描任务</strong>：配置完成后，点击 “Save” 按钮保存任务，然后点击 “Launch” 按钮开始运行扫描任务。</p></li><li><p><strong>查看扫描结果</strong>：扫描完成后，点击左侧的 “Scans” 标签页，然后点击你刚刚运行的扫描任务，就可以查看扫描结果了。结果会按照危险等级进行分类，并对每个发现的漏洞进行详细的描述。</p></li><li><p><strong>修复漏洞</strong>：根据扫描结果，开始修复发现的漏洞。Nessus 的漏洞描述中通常会包含修复建议，可以作为解决问题的参考。</p></li></ol><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p> NESSUS是一款强大的漏洞扫描工具，对于任何关心网络安全的人来说，都是必不可少的。通过掌握NESSUS的使用，我们可以更有效地发现和管理网络中的漏洞，从而大大提升网络的安全性。尽管现在的网络环境日益复杂，但我们有理由相信，有了像NESSUS这样的工具，我们能够更好地面对网络安全的挑战。 </p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> 网络安全 </tag>
            
            <tag> 渗透测试 </tag>
            
            <tag> nessus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NMAP：揭秘网络安全的终极工具</title>
      <link href="/shen-tou-nmap.html"/>
      <url>/shen-tou-nmap.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在网络安全领域，无论是进行系统保护还是进行安全测试，网络扫描工具都扮演着重要角色。其中，NMAP是一个功能强大且广泛使用的网络扫描和安全审计工具。在本文中，我们将进一步探索NMAP的高级使用技巧，并深入研究如何使用NMAP进行漏洞扫描和发现。 </p><h1 id="NMAP概述"><a href="#NMAP概述" class="headerlink" title="NMAP概述"></a>NMAP概述</h1><p>nmap 是一个网络探测和安全扫描程序，系统管理者和个人可以使用这个软件扫描大型的网络，获取那台主机正在运行以及提供什么服务等信息。nmap 支持很多扫描技术，例如: UDP、TCPconnect0、TCP SYN(半开扫描)、ftp 代理(bounce 攻击)、反向标志、ICMP、FIN、ACK扫描、圣诞树(Xmas Tree)、SYN 扫描和 null扫描。还可以探测操作系统类型。</p><blockquote><p> 下载地址：<a href="https://www.iculture.cc/?golink=aHR0cHM6Ly9ubWFwLm9yZy8=" target="_blank" rel="noopener">https://nmap.org</a> </p></blockquote><h1 id="nmap应用"><a href="#nmap应用" class="headerlink" title="nmap应用"></a>nmap应用</h1><ul><li>检测活在网络上的主机(主机发现)</li><li>检测主机上开放的端口(端口发现或枚举)</li><li>检测到相应的端口(服务发现)的软件和版本</li><li>检测操作系统，硬件地址，以及软件版本</li><li>检测脆弱性的漏洞(Nmap的脚本)</li></ul><h1 id="NMAP端口状态解析"><a href="#NMAP端口状态解析" class="headerlink" title="NMAP端口状态解析"></a>NMAP端口状态解析</h1><p>端口扫描是Nmap最基本最核心的功能，用于确定目标主机的TCP/UDP端口的开放情况。</p><p><strong>open:</strong> 应用程序在该端口接收 TCP 连接或者 UDP 报文</p><p><strong>closed:</strong>关闭的端口对于 nmap 也是可访问的， 它接收nmap 探测报文并作出响应。但没有应用程序在其上监听</p><p><strong>filtered:</strong>由于包过滤阻止探测报文到达端口，nmap 无法确定该端口是否开放。过滤可能来自专业的防火墙设备，路由规则 或者主机上的软件防火墙。</p><p><strong>unfiltered:</strong>未被过滤状态意味着端口可访问，但是 nmap 无法确定它是开放还是关闭。 只有用于映射防火墙规则集的ACK 扫描才会把端口分类到这个状态。</p><p><strong>open| filtered :</strong>无法确定端口是开放还是被过滤， 开放的端口不响应就是一个例子。没有响应也可能意味着报文过滤器丢弃了探测报文或者它引发的任何反应。UDP，IP 协议,FIN,Null 等扫描会引起。</p><p><strong>closed| filtered:</strong>(关闭或者被过滤的): 无法确定端口是关闭的还是被过滤的。</p><h1 id="NMAP高级使用技巧"><a href="#NMAP高级使用技巧" class="headerlink" title="NMAP高级使用技巧"></a>NMAP高级使用技巧</h1><ol><li><p><strong>复杂的扫描技术</strong></p><p>NMAP的高级扫描技术如IP协议扫描和FTP bounce扫描为用户提供更多灵活性。IP协议扫描通过发送空的IP头来确定目标主机支持哪些IP协议。如果目标主机不发送ICMP不可达消息，则认为该协议是支持的。而FTP bounce扫描是一种欺骗性的扫描技术，通过发送特殊构造的FTP命令到脆弱的FTP服务器，使其代替NMAP连接目标主机的端口。</p></li><li><p><strong>灵活的输出选项</strong></p><p>NMAP允许用户以各种方式来输出扫描结果。使用”-oN”选项可以生成普通的可读文本文件，”-oX”选项则可以生成XML格式的输出，这种格式可以方便地被其他工具或程序进一步处理。如果需要同时输出多种格式，可以使用”-oA”选项。</p></li><li><p><strong>NMAP脚本扫描</strong></p><p>NMAP的脚本扫描功能是其最强大的工具之一，它通过NMAP脚本引擎 (NSE) 运行脚本。脚本扫描可以用来完成各种复杂的任务，包括但不限于高级版本检测、服务识别、安全审计和漏洞扫描。例如，使用”ssl-enum-ciphers”脚本可以列出目标主机支持的SSL密码套件，使用”smb-enum-shares”脚本则可以枚举SMB服务上的共享。</p></li></ol><h2 id="复杂的扫描技术"><a href="#复杂的扫描技术" class="headerlink" title="复杂的扫描技术"></a>复杂的扫描技术</h2><p>nmap支持很多扫描技术，例如:UDP、TCP connect().TCP SYN(半开扫描)、ftp代理(bounce攻击)、反向标志、ICMP、FIN、ACK扫描、圣诞树(Xmas Tree)、SYN扫描和null扫描。还可以探测操作系统类型。 </p><p><strong>1. 复杂的扫描技术</strong></p><p>当然，这里有一些基本和高级Nmap扫描的例子：</p><ol><li><p><strong>基本的TCP SYN扫描</strong>：<br><code>nmap -sS 192.168.1.1</code><br>这个命令将会对IP地址为192.168.1.1的主机进行TCP SYN扫描。</p></li><li><p><strong>UDP扫描</strong>：<br><code>nmap -sU 192.168.1.1</code><br>这个命令将会对192.168.1.1进行UDP扫描。</p></li><li><p><strong>版本探测</strong>：<br><code>nmap -sV 192.168.1.1</code><br>这个命令将会对192.168.1.1进行版本探测，尝试发现运行在开放端口上的服务的版本信息。</p></li><li><p><strong>操作系统探测</strong>：<br><code>nmap -O 192.168.1.1</code><br>这个命令将会尝试判断192.168.1.1的操作系统类型和版本。</p></li><li><p><strong>使用脚本的扫描</strong>：<br><code>nmap --script=http-title 192.168.1.1</code><br>这个命令将会运行http-title脚本，尝试获取192.168.1.1上运行的web服务的标题。</p></li><li><p><strong>复杂的扫描</strong>：<br><code>nmap -sS -sV -O -v 192.168.1.1</code><br>这个命令将会对192.168.1.1进行SYN扫描，并尝试进行版本探测和操作系统探测，同时输出详细的扫描过程信息。</p></li></ol><h2 id="灵活的输出选项"><a href="#灵活的输出选项" class="headerlink" title="灵活的输出选项"></a>灵活的输出选项</h2><p><strong>2. 灵活的输出选项</strong></p><ol><li><p><strong>标准输出</strong>：这是Nmap的默认输出选项。Nmap将会在控制台显示扫描结果，以人类可读的形式展现。</p><p>例如：<code>nmap -sS 192.168.1.1</code></p></li><li><p><strong>输出到文件</strong>：通过<code>-oN</code>选项，Nmap可以将扫描结果输出到一个文件，文件的格式与标准输出相同。</p><p>例如：<code>nmap -sS -oN output.txt 192.168.1.1</code></p></li><li><p><strong>XML输出</strong>：通过<code>-oX</code>选项，Nmap可以将扫描结果以XML格式输出到一个文件，这使得用户可以用其他工具对扫描结果进行进一步的处理和分析。</p><p>例如：<code>nmap -sS -oX output.xml 192.168.1.1</code></p></li><li><p><strong>grep输出</strong>：通过<code>-oG</code>选项，Nmap可以将扫描结果以grepable格式输出到一个文件，这使得用户可以用grep或其他文本处理工具对扫描结果进行过滤和分析。</p><p>例如：<code>nmap -sS -oG output.gnmap 192.168.1.1</code></p></li><li><p><strong>所有格式输出</strong>：通过<code>-oA</code>选项，Nmap可以将扫描结果以所有上述格式输出到不同的文件。</p><p>例如：<code>nmap -sS -oA output 192.168.1.1</code></p></li></ol><h2 id="NMAP脚本扫描"><a href="#NMAP脚本扫描" class="headerlink" title="NMAP脚本扫描"></a>NMAP脚本扫描</h2><p><strong>3. NMAP脚本扫描</strong></p><ul><li><p>Nmap脚本引擎(NSE)是Nmap中一个强大的功能，它可以使用Lua编写的脚本来执行各种复杂的网络任务，如高级版本检测、操作系统检测、漏洞检测等。</p><ol><li><p><strong>HTTP服务标题获取</strong>：http-title脚本会访问目标主机上的HTTP服务，并尝试获取和返回网页的标题。</p><p>例如：<code>nmap --script=http-title 192.168.1.1</code></p></li><li><p><strong>HTTP服务漏洞扫描</strong>：http-vuln-cve2014-3704脚本会检查目标主机上的Drupal CMS是否存在CVE-2014-3704漏洞。</p><p>例如：<code>nmap --script=http-vuln-cve2014-3704 192.168.1.1</code></p></li><li><p><strong>SSL心脏滴血漏洞检测</strong>：ssl-heartbleed脚本会检查目标主机的SSL服务是否存在心脏滴血漏洞。</p><p>例如：<code>nmap --script=ssl-heartbleed 192.168.1.1</code></p></li><li><p><strong>执行多个脚本</strong>：你可以一次执行多个脚本，只需要将它们用逗号分隔即可。</p><p>例如：<code>nmap --script=http-title,http-vuln-cve2014-3704 192.168.1.1</code></p></li><li><p><strong>执行脚本分类</strong>：Nmap的脚本被分为多个分类，如默认、安全、版本、发现等。你可以使用脚本的分类名来执行一组脚本。</p><p>例如：<code>nmap --script=default,safe 192.168.1.1</code></p></li><li><p><strong>使用ssl-enum-ciphers脚本</strong></p><p>要列出目标主机支持的SSL密码套件，可以使用”ssl-enum-ciphers”脚本。例如，检查目标主机192.168.1.1的443端口支持的密码套件：</p><p><code>nmap --script ssl-enum-ciphers -p 443 192.168.1.1</code></p></li><li><p><strong>使用smb-enum-shares脚本</strong></p><p>要枚举SMB服务上的共享，可以使用”smb-enum-shares”脚本。例如，枚举目标主机192.168.1.1的SMB共享：</p><p><code>nmap --script smb-enum-shares 192.168.1.1</code></p></li></ol></li></ul><h1 id="漏洞扫描示例"><a href="#漏洞扫描示例" class="headerlink" title="漏洞扫描示例"></a>漏洞扫描示例</h1><h2 id="CVE-2014-3704漏洞"><a href="#CVE-2014-3704漏洞" class="headerlink" title="CVE-2014-3704漏洞"></a>CVE-2014-3704漏洞</h2><ol><li><p><strong>使用http-vuln-cve2014-3704脚本扫描Drupal CMS的CVE-2014-3704漏洞</strong>：</p><p><code>nmap --script=http-vuln-cve2014-3704 192.168.1.1</code></p><pre class=" language-linux"><code class="language-linux">root@kali:~# nmap --script=http-vuln-cve2014-3704 192.168.1.1Starting Nmap ( https://nmap.org )Nmap scan report for 192.168.1.1Host is up (0.00050s latency).Not shown: 998 closed portsPORT   STATE SERVICE80/tcp open  http| http-vuln-cve2014-3704:|   VULNERABLE:|   Drupal HTTP Parameter Key/Value SQL Injection|     State: VULNERABLE|     IDs:  CVE:CVE-2014-3704|     Risk factor: High  CVSSv2: 7.5 (HIGH) (AV:N/AC:L/Au:N/C:P/I:P/A:P)|       Drupal 7.x versions prior to 7.32 are vulnerable to a SQL injection flaw in the expandArguments function of the database abstraction API.|           |     Disclosure date: 2014-10-15|     References:|       http://cvedetails.com/cve/2014-3704/|       https://www.sektioneins.de/en/blog/14-10-15-drupal-sql-injection-vulnerability.html|_      https://www.drupal.org/SA-CORE-2014-005MAC Address: 08:00:27:53:8B:CC (Oracle VirtualBox virtual NIC)Nmap done: 1 IP address (1 host up) scanned in 7.60 seconds</code></pre></li></ol><h2 id="心脏滴血漏洞"><a href="#心脏滴血漏洞" class="headerlink" title="心脏滴血漏洞"></a>心脏滴血漏洞</h2><ol><li><p><strong>使用ssl-heartbleed脚本扫描SSL服务的心脏滴血漏洞</strong>：</p><p><code>nmap --script=ssl-heartbleed 192.168.1.1</code></p><pre><code>root@kali:~# nmap --script=ssl-heartbleed 192.168.1.1Starting Nmap ( https://nmap.org )Nmap scan report for 192.168.1.1Host is up (0.00051s latency).Not shown: 998 closed portsPORT    STATE SERVICE443/tcp open  https| ssl-heartbleed:|   VULNERABLE:|   The Heartbleed Bug is a serious vulnerability in the popular OpenSSL cryptographic software library. This weakness allows stealing the information protected, under normal conditions, by the SSL/TLS encryption used to secure the Internet|     State: VULNERABLE|     Risk factor: High|       OpenSSL versions 1.0.1 through 1.0.1f (inclusive) are vulnerable|           |     References:|       https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-0160|       http://www.openssl.org/news/secadv_20140407.txt|_      https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-0160MAC Address: 08:00:27:53:8B:CC (Oracle VirtualBox virtual NIC)Nmap done: 1 IP address (1 host up) scanned in 7.70 seconds</code></pre></li></ol><h2 id="MS17-010-永恒之蓝-漏洞"><a href="#MS17-010-永恒之蓝-漏洞" class="headerlink" title="MS17-010(永恒之蓝)漏洞"></a>MS17-010(永恒之蓝)漏洞</h2><ol><li><p><strong>使用smb-vuln-ms17-010脚本扫描SMB服务的MS17-010(永恒之蓝)漏洞</strong>：</p><p><code>nmap --script=smb-vuln-ms17-010 192.168.1.1</code></p><pre><code>root@kali:~# nmap --script=smb-vuln-ms17-010 192.168.1.1Starting Nmap ( https://nmap.org )Nmap scan report for 192.168.1.1Host is up (0.00051s latency).Not shown: 998 closed portsPORT    STATE SERVICE445/tcp open  microsoft-ds| smb-vuln-ms17-010: |   VULNERABLE:|   Remote Code Execution vulnerability in Microsoft SMBv1 servers (ms17-010)|     State: VULNERABLE|     IDs:  CVE:CVE-2017-0143|     Risk factor: HIGH|       A critical remote code execution vulnerability exists in Microsoft SMBv1|        servers (ms17-010).|           |     References:|       https://technet.microsoft.com/en-us/library/security/ms17-010.aspx|       https://blogs.technet.microsoft.com/msrc/2017/05/12/customer-guidance-for-wannacrypt-attacks/|_      https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-0143Nmap done: 1 IP address (1 host up) scanned in 7.70 seconds</code></pre></li></ol><h1 id="DNMAP集群简介"><a href="#DNMAP集群简介" class="headerlink" title="DNMAP集群简介"></a>DNMAP集群简介</h1><p>dnmap 是一个用 python 写的进行分布式扫描的nmap 扫描框架，我们可以用dnmap 来通过多个台机器发起一个大规模的扫描，dnmap 采用 C/S 结构，<strong>执行大量扫描任务时非常便捷，扫描结果可以统一管理</strong>。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>使用dnmap进行大规模的网络扫描，你需要设置一个dnmap服务器，这将作为所有扫描任务的中心。然后，在每个要参与扫描的客户端系统上安装dnmap客户端。在这种设置中，服务器发送扫描命令给所有的客户端，然后收集并管理扫描结果。</p><ol><li>在服务器上安装并设置dnmap：</li></ol><pre class=" language-bash"><code class="language-bash"><span class="token function">apt-get</span> <span class="token function">install</span> dnmap<span class="token function">mkdir</span> /var/dnmap_server/dnmap_server -f -l /var/dnmap_server/dnmap.log -w /var/dnmap_server/dnmap.output</code></pre><p><code>-f</code>标志表示dnmap服务器将运行在前台模式，<code>-l</code>标志指定日志文件的位置，<code>-w</code>标志指定扫描结果的输出文件。</p><ol start="2"><li>在每个客户端系统上安装并运行dnmap客户端：</li></ol><pre class=" language-bash"><code class="language-bash"><span class="token function">apt-get</span> <span class="token function">install</span> dnmapdnmap_client -s server_ip</code></pre><p><code>-s</code>标志后面跟着的是dnmap服务器的IP地址。</p><ol start="3"><li>在服务器上，通过添加扫描命令到dnmap文件中来开始一个新的扫描任务：</li></ol><pre class=" language-bash"><code class="language-bash"><span class="token keyword">echo</span> <span class="token string">"nmap -Pn -p 80 -oX - 10.0.0.0/8"</span> <span class="token operator">></span> /var/dnmap_server/dnmap.commands</code></pre><p>在这个示例中，服务器将扫描10.0.0.0/8网络的所有主机的80端口，并将结果以XML格式输出。</p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>通过本文的深入探讨，我们可以看到NMAP作为一个强大的网络扫描和安全审计工具的价值。从基本的网络扫描到高级的扫描技术，再到漏洞扫描和发现，NMAP都能为我们提供强大的支持。了解并熟练掌握NMAP的使用，无疑会在网络安全领域中大大提高我们的工作效率和准确性。同时，也要时刻提醒自己，任何强大的工具都应在法律和道德的框架内使用，保护网络安全，也是保护我们自己。 </p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> 网络安全 </tag>
            
            <tag> 渗透测试 </tag>
            
            <tag> nmap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WireShark 简介和抓包原理及过程</title>
      <link href="/shen-tou-wireshark-zhua-bao-ji-chang-yong-xie-yi-fen-xi.html"/>
      <url>/shen-tou-wireshark-zhua-bao-ji-chang-yong-xie-yi-fen-xi.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="引言："><a href="#引言：" class="headerlink" title="引言："></a>引言：</h1><p>在我们日常的网络生活中，电子邮件、网页浏览、在线视频，每一个操作背后都是网络通信的默默工作。网络通信的基础是一系列复杂的协议，而理解这些协议的工作方式可以帮助我们更好地理解网络的运作。WireShark，一个强大的网络协议分析工具，使我们能够深入了解这些协议的内部运作，从而帮助我们解决网络问题。</p><h1 id="WireShark-简介和抓包原理及过程"><a href="#WireShark-简介和抓包原理及过程" class="headerlink" title="WireShark 简介和抓包原理及过程"></a>WireShark 简介和抓包原理及过程</h1><h2 id="WireShark-简介"><a href="#WireShark-简介" class="headerlink" title="WireShark 简介"></a>WireShark 简介</h2><p>Wireshark 是一个网络封包分析软件。网络封包分析软件的功能是损取网络封包，并尽可能显示出最为详细的网络封包资料。Wireshark 使用 WinPCAP 作为接口，直接与网卡进行数据报文交换。</p><h2 id="WireShark的应用"><a href="#WireShark的应用" class="headerlink" title="WireShark的应用"></a>WireShark的应用</h2><p>WireShark是一款功能强大的网络协议分析工具，其应用场景广泛。在网络故障排查方面，WireShark能够帮助我们通过分析网络流量，查看数据包来定位问题的原因。同时，它也可以被用于网络性能优化，通过对网络中数据流的分析，我们可以找出网络瓶颈并进行针对性优化。在网络安全领域，WireShark可以助力发现和定位网络中的安全问题。此外，对于学习和研究网络协议以及开发和测试新的网络协议，WireShark都是一个非常有价值的工具，使我们能够深入理解协议的运行细节，或观察新协议的实际行为。</p><p>开发者使用 Wireshark 来为新的通讯协议除错，普通使用者使用 Wireshark 来学习网络协议的相关知识。当然，有的人也会“居心叵测”的用它来寻找一些敏感信息……</p><h2 id="WireShark-快速分析数据包技巧"><a href="#WireShark-快速分析数据包技巧" class="headerlink" title="WireShark 快速分析数据包技巧"></a>WireShark 快速分析数据包技巧</h2><p>(1)确定Wireshark 的物理位置。如果没有一个正确的位置，启动 Wireshark 后会花费很长的时间捕获一些与自己无关的数据。</p><p>(2) 选择捕获接口。一般都是选择连接到lnternet 网络的接口，这样才可以捕获到与网络相关的数据。否则，捕获到的其它数据对自己也没有任何帮助。</p><p>(3) 使用捕获过滤器。通过设置捕获过滤器，可以避免产生过大的捕获数据。这样用户在分析数据时，也不会受其它数据干扰。而且，还可以为用户节约大量的时间。</p><p>(4) 使用显示过滤器。通常使用捕获过滤器过滤后的数据，往往还是很复杂。为了使过滤的数据包再更细致，此时使用显示过滤器进行过滤。</p><p>(5) 使用着色规则。通常使用显示过滤器过滤后的数据，都是有用的数据包。如果想更加突出的显示某个会话，可以使用着色规则高亮显示。</p><p>(6) 构建图表。如果用户想要更明显的看出一个网络中数据的变化情况，使用图表的形式可以很方便的展现数据分布情况。</p><p>(7) 重组数据。当传输较大的图片或文件时，需要将信息分布在多个数据包中。这时候就需要使用重组数据的方法来抓取完整的数据。Wireshark 的重组功能，可以重组一个会话中不同数据包的信息，或者是重组一个完整的图片或文件。</p><h2 id="WireShark界面"><a href="#WireShark界面" class="headerlink" title="WireShark界面"></a>WireShark界面</h2><img src="https://cdn.jsdelivr.net/gh/Bevis23/blog-pic/wireshark%E7%95%8C%E9%9D%A2.png" alt="wireshark界面" style="zoom:50%;"><h2 id="WireShark过滤器语法"><a href="#WireShark过滤器语法" class="headerlink" title="WireShark过滤器语法"></a>WireShark过滤器语法</h2><ol><li><p><strong>协议类型</strong>：你可以直接输入协议名称，如 “http”、”dns” 或 “tcp”，WireShark会过滤出所有该类型的数据包。</p></li><li><p><strong>源和目标IP地址</strong>：你可以使用 “ip.src == x.x.x.x” 和 “ip.dst == y.y.y.y” 来过滤出特定IP地址的数据包。这里的x.x.x.x和y.y.y.y需要替换为实际的IP地址。</p></li><li><p><strong>源和目标端口</strong>：你可以使用 “tcp.srcport == 80” 和 “tcp.dstport == 80” 来过滤出特定端口的TCP数据包。</p></li><li><p><strong>逻辑操作符</strong>：你可以使用逻辑操作符 “&amp;&amp;”（与）、”||”（或） 和 “!”（非）来组合过滤器。例如， “http &amp;&amp; ip.src == x.x.x.x” 会过滤出所有从特定IP地址发送的HTTP数据包。</p></li><li><p><strong>内容搜索</strong>：你可以使用 “contains” 和 “matches” 操作符来搜索数据包的内容。例如， “http contains ‘OpenAI’” 会过滤出所有HTTP数据包中包含’OpenAI’字符串的数据包。</p></li></ol><blockquote><p>注意，WireShark的过滤器语法区分大小写，你需要确保所有的协议名、字段名和操作符都是小写。这只是WireShark过滤器语法的基础，实际上，它的功能远不止这些。你可以参考WireShark的官方文档来了解更多的过滤器语法和使用方法。</p></blockquote><h2 id="常用协议分析"><a href="#常用协议分析" class="headerlink" title="常用协议分析"></a>常用协议分析</h2><p>A. HTTP协议分析：通过WireShark, 监控到每一个HTTP请求及其响应，包括请求方法、URL、状态码、请求和响应头部信息等。这对于理解如何优化网页加载速度，或识别可能的安全风险都非常有帮助。例如，我们可以查看服务器返回的HTTP头部中的缓存控制字段，来了解网页内容是如何被缓存的，以此来优化网页加载速度。</p><p>B. DNS协议分析：WireShark能跟踪DNS查询以及其响应，了解域名解析的全过程。例如，如果一个网站加载缓慢，那可能是因为DNS查询时间过长。通过WireShark，我们可以找到问题并优化它。</p><p>C. TCP/IP协议分析：TCP/IP协议是互联网的基石，理解和分析它们对于网络故障排查和性能优化至关重要。使用WireShark，可以看到每个TCP/IP数据包的详细信息，包括源/目标IP地址、端口号、序列号、确认号以及控制标志等。例如，我们可以通过分析TCP重传和丢包来识别网络问题，通过观察TCP窗口大小的变化来了解网络拥塞状况。</p><h1 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h1><p>WireShark作为一款强大的网络分析工具，其在帮助我们理解网络协议，解决网络问题，以及进行网络性能优化方面发挥了巨大的作用。同时，随着网络技术的日益发展，我们相信WireShark在未来将有更多的应用场景和更深远的影响。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> 网络安全 </tag>
            
            <tag> wireshark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python编程：深入理解列表与元组的关键差异</title>
      <link href="/bian-cheng-python-yuan-zu-yu-lie-biao.html"/>
      <url>/bian-cheng-python-yuan-zu-yu-lie-biao.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="引言："><a href="#引言：" class="headerlink" title="引言："></a>引言：</h2><p>在Python编程中，我们经常会使用到的两种基础数据结构就是列表（List）和元组（Tuple）。这两者都用于存储数据集合，但它们之间存在着一些关键的差异。理解这些差异以及何时使用哪种数据结构是成为一名高效的Python程序员的关键。在这篇博客中，我们将深入探讨列表和元组的主要特性和用途，并通过实例来更好地理解这些概念。</p><h2 id="差异"><a href="#差异" class="headerlink" title="差异"></a>差异</h2><p>我们已经有了列表这种数据结构，为什么还需要元组这样的类型呢？ </p><p>列表（list）和元组（tuple）是Python中两种常用的序列数据类型。虽然它们在许多方面都很相似，但也有一些重要的差异：</p><ol><li><strong>不变性</strong>：列表是可变的，这意味着你可以改变一个列表的元素或长度。而元组是不可变的，一旦创建，就不能改变。</li><li><strong>性能</strong>：由于元组是不可变的，所以它们通常比列表更加高效。如果你有一个不需要改变的序列，使用元组比使用列表更好。</li><li><strong>安全性</strong>：元组的不变性使得它们可以作为字典的键，而列表不可以。此外，如果你要传递一个序列，并且不希望接收者改变这个序列，你应该使用元组。</li><li><strong>语义</strong>：元组常常用于包含不同类型的元素，例如元组可能包含一个姓名和一个年龄。而列表通常用于包含多个相同类型的元素，例如一个整数列表或一个字符串列表。</li><li><strong>内存使用</strong>：元组通常比列表占用更少的内存。因为元组是不可变的，Python在创建元组时可以更精确地分配内存，而列表由于其可变性，必须分配额外的内存来处理可能的增长，这导致列表占用的内存通常更多。</li><li><strong>函数和方法</strong>：元组和列表都有一些内置的函数和方法，例如len()函数可以返回元组或列表的长度，append()方法（只适用于列表）可以在列表的末尾添加一个新元素，等等。</li><li><strong>可哈希性</strong>：由于元组的不可变性，它们是可哈希的，这意味着你可以使用元组作为字典的键或将它们添加到集合中。而由于列表是可变的，它们不是可哈希的，所以你不能使用列表作为字典的键或将它们添加到集合中。</li></ol><h2 id="体现"><a href="#体现" class="headerlink" title="体现"></a>体现</h2><h3 id="不变性："><a href="#不变性：" class="headerlink" title="不变性："></a><strong>不变性</strong>：</h3><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 列表是可变的</span>list_example <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">]</span>list_example<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'d'</span>  <span class="token comment" spellcheck="true"># 改变列表的一个元素</span><span class="token keyword">print</span><span class="token punctuation">(</span>list_example<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 输出：['a', 'd', 'c']</span><span class="token comment" spellcheck="true"># 元组是不可变的</span>tuple_example <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">)</span><span class="token keyword">try</span><span class="token punctuation">:</span>    tuple_example<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'d'</span>  <span class="token comment" spellcheck="true"># 尝试改变元组的一个元素，会抛出异常</span><span class="token keyword">except</span> TypeError<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Cannot modify a tuple'</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 输出：Cannot modify a tuple</span></code></pre><h3 id="性能："><a href="#性能：" class="headerlink" title="性能："></a><strong>性能</strong>：</h3><p>元组的存储效率更高，创建和访问速度也更快。下面是一个使用Python的<code>timeit</code>模块比较列表和元组创建时间的例子：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> timeit<span class="token keyword">print</span><span class="token punctuation">(</span>timeit<span class="token punctuation">.</span>timeit<span class="token punctuation">(</span><span class="token string">'x = (1,2,3,4,5,6)'</span><span class="token punctuation">,</span> number<span class="token operator">=</span><span class="token number">1000000</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 创建元组的时间</span><span class="token keyword">print</span><span class="token punctuation">(</span>timeit<span class="token punctuation">.</span>timeit<span class="token punctuation">(</span><span class="token string">'x = [1,2,3,4,5,6]'</span><span class="token punctuation">,</span> number<span class="token operator">=</span><span class="token number">1000000</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 创建列表的时间</span></code></pre><h3 id="安全性："><a href="#安全性：" class="headerlink" title="安全性："></a><strong>安全性</strong>：</h3><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 元组可以作为字典的键</span>dictionary <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token string">'c'</span><span class="token punctuation">}</span><span class="token keyword">print</span><span class="token punctuation">(</span>dictionary<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 输出：'c'</span><span class="token comment" spellcheck="true"># 列表不能作为字典的键</span><span class="token keyword">try</span><span class="token punctuation">:</span>    dictionary <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token string">'c'</span><span class="token punctuation">}</span><span class="token keyword">except</span> TypeError<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Cannot use a list as a dictionary key'</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 输出：Cannot use a list as a dictionary key</span></code></pre><h3 id="语义："><a href="#语义：" class="headerlink" title="语义："></a><strong>语义</strong>：</h3><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 元组包含不同类型的元素</span>person <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">'Alice'</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 元组包含一个姓名和一个年龄</span><span class="token comment" spellcheck="true"># 列表包含相同类型的元素</span>ages <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">35</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true"># 列表包含多个年龄</span></code></pre><h3 id="内存使用："><a href="#内存使用：" class="headerlink" title="内存使用："></a><strong>内存使用</strong>：</h3><p>使用Python的<code>sys</code>模块来查看对象占用的内存大小：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> syslist_example <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span>tuple_example <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>sys<span class="token punctuation">.</span>getsizeof<span class="token punctuation">(</span>list_example<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 输出：96</span><span class="token keyword">print</span><span class="token punctuation">(</span>sys<span class="token punctuation">.</span>getsizeof<span class="token punctuation">(</span>tuple_example<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 输出：80</span></code></pre><h3 id="函数和方法："><a href="#函数和方法：" class="headerlink" title="函数和方法："></a><strong>函数和方法</strong>：</h3><pre class=" language-python"><code class="language-python">list_example <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span>len<span class="token punctuation">(</span>list_example<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 输出：5</span>list_example<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>list_example<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 输出：[1, 2, 3, 4, 5, 6]</span>tuple_example <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>len<span class="token punctuation">(</span>tuple_example<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 输出：5 append()方法（只适用于列表）</span></code></pre><h3 id="可哈希性："><a href="#可哈希性：" class="headerlink" title="可哈希性："></a><strong>可哈希性</strong>：</h3><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 元组可以作为字典的键</span>dictionary <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token string">'a'</span><span class="token punctuation">}</span><span class="token keyword">print</span><span class="token punctuation">(</span>dictionary<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 输出：'a'</span><span class="token comment" spellcheck="true"># 列表不能作为字典的键</span><span class="token keyword">try</span><span class="token punctuation">:</span>    dictionary <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token string">'a'</span><span class="token punctuation">}</span><span class="token keyword">except</span> TypeError<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Cannot use a list as a dictionary key'</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 输出：Cannot use a list as a dictionary key</span></code></pre><h2 id="结语："><a href="#结语：" class="headerlink" title="结语："></a>结语：</h2><p>通过上述讨论和示例，我们了解了列表和元组的关键区别，包括其可变性、性能、内存使用、嵌套和可哈希性等特性。尽管列表和元组在很多方面都很相似，但是这些差异使得它们在特定的应用场景中具有各自的优势。在编写Python代码时，应根据实际需求选择使用列表还是元组。</p><p>最后的最后： 人生苦短 我用python ^_^</p><pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> thisThe Zen of Python<span class="token punctuation">,</span> by Tim PetersBeautiful <span class="token keyword">is</span> better than ugly<span class="token punctuation">.</span>Explicit <span class="token keyword">is</span> better than implicit<span class="token punctuation">.</span>Simple <span class="token keyword">is</span> better than complex<span class="token punctuation">.</span>Complex <span class="token keyword">is</span> better than complicated<span class="token punctuation">.</span>Flat <span class="token keyword">is</span> better than nested<span class="token punctuation">.</span>Sparse <span class="token keyword">is</span> better than dense<span class="token punctuation">.</span>Readability counts<span class="token punctuation">.</span>Special cases aren't special enough to <span class="token keyword">break</span> the rules<span class="token punctuation">.</span>Although practicality beats purity<span class="token punctuation">.</span>Errors should never <span class="token keyword">pass</span> silently<span class="token punctuation">.</span>Unless explicitly silenced<span class="token punctuation">.</span>In the face of ambiguity<span class="token punctuation">,</span> refuse the temptation to guess<span class="token punctuation">.</span>There should be one<span class="token operator">-</span><span class="token operator">-</span> <span class="token operator">and</span> preferably only one <span class="token operator">-</span><span class="token operator">-</span>obvious way to do it<span class="token punctuation">.</span>Although that way may <span class="token operator">not</span> be obvious at first unless you're Dutch<span class="token punctuation">.</span>Now <span class="token keyword">is</span> better than never<span class="token punctuation">.</span>Although never <span class="token keyword">is</span> often better than <span class="token operator">*</span>right<span class="token operator">*</span> now<span class="token punctuation">.</span>If the implementation <span class="token keyword">is</span> hard to explain<span class="token punctuation">,</span> it's a bad idea<span class="token punctuation">.</span>If the implementation <span class="token keyword">is</span> easy to explain<span class="token punctuation">,</span> it may be a good idea<span class="token punctuation">.</span>Namespaces are one honking great idea <span class="token operator">-</span><span class="token operator">-</span> let's do more of those!</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>渗透-被动信息收集</title>
      <link href="/shen-tou-bei-dong-xin-xi-shou-ji.html"/>
      <url>/shen-tou-bei-dong-xin-xi-shou-ji.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="被动信息收集"><a href="#被动信息收集" class="headerlink" title="被动信息收集"></a>被动信息收集</h1><h2 id="被动信息收集-1"><a href="#被动信息收集-1" class="headerlink" title="被动信息收集"></a>被动信息收集</h2><p>指在不直接与目标交互或者不打扰目标的情况下获取信息的一种方式。与主动信息收集（比如问卷调查或面试）相比，被动信息收集更依赖于现有的公开信息资源，或者通过监听和观察来获取信息。 </p><h2 id="被动信息收集的内容"><a href="#被动信息收集的内容" class="headerlink" title="被动信息收集的内容"></a>被动信息收集的内容</h2><ol><li>公开信息：例如新闻报告、社交媒体发帖、公开数据库或报告。</li><li>网络行为数据：如浏览记录、购物习惯、搜索历史等。</li><li>环境数据：例如，通过使用各种传感器收集的环境或行为数据。</li><li>元数据：例如，邮件通信的时间戳和发件人/收件人信息，不包括邮件内容本身。</li></ol><h2 id="信息用途"><a href="#信息用途" class="headerlink" title="信息用途"></a>信息用途</h2><ol><li>市场研究：企业可能会收集潜在客户的信息，以更好地理解他们的需求和行为，然后优化产品或服务。</li><li>竞争情报：企业也可能会收集关于竞争对手的信息，以便在战略决策中获取优势。</li><li>个性化推荐：互联网公司常常使用用户的浏览历史和购物行为来推荐相关的产品或服务。</li><li>安全和防御：政府或安全机构可能会收集公开的信息，以识别和防止可能的威胁。</li><li>科研：学者和研究人员可能会收集公开数据来进行科学研究，例如社会学研究、公共卫生研究等。</li><li>广告定向：通过分析用户的网络行为数据，可以推送更精准的广告，提高广告效益。</li></ol><h1 id="信息收集-DNS"><a href="#信息收集-DNS" class="headerlink" title="信息收集-DNS"></a>信息收集-DNS</h1><h2 id="DNS-服务器概述"><a href="#DNS-服务器概述" class="headerlink" title="DNS 服务器概述:"></a>DNS 服务器概述:</h2><p>运行 DNS 服务器程序的计算机，储存 DNS 数据库信息。DNS 服务器分为根域 DNS 服务器、顶级域名DNS 服务器。[根域DNS 服务器有 13个，都存储了全部的顶级域名服务器的所在地址;顶级域名服务器存储了每位客户所注册的主机地址，这里对应到 163.com这个级别。</p><h2 id="域名记录"><a href="#域名记录" class="headerlink" title="域名记录"></a>域名记录</h2><ol><li>A 记录：用于将域名映射到对应的 IPv4 地址。</li><li>AAAA 记录：用于将域名映射到对应的 IPv6 地址。</li><li>CNAME 记录：将一个域名映射到另一个域名，也称为别名。</li><li>MX 记录：定义用于处理特定域名的邮件的邮件服务器。</li><li>NS 记录：用于指定负责特定域名的 DNS 服务器。</li><li>TXT 记录：可以包含任何文本，经常用于验证域名所有权，或为 SPF（Sender Policy Framework，发送方策略框架）提供信息，这是一种防止垃圾邮件的技术。</li><li>SRV 记录：提供特定服务的服务器的信息。</li><li>SOA 记录：在 DNS 区域中的每个域名服务器上都有一个 SOA 记录，它包含关于 DNS 区域的元数据，如负责区域的主 DNS 服务器和联系邮箱等。</li></ol><h2 id="DNS缓存服务器"><a href="#DNS缓存服务器" class="headerlink" title="DNS缓存服务器"></a>DNS缓存服务器</h2><p>缓存DNS 服务器:不负责解析域，只是缓存域名解析结果。一般来说 DNS 缓存服务器是最接近客户的一个服务器，当有客户机需要访问某个网址时就会访问该服务器，DNS 缓存服务器则去查询根域-&gt;顶级域名-&gt;WEB 提供商的域名服务器DNS 缓存服务器得到具体主机记录时，将该记录缓存在本地缓存中存放一定的时间，当该缓存未被丢弃时，有客户机访问对应网址，则由 DNS 缓存服务器直接返回相应主机记录。</p><h2 id="DNS信息收集"><a href="#DNS信息收集" class="headerlink" title="DNS信息收集"></a>DNS信息收集</h2><h3 id="nslookup"><a href="#nslookup" class="headerlink" title="nslookup"></a>nslookup</h3><p><code>nslookup</code> 是一个网络管理命令行工具，它用于查询 DNS（域名系统）以获取域名或 IP 地址映射，或者其他 DNS 记录。它是大多数操作系统（如 Windows，macOS，Linux）中的标准工具。</p><p>下面是使用 <code>nslookup</code> 的一些基本用法：</p><ol><li><strong>查询域名的 IP 地址</strong>：只需在命令行中输入 <code>nslookup</code>，后面跟上你想查询的域名。例如：</li></ol><pre><code>nslookup www.example.com</code></pre><p>这将返回该域名对应的 IP 地址。</p><ol start="2"><li><strong>查询特定 DNS 记录</strong>：你可以使用 <code>-query</code> 选项查询特定类型的 DNS 记录。例如，要查询一个域的 MX 记录（邮件交换记录），你可以输入：</li></ol><pre><code>nslookup -query=mx example.com</code></pre><p>这将返回处理该域名邮件的邮件服务器。</p><ol start="3"><li><strong>查询特定 DNS 服务器</strong>：你还可以指定一个特定的 DNS 服务器来查询。例如，要使用 Google 的公共 DNS 服务器查询一个域名，可以输入：</li></ol><pre><code>nslookup example.com 8.8.8.8</code></pre><p>其中，8.8.8.8 是 Google 公共 DNS 的 IP 地址。</p><h3 id="dig"><a href="#dig" class="headerlink" title="dig"></a>dig</h3><p><code>dig</code>（域信息搜寻器）是一个强大而灵活的命令行工具，主要用于查询 DNS 名称服务器。它可以用于获取各种类型的 DNS 记录，包括 A 记录，MX 记录，CNAME 记录等。它是 Unix 和 Linux 系统中的一个常见工具，但也可以在其他系统如 Windows 和 macOS 上安装。</p><p>以下是 <code>dig</code> 的一些基本用法：</p><ol><li><p><strong>查询 A 记录</strong>：要查询一个域名的 A 记录（也就是该域名的 IP 地址），你只需在命令行中输入 <code>dig</code>，后面跟上你想查询的域名。例如：</p><pre><code>dig www.example.com</code></pre><p>默认情况下，<code>dig</code> 查询的就是 A 记录。</p></li><li><p><strong>查询其他类型的记录</strong>：你可以通过在 <code>dig</code> 后面加上记录类型来查询其他类型的 DNS 记录。例如，要查询一个域名的 MX 记录，你可以输入：</p><pre><code>dig MX example.com</code></pre></li><li><p><strong>查询特定 DNS 服务器</strong>：你还可以指定一个特定的 DNS 服务器进行查询。例如，要使用 Google 的公共 DNS 服务器查询一个域名，你可以输入：</p><pre><code>dig @8.8.8.8 www.example.com</code></pre></li><li><p><strong>简化输出</strong>：<code>dig</code> 的输出包含很多详细信息，如果你只需要 IP 地址，可以使用 <code>+short</code> 选项来简化输出。例如：</p><pre><code>dig +short www.example.com</code></pre></li></ol><h1 id="子域名信息收集"><a href="#子域名信息收集" class="headerlink" title="子域名信息收集"></a>子域名信息收集</h1><h2 id="maltego"><a href="#maltego" class="headerlink" title="maltego"></a>maltego</h2><p>Maltego 是一种开源的情报收集和数据可视化工具。它广泛应用于网络防御、信息安全、侦查和其他相关领域。Maltego 主要用于收集公开可获取的信息（Open-source intelligence, OSINT）并将这些信息关联起来以发现隐藏的关系。</p><p>这种工具可以提取大量数据，并通过各种转换工具分析这些数据，以揭示网络、个人、组织、网址、社交网络账户等之间的关系。Maltego 可以通过图形化界面显示这些信息和关系，让用户能够更好地理解和解读数据。</p><p>Maltego 可以收集和分析的信息类型包括：</p><ul><li>域名、网站和网络基础设施</li><li>人员姓名、社交媒体信息和电子邮件地址</li><li>电话号码和地理位置信息</li><li>公司、组织和业务关系信息</li></ul><p>这些信息可以帮助安全研究员、调查人员、情报机构等用户追踪网络攻击、侦查欺诈活动、进行企业情报收集、网络侦查等活动</p><h2 id="子域名"><a href="#子域名" class="headerlink" title="子域名"></a>子域名</h2><p>子域名是 Internet 域名系统（DNS）层级结构中的一部分，位于主域名之下。子域名可以帮助组织管理和分发其主域名下的内容，它常常用于区分公司的不同业务部门或产品，或者提供不同地区的本地化服务。</p><p>例如，在域名 “<a href="http://www.example.com&quot;" target="_blank" rel="noopener">www.example.com&quot;</a> 中，”www” 就是一个子域名，”example.com” 是主域名。实际上，”www” 只是约定俗成的子域名，表示一个公司的主网站。其他常见的子域名可能包括 “mail.example.com”（用于电子邮件服务）、”blog.example.com”（用于博客）或者 “us.example.com”（用于美国的本地化服务）等。</p><p>一个主域名下可以有多个子域名，甚至可以有多级子域名。例如，你可以有一个 “sales.ny.us.example.com” 的子域名，其中 “sales” 是一级子域名，”ny” 是二级子域名，”us” 是三级子域名。</p><p>使用子域名的好处之一是，它们可以指向不同的 IP 地址，因此可以分散网站流量，提供更好的用户体验。此外，它们还可以帮助提高网站的搜索引擎优化（SEO）效果，因为搜索引擎通常将子域名视为独立的网站。</p><h2 id="如何查找子域名"><a href="#如何查找子域名" class="headerlink" title="如何查找子域名"></a>如何查找子域名</h2><p>1.子域名挖掘工具 : Maltego 子域名挖掘机。<br>2.搜索引擎挖掘 如: 在Google 中输入 site:qq.comu<br>3.第三方网站查询: <a href="http://tool.chinaz.com/subdomain、https://dnsdumpster.com/" target="_blank" rel="noopener">http://tool.chinaz.com/subdomain、https://dnsdumpster.com/</a></p><p>4.证书透明度公开日志枚举: <a href="https://crt.sh/" target="_blank" rel="noopener">https://crt.sh/</a> 、<a href="http://censys.io/4" target="_blank" rel="noopener">http://censys.io/4</a><br>5.其他途径: <a href="https://phpinfo.me/domain" target="_blank" rel="noopener">https://phpinfo.me/domain</a> 、<a href="http://dns.aizhan.com" target="_blank" rel="noopener">http://dns.aizhan.com</a></p><h1 id="shodan-信息收集"><a href="#shodan-信息收集" class="headerlink" title="shodan 信息收集"></a>shodan 信息收集</h1><h2 id="Shodan介绍"><a href="#Shodan介绍" class="headerlink" title="Shodan介绍"></a>Shodan介绍</h2><p>Shodan 搜索引擎概述:虽然目前人们都认为谷歌是最强劲的搜索引擎，但Shodan 才是互联网上最可怕的搜索引擎。与谷歌不同的是，Shodan 不是在网上搜索网址，而是直接进入互联网背后的通道。Shodan 可以说是一款“黑暗”谷歌，一刻不停的在寻找着所有和互联网关联的服务器、摄像头、打印机、路由器等等。还可以直接显示出目标的县体地理位置信息。</p><p>  网址：<a href="https://www.shodan.io/" target="_blank" rel="noopener">https://www.shodan.io/</a></p><h2 id="Shodan-的工作原理："><a href="#Shodan-的工作原理：" class="headerlink" title="Shodan 的工作原理："></a>Shodan 的工作原理：</h2><p>它通过互联网扫描各类设备，收集关于这些设备的信息，如 IP 地址、操作系统、开放的网络端口、所在地理位置等。这些信息会被 Shodan 索引并存储，用户可以通过关键词或者特定的搜索过滤器在 Shodan 上进行查询。</p><h2 id="Shodan-的主要用途"><a href="#Shodan-的主要用途" class="headerlink" title="Shodan 的主要用途"></a>Shodan 的主要用途</h2><p>可以被归纳为两大类：安全研究和威胁侦查。安全研究人员可以利用 Shodan 检查自家网络中可能存在的安全漏洞，或者研究新的攻击方式。另一方面，威胁猎人和安全响应团队可以使用 Shodan 追踪恶意活动和攻击者。Shodan 也常被用于侦查网络犯罪活动，如寻找可能被利用为僵尸网络的设备。</p><h2 id="Shodan-的搜索语法"><a href="#Shodan-的搜索语法" class="headerlink" title="Shodan 的搜索语法"></a>Shodan 的搜索语法</h2><p>能够进行细致的过滤以帮助你找到特定的设备。下面是一些基本的搜索过滤器：</p><ol><li><p><strong>城市（city）</strong>：可以通过 <code>city:北京</code> 这样的搜索过滤器找到特定城市的设备。</p></li><li><p><strong>国家（country）</strong>：同样，<code>country:CN</code> 可以帮助你找到位于中国的设备。</p></li><li><p><strong>端口（port）</strong>：<code>port:22</code> 会返回所有开放了 22 端口（通常为 SSH 服务）的设备。</p></li><li><p><strong>操作系统（os）</strong>：<code>os:windows</code> 会返回所有运行 Windows 操作系统的设备。</p></li><li><p><strong>组织（org）</strong>：<code>org:&quot;Microsoft&quot;</code> 可以搜索特定组织的设备。</p></li><li><p><strong>产品（product）</strong>：<code>product:&quot;Apache httpd&quot;</code> 会返回使用了特定软件产品的设备。</p></li></ol><p>这些只是 Shodan 的基本搜索过滤器，实际上 Shodan 还支持很多其他的搜索过滤器，甚至可以组合使用多个过滤器，如 <code>city:北京 country:CN port:22</code>。</p><ol><li><p><strong>hostname</strong>：可以搜索特定主机名的设备，例如：<code>hostname:google.com</code>。</p></li><li><p><strong>net</strong>：搜索特定 IP 地址范围的设备，例如：<code>net:192.168.1.0/24</code>。</p></li><li><p><strong>before/after</strong>：可以搜索特定日期之前或之后的设备，例如：<code>before:2023-01-01</code> 或 <code>after:2023-01-01</code>。</p></li><li><p><strong>geo</strong>：搜索指定地理坐标范围的设备，例如：<code>geo:37.7749,-122.4194</code>。</p></li><li><p><strong>has_ipv6</strong>：搜索支持 IPv6 的设备，例如：<code>has_ipv6:true</code>。</p></li><li><p><strong>ssl</strong>：搜索使用 SSL 的设备，例如：<code>ssl:cert.subject.CN:google</code>。</p></li><li><p><strong>version</strong>：搜索特定版本的设备，例如：<code>version:1.0</code>。</p></li></ol><p>还可以使用一些逻辑运算符来结合多个过滤器，如 <code>AND</code>、<code>OR</code> 和 <code>NOT</code>。例如：<code>port:80 AND city:Beijing</code> 会返回在北京并开放了 80 端口的设备。</p><p>以上只是一部分 Shodan 的搜索过滤器，要获取更详细的信息，可以查阅 Shodan 的官方文档或搜索语法指南。</p><h1 id="Google-搜索引擎的使用"><a href="#Google-搜索引擎的使用" class="headerlink" title="Google 搜索引擎的使用"></a>Google 搜索引擎的使用</h1><h2 id="Google-hacking是什么？"><a href="#Google-hacking是什么？" class="headerlink" title="Google hacking是什么？"></a>Google hacking是什么？</h2><p>Google hacking，维基百科解释： 是指利用谷歌搜索引擎中的高级操作符，在搜索结果中定位特定的文本字符串 。这种技术利用的是网站配置和代码中存在的安全漏洞，通过特定的搜索语法来寻找和利用这些漏洞。</p><h2 id="Google-hacking常用的技术语法"><a href="#Google-hacking常用的技术语法" class="headerlink" title="Google hacking常用的技术语法"></a>Google hacking常用的技术语法</h2><p>列举常用的google语法，通过这些语法更好定位想要的信息；更多详细的语法，可以进数据库查看</p><ul><li><strong>site:</strong>：这个操作符可以让你只在特定网站内进行搜索。例如，”site:example.com” 就会在 example.com 网站内搜索。</li><li><strong>filetype:</strong>：这个操作符可以帮助你搜索特定类型的文件。例如，”filetype:pdf” 就会搜索PDF文件。</li><li><strong>intitle:</strong>：使用这个操作符可以搜索包含特定词语的网页标题。例如，”intitle:password” 会搜索标题中含有 “password” 的网页。</li><li><strong>inurl:</strong>：这个操作符可以搜索URL中包含特定词语的网页。例如，”inurl:admin” 会搜索URL中包含 “admin” 的网页。</li><li><strong>intext:</strong>：使用这个操作符可以搜索网页正文中包含特定词语的网页。例如，”intext:confidential” 会搜索正文中含有 “confidential” 的网页。</li><li><strong>cache:</strong>：这个操作符可以帮助你查看Google对某个网页的缓存版本。例如，”cache:example.com” 会显示Google最近一次索引 example.com 的快照。</li><li><strong>link:</strong>：这个操作符可以帮助你查找链接到特定URL的所有网页，不过这个功能在2017年被Google关闭，现在可能已经不能用了。</li><li><strong>info:</strong>：这个操作符可以帮助你获取关于特定URL的基本信息，如网页描述、相关链接等。</li><li><strong>related:</strong>：这个操作符可以帮你查找和特定网站内容相关的网站。</li><li><strong>stocks:</strong>：这个操作符可以帮助你查找特定公司的股票信息。</li></ul><blockquote><p>google hacking语法库：<a href="https://www.exploit-db.com/google-hacking-database" target="_blank" rel="noopener">https://www.exploit-db.com/google-hacking-database</a></p></blockquote><p>符号类</p><ul><li><strong>使用双引号(“ “)进行精确匹配</strong>：例如，搜索 “太阳能电池” 将只返回包含完整词组 “太阳能电池” 的结果。</li><li><strong>使用减号(-)排除特定词汇</strong>：例如，搜索 “iPhone -12” 将返回与 iPhone 相关的结果，但不包括 “iPhone 12”。</li><li><strong>使用星号(*)作为通配符</strong>：例如，搜索 “Apple 的 * 手机” 可以返回 “Apple 的 iPhone 手机”、”Apple 的 5G 手机” 等结果。</li><li><strong>使用 OR 查询多个词</strong>：例如，搜索 “华为 OR 小米” 将返回与 “华为” 或 “小米” 相关的结果</li></ul><h2 id="如何利用-防范Google-hacking？"><a href="#如何利用-防范Google-hacking？" class="headerlink" title="如何利用/防范Google hacking？"></a>如何利用/防范Google hacking？</h2><p>利用: 利用好google hacking 可以更准确找到自己需要的信息，做到真正的高效搜索</p><p>防范：Google hacking的首要步骤是对自己的网络环境有深入的了解，包括服务器配置、代码安全等。其次，定期进行安全审计和漏洞扫描也非常重要，这可以帮助我们及时发现并修复潜在的安全问题。最后，我们还可以通过robots.txt文件来限制搜索引擎对敏感信息的索引，从而避免信息被黑客搜索到。</p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术分享 </tag>
            
            <tag> 网络安全 </tag>
            
            <tag> 渗透测试 </tag>
            
            <tag> shodan </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>渗透-主动信息收集</title>
      <link href="/shen-tou-zhu-dong-xin-xi-shou-ji.html"/>
      <url>/shen-tou-zhu-dong-xin-xi-shou-ji.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="主动信息收集"><a href="#主动信息收集" class="headerlink" title="主动信息收集"></a>主动信息收集</h1><h2 id="什么是主动信息收集"><a href="#什么是主动信息收集" class="headerlink" title="什么是主动信息收集"></a>什么是主动信息收集</h2><p>主动信息收集指的是主体根据自身需求和目标，通过主动搜集、查询、调查等方式，积极主动地获取所需的信息。在主动信息收集中，个体或组织作为信息的主动者，主动发起搜索和查询行为，以获得所需的有用信息 </p><h2 id="主动信息收集的原理"><a href="#主动信息收集的原理" class="headerlink" title="主动信息收集的原理"></a>主动信息收集的原理</h2><h3 id="主动信息收集的特点"><a href="#主动信息收集的特点" class="headerlink" title="主动信息收集的特点"></a>主动信息收集的特点</h3><p>1直接与目标系统交互通信 2.无法避免留下访问的痕迹 3.使用受控的第三方电脑进行探测，使用代理或已经被控制的机器，做好被封杀的准备 4.扫描发送不同的探测，根据返回结果判断目标状态</p><h3 id="发现目标主机的过程"><a href="#发现目标主机的过程" class="headerlink" title="发现目标主机的过程"></a>发现目标主机的过程</h3><p>1识别存活主机，发现潜在的被攻击目标</p><p>2输出一个IP 地址列表比如IP 地址段 IP 地址范围</p><p>3使用二、三、四层进行探测发现</p><h2 id="OSI七层模型和-TCP-IP-五层模型"><a href="#OSI七层模型和-TCP-IP-五层模型" class="headerlink" title="OSI七层模型和 TCP/IP 五层模型"></a>OSI七层模型和 TCP/IP 五层模型</h2><p> OSI 参考模型和 TCP/IP 模型的各层以及它们的解释：</p><table><thead><tr><th>OSI 七层模型</th><th>各层的解释</th><th>TCP/IP 五层模型</th><th>对应的网络设备关系</th><th>对应的协议关系</th></tr></thead><tbody><tr><td>应用层</td><td>为应用程序提供服务</td><td>应用层</td><td>应用层</td><td>HTTP Telnet FTP TFTP DNS SMTP</td></tr><tr><td>表示层</td><td>数据格式转化、数据加密</td><td>同上</td><td>同上</td><td>同上</td></tr><tr><td>会话层</td><td>建立、管理和维护会话</td><td>同上</td><td>同上</td><td>同上</td></tr><tr><td>传输层</td><td>建立、管理和维护端到端的连接</td><td>传输层</td><td>四层交换机、四层的路由器</td><td>TCP UDP</td></tr><tr><td>网络层</td><td>IP 选址及路由选择</td><td>网络层</td><td>路由器、三层交换机</td><td>IP ICMP RIP IGMP</td></tr><tr><td>数据链路层</td><td>提供介质访问和链路管理</td><td>数据链路层</td><td>网桥、以太网交换机、网卡</td><td>ARP RARP IEEE802.3 PPP CSMA/CD</td></tr><tr><td>物理层</td><td>在物理媒介上传输比特流</td><td>物理层</td><td>中继器、集线器、双绞线</td><td>FE自协商 Manchester MLT-3 4A PAM5</td></tr></tbody></table><p>请注意，TCP/IP 模型是一个简化的模型，将 OSI 模型的表示层和会话层合并到应用层，将数据链路层和物理层合并为一个层级。因此，在 TCP/IP 模型中没有专门的表示层和会话层。</p><h2 id="基于OSI模型进行扫描的优缺点"><a href="#基于OSI模型进行扫描的优缺点" class="headerlink" title="基于OSI模型进行扫描的优缺点"></a>基于OSI模型进行扫描的优缺点</h2><p>1.二层扫描的优缺点 优点:扫描速度快、可靠 缺点:不可路由</p><p>2三层扫描的优缺点 优点:可路由，速度较快 缺点:速度比二层慢，经常被边界防火墙过滤使用IP、icmp协议</p><p>3四层扫描的优缺点</p><p>优点：</p><p>可路由且结果可靠 不太可能被防火墙过滤 可以发现所有端口都被过滤的主机</p><p>缺点：</p><p>基于状态过滤的防火墙可能过滤扫描 全端口扫描速度慢、</p><h1 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h1><h2 id="端口定义"><a href="#端口定义" class="headerlink" title="端口定义"></a><strong>端口定义</strong></h2><p>在计算机网络中，端口是一种抽象的软件结构，包括一些特定的协议和数据结构。它用于区分不同的进程或服务，每个端口都与一个特定的进程或服务相对应，通过端口号来唯一标识。</p><h2 id="端口分类"><a href="#端口分类" class="headerlink" title="端口分类"></a><strong>端口分类</strong></h2><p>根据端口号的范围，端口可以分为三类：</p><ol><li>知名端口（Well-Known Ports）：0到1023号，由Internet Assigned Numbers Authority (IANA)维护，对应一些固定的、被广泛使用的服务。例如，80端口通常用于HTTP服务，443端口用于HTTPS服务。</li><li>注册端口（Registered Ports）：1024到49151号，可以被应用程序和进程使用，但需要在IANA进行注册。</li><li>动态或私有端口（Dynamic or Private Ports）：49152到65535号，不需要注册就可以使用，通常被临时任务使用。</li></ol><h2 id="端口查看"><a href="#端口查看" class="headerlink" title="端口查看"></a><strong>端口查看</strong></h2><p>在Linux系统中，你可以使用<code>netstat</code>命令或者<code>lsof</code>命令来查看当前系统的端口使用情况。在Windows系统中，你可以使用<code>netstat</code>命令或者资源监视器来查看端口使用情况。</p><h2 id="常用端口和常见端口漏洞利用方式"><a href="#常用端口和常见端口漏洞利用方式" class="headerlink" title="常用端口和常见端口漏洞利用方式"></a><strong>常用端口和常见端口漏洞利用方式</strong></h2><p>以下是一些常用的端口号和它们通常对应的服务：</p><ul><li>21：FTP</li><li>22：SSH</li><li>23：Telnet</li><li>25：SMTP</li><li>53：DNS</li><li>80：HTTP</li><li>110：POP3</li><li>443：HTTPS</li><li>445：Microsoft-DS (SMB)</li><li>3306：MySQL</li><li>3389：Remote Desktop Protocol (RDP)</li></ul><p>每个服务都有可能存在漏洞，攻击者可以通过这些漏洞进行攻击。例如，旧版的FTP服务可能存在匿名访问漏洞，旧版的SSH服务可能存在弱密码或未修补的软件漏洞。对于445端口，MS17-010（永恒之蓝）就是一个被广泛利用的漏洞。</p><p>最佳的防御措施是保持系统和服务的更新，定期进行安全审计，以及使用复杂且不易被猜测的密码。</p><h1 id="基于-ping-命令的探测"><a href="#基于-ping-命令的探测" class="headerlink" title="基于 ping 命令的探测"></a>基于 ping 命令的探测</h1><h2 id="ping命令："><a href="#ping命令：" class="headerlink" title="ping命令："></a>ping命令：</h2><p> <code>ping</code> 是一个常用的网络工具，用于检测主机之间的连通性。它通过向目标主机发送 ICMP (Internet Control Message Protocol) 回显请求消息，并等待目标主机返回回显应答消息来测试网络连接。 </p><pre><code>ping -c [count] [destination]</code></pre><p>“[count]”是要发送的ping请求的数量，”[destination]”是目标的IP地址或域名 </p><blockquote><p>根据操作系统和ping工具的不同，选项的语法和名称可能会有所不同。上述示例适用于大多数Linux和Unix类操作系统。如果你使用的是Windows操作系统，可能需要使用不同的选项，如”-n”来指定ping请求的数量 </p></blockquote><h2 id="traceroute命令："><a href="#traceroute命令：" class="headerlink" title="traceroute命令："></a>traceroute命令：</h2><p> <code>traceroute</code> 是一个常用的网络工具，用于跟踪数据包从本地主机到目标主机在网络上的路由路径。通过发送一系列的数据包，每个数据包在路由中途被一个节点（路由器）记录下来，<code>traceroute</code> 命令可以显示数据包经过的所有中间节点，并计算出每个节点的延迟时间 </p><pre><code>traceroute [选项] 目标主机</code></pre><p>常用选项：</p><ul><li><code>-m max_ttl</code>：设置最大跃点数（TTL），即指定数据包的最大可达距离。</li><li><code>-n</code>：以 IP 地址而非主机名显示路由节点。</li><li><code>-q num</code>：设置每个跃点发送的请求数量。</li></ul><h2 id="arping命令"><a href="#arping命令" class="headerlink" title="arping命令"></a>arping命令</h2><p>ARPing是地址解析协议（Address Resolution Protocol）的简称。它是一种用于在局域网中将IP地址映射到物理MAC地址的网络协议。每个网络设备都有一个唯一的物理地址，即MAC地址，用于在本地网络中进行通信。而在IP网络中，设备之间通过IP地址进行通信。</p><p>当一个设备需要向另一个设备发送数据时，它首先会检查目标设备的IP地址是否在同一局域网内。如果目标设备与发送设备在同一局域网内，那么发送设备可以直接发送数据。但如果目标设备不在同一局域网内，发送设备就需要知道目标设备的MAC地址才能正确传输数据。</p><p>这时候，发送设备就会使用ARP协议发送一个ARP请求广播到局域网内的所有设备，请求目标设备的MAC地址。目标设备收到ARP请求后，会通过ARP回应将自己的MAC地址发送给发送设备。发送设备接收到ARP回应后，就可以将目标设备的MAC地址与目标IP地址进行关联，然后将数据包发送到目标设备。</p><p>因此，ARPing实际上是指通过发送ARP请求来获取目标设备的MAC地址的过程。它在局域网环境中起着重要的作用，使得设备可以准确地将数据传递给目标设备。</p><pre><code>arping 192.168.1.1 -c 1 | grep &quot;bytes from&quot;arping 192.168.1.1 -c 1 | grep &quot;bytes from&quot; | cut -d &quot; &quot; -f 5arping 192.168.1.1 -c 1  grep &quot;bytes from&quot;  cut -d &quot; &quot; -f 5  cut -d &quot;(&quot; -f 2  cut -d &quot;)&quot; -f 1执行arp命令，并截取出ip地址————输出：192.168.1.1</code></pre><ul><li><code>cut</code>：执行 <code>cut</code> 命令，用于从输入行中提取特定字段。</li><li><code>-d &quot; &quot;</code>：指定字段分隔符为空格。</li><li><code>-f 5</code>：指定要提取的字段为第 5 个字段。</li></ul><h2 id="多抓mac地址脚本"><a href="#多抓mac地址脚本" class="headerlink" title="多抓mac地址脚本"></a>多抓mac地址脚本</h2><p>脚本：arping1.sh</p><pre><code>#!/bin/bashif [&quot;$#&quot; -ne 1 ];then   #判断用户是否输入了至少一个参数如果没有输入参数，输出提示信息并退出    echo &quot;Usage - ./arping.sh [interface]&quot;    echo &quot;Excample - ./arping.sh etho&quot;    echo &quot;Example will perform an ARP scan of the local subnet to which eth0 is assigned&quot;    exitfiinterface=$1    #将用户输入的参数传递给 interface变量prefix=$(ifconfig $interface | grep &quot;inet&quot; | cut -d &#39;t&#39; -f 2 | cut -d &#39;.&#39; -f 1-3)    #获取本机IP地址网段192.168.1##对整个网段进行arpingfor addr in $(seq 1 254);do  arping -c 1 $prefix.$addr grep &quot;bytes from&quot; | cut -d &quot; &quot; -f 5 | cut -d &quot;(&quot; -f 2 | cut -d &quot;)&quot; -f 1done</code></pre><p> 脚本的整体作用是执行本地子网的 ARP 扫描，逐个遍历子网中的 IP 地址并输出相应的 MAC 地址。 </p><h2 id="netdiscover"><a href="#netdiscover" class="headerlink" title="netdiscover"></a>netdiscover</h2><h3 id="主动模式"><a href="#主动模式" class="headerlink" title="主动模式:"></a>主动模式:</h3><p>主动模式顾名思义就是主动的探测发现网络内主机，但是这种方式往往会引起网络管理员的注意</p><pre><code>netdiscover i eth0 -r 192.168.1.0/24</code></pre><p>参数: -i device: your network devicee</p><p>-r range:  “-r”表示扫描指定的IP范围，而”192.168.0.0/24”是要扫描的子网 </p><h3 id="被动模式"><a href="#被动模式" class="headerlink" title="被动模式:"></a>被动模式:</h3><p>被动模式的方法更加隐蔽，但是速度会比较慢，网卡被设置为混杂模式来侦听网络内的 arp 数据包进行被动式探测，这种方式就需要网络内设备发送 arp 包才能被探测到。</p><pre><code>netdiscover -p</code></pre><p>参数: -p passive mode:  在被动模式下，Netdiscover不会发送任何ARP请求以主动发现网络上的设备，而是静默地监听网络，只收集通过网络发送的ARP包。这种模式的优势在于，它对网络的影响最小，不会引起目标系统或网络监控工具的警报。 </p><p> 可以使用<code>man netdiscover</code>或<code>netdiscover -h</code>来查看所有的选项和用法 </p><h2 id="hping3："><a href="#hping3：" class="headerlink" title="hping3："></a>hping3：</h2><p> <code>hping3</code>是一个网络工具，可用于生成并分析各种类型的网络数据包，如ICMP、TCP、UDP等。它可以用于网络安全测试、防火墙和IDS测试、网络扫描、路由跟踪等多种场景。 </p><p>以下是一些<code>hping3</code>的基本用法：</p><ul><li><p>发送TCP SYN包（常用于端口扫描）：</p><p><code>hping3 -S &lt;目标IP&gt; -p &lt;目标端口&gt;</code></p></li><li><p>发送TCP ACK包（常用于防火墙规则测试）：</p><p><code>hping3 -A &lt;目标IP&gt; -p &lt;目标端口&gt;</code></p></li><li><p>发送ICMP Echo请求（类似于ping命令）：</p><p><code>hping3 -1 &lt;目标IP&gt;</code></p></li><li><p>发送UDP数据包：</p><p><code>hping3 -2 &lt;目标IP&gt; -p &lt;目标端口&gt;</code></p><blockquote><p>可能被滥用</p><p>两个例子说明<code>hping3</code>如何可能被滥用：</p><ol><li><p><strong>洪水攻击</strong>：这是一种DoS（Denial of Service，服务拒绝）攻击，通过向目标发送大量数据包来消耗其资源。例如，下面的命令会向目标IP发送大量的ICMP Echo请求（ping请求）：</p><p><code>hping3 -1 --flood &lt;目标IP&gt;</code></p><p>在这个命令中，<code>-1</code>表示使用ICMP，<code>--flood</code>表示以最快的速度发送数据包。</p></li><li><p><strong>SYN洪水攻击</strong>：这也是一种DoS攻击，通过向目标发送大量未完成的TCP连接请求，以消耗其资源。例如：</p><p><code>hping3 -S --flood -p 80 &lt;目标IP&gt;</code></p><p>在这个命令中，<code>-S</code>表示使用SYN标志，<code>--flood</code>表示以最快的速度发送数据包，<code>-p 80</code>表示目标端口为80。</p></li></ol></blockquote></li></ul><h4 id="ddos与hping3："><a href="#ddos与hping3：" class="headerlink" title="ddos与hping3："></a>ddos与hping3：</h4><p>DDoS（分布式拒绝服务）攻击和hping3模拟的攻击之间存在一些重要区别：</p><ol><li>资源规模：DDoS攻击通常涉及大量的机器参与，形成一个分布式网络（botnet），以同时向目标系统发送大量流量或请求。这使得DDoS攻击可以产生巨大的带宽消耗和服务过载。而hping3是一个单机工具，无法实现类似规模和效果的攻击。</li><li>IP地址：在典型的DDoS攻击中，攻击者使用控制的僵尸计算机或通过操纵网络协议来伪造大量不同的IP地址。这样可以增加攻击的复杂性和欺骗性，使防御更加困难。相比之下，hping3发送的数据包通常会显示真实的源IP地址，除非使用其他技术进行欺骗。</li><li>合法性：DDoS攻击是非法行为，违反了许多国家/地区的法律法规。对于个人用户或未经授权的使用者来说，实施DDoS攻击是严重违法的行为，可能导致刑事指控和严厉的法律后果。hping3作为一个网络工具，可以用于合法的网络测试和研究目的，但需要在合规和授权的环境中使用。</li></ol><p>总结起来，DDoS攻击是一种恶意行为，涉及大规模的资源消耗和伪造IP地址的操作。hping3仅是一个网络工具，可以用于模拟某些攻击情景，并在合法的环境下进行网络测试。但它无法达到典型DDoS攻击的规模和效果，并且使用hping3实施未经授权的攻击是非法的。</p><h2 id="fping："><a href="#fping：" class="headerlink" title="fping："></a>fping：</h2><p><code>fping</code>是一种网络诊断工具，它的主要目的是快速检查一组IP地址，看看哪些是活动的，哪些是不活动的。它与经典的<code>ping</code>工具的主要区别在于，<code>fping</code>是设计来检查多个IP地址的，而<code>ping</code>主要是用来检查单个IP地址。</p><p>以下是一些<code>fping</code>的基本用法：</p><ul><li><p>检查单个IP地址：</p><p><code>fping 192.168.0.1</code></p></li><li><p>检查多个IP地址：</p><p><code>fping 192.168.0.1 192.168.0.2 192.168.0.3</code></p></li><li><p>从文件中读取IP地址进行检查：</p><p><code>fping -f ip_addresses.txt</code></p><p>其中，<code>ip_addresses.txt</code>是一个包含要检查的IP地址的文件，每个IP地址占一行。</p></li></ul><h1 id="基于Nmap的扫描方式"><a href="#基于Nmap的扫描方式" class="headerlink" title="基于Nmap的扫描方式"></a>基于Nmap的扫描方式</h1><h2 id="Nmap的基本扫描方式"><a href="#Nmap的基本扫描方式" class="headerlink" title="Nmap的基本扫描方式"></a>Nmap的基本扫描方式</h2><p>Nmap，也就是Network Mapper，最早是Linux下的网络扫描和嗅探工具包。</p><pre><code>针对全连接扫描和半连接扫描（了解tcp三次握手），相应的Nmap命令如下：全连接扫描：这也被称为TCP connect()扫描，可以使用-sT选项来进行。nmap -sT &lt;目标IP&gt;半连接扫描：这也被称为SYN扫描，可以使用-sS选项来进行。需要注意的是，这种扫描方式通常需要管理员权限。nmap -sS &lt;目标IP&gt;</code></pre><h2 id="nc端口扫描："><a href="#nc端口扫描：" class="headerlink" title="nc端口扫描："></a>nc端口扫描：</h2><p> <code>nc</code>，全称netcat，是一个简单而强大的网络工具，可以用于读取和写入网络连接。由于其多功能性，它被誉为网络界的”瑞士军刀”。在端口扫描上，使用<code>nc</code>命令扫描目标主机的开放端口。 </p><p>以下是一些<code>nc</code>端口扫描的基本用法：</p><ul><li><p>扫描单个端口：</p><p><code>nc -zv &lt;目标IP&gt; &lt;端口号&gt;</code></p></li><li><p>扫描一系列端口：</p><p><code>nc -zv &lt;目标IP&gt; &lt;起始端口&gt;-&lt;结束端口&gt;</code></p></li></ul><h1 id="实战1-使用scapy定制数据包进行高级扫描"><a href="#实战1-使用scapy定制数据包进行高级扫描" class="headerlink" title="实战1-使用scapy定制数据包进行高级扫描"></a>实战1-使用scapy定制数据包进行高级扫描</h1><p> Scapy的强大之处在于它能够让你定制数据包进行各种复杂的网络任务，包括高级的端口扫描。以下是使用Scapy进行TCP SYN扫描（半连接扫描）和TCP connect扫描（全连接扫描）的示例： </p><h2 id="1-TCP-SYN扫描（半连接扫描）"><a href="#1-TCP-SYN扫描（半连接扫描）" class="headerlink" title="1. TCP SYN扫描（半连接扫描）"></a><strong>1. TCP SYN扫描（半连接扫描）</strong></h2><pre><code>from scapy.all import IP, TCP, sr1target_ip = &quot;192.168.0.1&quot;target_port = 80ip = IP(dst=target_ip)syn = TCP(dport=target_port, flags=&#39;S&#39;)packet = ip/synresponse = sr1(packet, timeout=2)if response:    if response[TCP].flags == &#39;SA&#39;:        print(f&quot;Port {target_port} is open.&quot;)    else:        print(f&quot;Port {target_port} is closed.&quot;)else:    print(&quot;No response received.&quot;)</code></pre><p>这个代码会创建一个SYN数据包并发送到目标IP的目标端口，然后等待一个响应。如果收到的响应是SYN/ACK（即，flags是’SA’），则表示端口是开放的。如果没有收到响应，或者响应不是SYN/ACK，则表示端口是关闭的。</p><h2 id="2-TCP-connect扫描（全连接扫描）"><a href="#2-TCP-connect扫描（全连接扫描）" class="headerlink" title="2. TCP connect扫描（全连接扫描）"></a><strong>2. TCP connect扫描（全连接扫描）</strong></h2><p>Scapy没有内置的TCP connect扫描功能，所以如果你想进行这种扫描，可能需要使用其他的库，例如socket库。</p><pre><code>import sockettarget_ip = &quot;192.168.0.1&quot;target_port = 80try:    client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)    client.connect((target_ip, target_port))    client.close()    print(f&quot;Port {target_port} is open.&quot;)except:    print(f&quot;Port {target_port} is closed.&quot;)</code></pre><p> 这个代码会尝试连接到目标IP的目标端口，如果连接成功，则表示端口是开放的；如果连接失败，则表示端口是关闭的。 </p><h2 id="kali下的scapy使用："><a href="#kali下的scapy使用：" class="headerlink" title="kali下的scapy使用："></a>kali下的scapy使用：</h2><pre><code>sudo apt-get install python3-scapy</code></pre><h3 id="查看arp函数的用法"><a href="#查看arp函数的用法" class="headerlink" title="查看arp函数的用法"></a>查看arp函数的用法</h3><pre><code>&gt;&gt;&gt; ARP().display()###[ ARP ]###   hwtype    = 0x1  ptype     = IPv4  hwlen     = 6  plen      = 4  op        = who-has  hwsrc     = 00:00:00:00:00:00  psrc      = 0.0.0.0  hwdst     = 00:00:00:00:00:00  pdst      = 0.0.0.0</code></pre><p>例:定义向192.168.1.1发送arp 请求的数据包</p><h3 id="sr1函数作用"><a href="#sr1函数作用" class="headerlink" title="sr1函数作用:"></a>sr1函数作用:</h3><p>sr1函数包含了发送数据包和接收数据包的功能</p><pre><code>&gt;&gt;&gt;sr1(ARP(pdst=&quot;192.168.1.1&quot;))Begin emission:Finished sending 1 packets.Received 2 packets, got 1 answers, remaining 0 packets&lt;ARP  op=is-at hwsrc=00:11:22:33:44:55 psrc=192.168.1.1 hwdst=00:66:77:88:99:aa pdst=192.168.1.2 |&gt;</code></pre><p> 这个输出表示Scapy收到了一个ARP响应，其中源硬件地址（hwsrc）是目标主机的MAC地址，源协议地址（psrc）是目标主机的IP地址。目标硬件地址（hwdst）和目标协议地址（pdst）则是发送ARP请求的主机的MAC地址和IP地址。 </p><blockquote><p>发现源地址 psrc=192.168.1.1，说明已经收到网关的应答包。</p></blockquote><h3 id="查看tcp函数的用法"><a href="#查看tcp函数的用法" class="headerlink" title="查看tcp函数的用法"></a>查看tcp函数的用法</h3><pre><code>&gt;&gt;&gt; TCP().display()###[ TCP ]###   sport     = ftp_data  dport     = http  seq       = 0  ack       = 0  dataofs   = None  reserved  = 0  flags     = S  window    = 8192  chksum    = None  urgptr    = 0  options   = {}</code></pre><p> 这显示了一个TCP数据包的默认值，包括源端口（sport）、目标端口（dport）、序列号（seq）、确认号（ack）、数据偏移（dataofs）、保留位（reserved）、标志（flags）、窗口大小（window）、校验和（chksum）、紧急指针（urgptr）和选项（options） </p><h1 id="实战-2-僵尸扫描"><a href="#实战-2-僵尸扫描" class="headerlink" title="实战 2-僵尸扫描"></a>实战 2-僵尸扫描</h1><blockquote><p>僵尸扫描的思维值得一学</p></blockquote><h2 id="什么是僵尸扫描？"><a href="#什么是僵尸扫描？" class="headerlink" title="什么是僵尸扫描？"></a>什么是僵尸扫描？</h2><p>僵尸主机: 僵尸主机是指感染僵尸程序病毒，从而被黑客程序控制的计算机设备。<strong>但是僵尸扫描中的僵尸主机指得是一个闲置的操作系统 (这里的闲置是指主机不会主动和任何人通信)</strong>，且此系统中 IP 数据包中ID 是递增的。</p><p>IPID:指的是通信过中，IP 数据包中的ID。</p><p>僵尸扫描拥有极高的隐蔽特性，但是实施条件苛刻。</p><p>1.目标网络可伪造源地址进行访问 2.选择僵尸机，僵尸机需要在互联网上是一个闲置的操作系统，需要系统使用递增的IPID，比如XP 系统。</p><h2 id="僵尸扫描过程图示"><a href="#僵尸扫描过程图示" class="headerlink" title="僵尸扫描过程图示"></a>僵尸扫描过程图示</h2><p><img src="https://segmentfault.com/img/bVbr69u?w=673&h=287" alt="僵尸扫描图示"></p><p>第一步:参考图1 (1)、攻击者向僵尸机发送SYN/ACK 确认包。 (2)、僵尸主机返回我们 RST 数据包关闭链接，RST 数据包中包含了IPID 信息。假设 IPID=Xe注:三次握手的第一个包是SYN，目标主机收到SYN 才会应答SYN/ACK，因为尸主机没有向我门发送SYN 请求。所以僵尸主机返回我们 RST 数据包关闭链接。第一步中，黑客的收获是: 知道了僵尸主机的 IPID</p><p>第二步:参考图2。 (1)攻击者修改IP 包头的 SRC字段为尸主机的IP，伪装成尸主机给目标主机发 SYN 请求.(2)、目标主机收到请求，如果端口是开放的就会返回给僵尸主机一个SYN/ACK 的数据包。(3)尸主机收到目标主机发来的 SYN/ACK 确认包，因为尸主机没有给你发 SYN 请求。所以僵尸主机给目标主机返回了一个 RST 数据包。这个数据包表示关闭连接。此尸主机对外发出一个数据包，所以僵尸主机的IPID 值+1。此时IPID 值为 X+1。</p><p>第三步:参考图 3 (1)、攻击者再次向僵尸主机发送 SYN/ACK 确认包 (2)、僵尸主机同样向攻击者返回了一个 RST 数据包，此僵尸主机对外又发出一个数据包，所以僵尸主机的IPID 值再+1。此时IPID 值为X+2</p><p>第四步:计算3次通信过中的IPID 值 (1)、攻击者查看僵尸主机返回的数据包中IPID 值为 X+2 (2)、攻击者对比在第一步中的IPID 值 X，发现增加了 2。 结论:肯定目标主机和僵尸主机通信了，能通信，就说明目标主机端口是开放的。</p><h2 id="Python脚本实现僵尸扫描"><a href="#Python脚本实现僵尸扫描" class="headerlink" title="Python脚本实现僵尸扫描"></a>Python脚本实现僵尸扫描</h2><pre><code>from scapy.all import *# 僵尸主机 IP 和目标主机 IPzombie_host_ip = &#39;zombie_host_ip&#39;target_host_ip = &#39;target_host_ip&#39;target_port = 80# 发送一个数据包到僵尸主机，获取 IP IDipid_start = sr1(IP(dst=zombie_host_ip) / TCP(dport=80), verbose=0)[IP].id# 使用僵尸主机的 IP 作为源 IP，向目标主机发送一个 SYN 数据包send(IP(src=zombie_host_ip, dst=target_host_ip) / TCP(dport=target_port, flags=&#39;S&#39;), verbose=0)# 再次向僵尸主机发送一个数据包，获取 IP IDipid_end = sr1(IP(dst=zombie_host_ip) / TCP(dport=80), verbose=0)[IP].id# 比较两次获取的 IP ID，如果有变化，那么就可以推断目标主机的端口是开放的if ipid_end &gt; ipid_start:    print(f&#39;Port {target_port} is open.&#39;)else:    print(f&#39;Port {target_port} is closed.&#39;)</code></pre><p> 这个脚本中，我们首先向僵尸主机发送一个 TCP 数据包并获取其 IP ID。然后我们伪造一个 TCP SYN 数据包，并将源 IP 设置为僵尸主机的 IP，将这个数据包发送到目标主机。最后我们再次向僵尸主机发送一个 TCP 数据包并获取其 IP ID。如果这两次获取的 IP ID 不同，那么就可以推断目标主机的端口是开放的。 </p><h2 id="NMAP实现僵尸扫描"><a href="#NMAP实现僵尸扫描" class="headerlink" title="NMAP实现僵尸扫描"></a>NMAP实现僵尸扫描</h2><p>假设</p><p>扫描主机 kali: ip:192.168.0.2 </p><p>zombie kali: ip:192.168.0.1 </p><p>目标主机 Windows: ip:192.168.0.7 </p><pre><code>root@kali:~# nmap -p445 192.168.111.111 --script=ipidseq.nseStarting Nmap 7.01 ( https://nmap.org ) at 2023-07-14 05:12 EDTNmap scan report for 192.168.111.111Host is up (0.00033s latency).PORT    STATE SERVICE445/tcp open  microsoft-dsHost script results:|_ipidseq: Incremental!Nmap done: 1 IP address (1 host up) scanned in 0.49 seconds</code></pre><p> 使用Nmap的<code>ipidseq.nse</code>脚本扫描IP地址为192.168.111.111的主机的445端口。这个脚本会检测目标主机的IP ID序列生成特性。在这个模拟的例子中，目标主机的IP ID序列是增量的，这意味着该主机可能可以作为僵尸扫描的僵尸主机 </p><p>可以看到该主机的ipid是递增的,僵尸找到了，开始进行扫描 NMAP 僵尸扫描 </p><pre><code>root@kali:~# nmap -Pn -sI 192.168.0.2 192.168.0.1 -p 0-100Starting Nmap 7.01 ( https://nmap.org ) at 2023-07-14 05:12 EDTNmap scan report for 192.168.0.1Host is up (0.00033s latency).PORT    STATE SERVICE1/tcp   open  tcpmux2/tcp   open  compressnet...99/tcp  open  metagram100/tcp open  newacctNmap done: 1 IP address (1 host up) scanned in 0.49 seconds</code></pre><p> 对192.168.0.1执行僵尸扫描，使用192.168.0.2作为僵尸主机，并扫描目标主机的前100个端口。 </p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术分享 </tag>
            
            <tag> 网络安全 </tag>
            
            <tag> 渗透测试 </tag>
            
            <tag> OSI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[两万字教程]MYSQL必知必会一站式完全教程</title>
      <link href="/shu-ju-fen-xi-liang-wan-zi-jiao-cheng-mysql-bi-zhi-bi-hui.html"/>
      <url>/shu-ju-fen-xi-liang-wan-zi-jiao-cheng-mysql-bi-zhi-bi-hui.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>此文是针对《MYSQL必知必会》一书学习的笔记与总结，注意要点的提示，<u>文末会放上总的思维导图</u>，该文除了对整书的脉络与知识点整理外，还有一些个人的总结见解，比如基本概念-mysql语句的法则与执行顺序，是通过阅读借鉴与实践再经过个人总结，后续且会不断更新本文，为写出更好的mysql语句 ^_^</p><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="什么是数据库？"><a href="#什么是数据库？" class="headerlink" title="什么是数据库？"></a>什么是数据库？</h2><p>一个以某种有组织的方式存储的数据集合，数据库（database） 保存有组织的数据的容器</p><p>数据库由表组成，行/列数据，数据类型；主键（primary key）一一列（或一组列），其值能够唯一区分表中每个行</p><h2 id="数据库术语"><a href="#数据库术语" class="headerlink" title="数据库术语"></a>数据库术语</h2><ul><li>数据库（database） - 保存有组织的数据的容器（通常是一个文件或一组文件）。</li><li>数据表（table） - 某种特定类型数据的结构化清单。</li><li>模式（schema） - 关于数据库和表的布局及特性的信息。模式定义了数据在表中如何存储，包含存储什么样的数据，数据如何分解，各部分信息如何命名等信息。数据库和表都有模式。</li><li>列（column） - 表中的一个字段。所有表都是由一个或多个列组成的。</li><li>行（row） - 表中的一个记录。</li><li>主键（primary key） - 一列（或一组列），其值能够唯一标识表中每一行</li></ul><h2 id="什么是SQL？"><a href="#什么是SQL？" class="headerlink" title="什么是SQL？"></a>什么是SQL？</h2><p>SQL是结构化查询语言（Structured Query  Language）的缩写。SQL是一种专门用来与数据库通信的语言</p><blockquote><p>语法结构：</p><p>1分号结尾、2不区分大小写、3字符要加单引号、4字段或参数间用逗号分割</p><ul><li><p>SQL 支持三种注释 </p><p> ## 注释1<br>– 注释2<br>/<em> 注释3 </em>/ </p></li><li><p>子句 - 是语句和查询的组成成分。（在某些情况下，这些都是可选的。）</p></li><li><p>表达式 - 可以产生任何标量值，或由列和行的数据库表</p></li><li><p>谓词 - 给需要评估的 SQL 三值逻辑（3VL）（true/false/unknown）或布尔真值指定条件，并限制语句和查询的效果，或改变程序流程。</p></li><li><p>查询 - 基于特定条件检索数据。这是 SQL 的一个重要组成部分。</p></li><li><p>语句 - 可以持久地影响纲要和数据，也可以控制数据库事务、程序流程、连接、会话或诊断。</p></li></ul></blockquote><h2 id="SQL分类"><a href="#SQL分类" class="headerlink" title="SQL分类"></a>SQL分类</h2><h3 id="数据定义语言（DDL）"><a href="#数据定义语言（DDL）" class="headerlink" title="数据定义语言（DDL）"></a>数据定义语言（DDL）</h3><p>数据定义语言（Data Definition Language，DDL）是 SQL 语言集中负责数据结构定义与数据库对象定义的语言。</p><p>DDL 的主要功能是定义数据库对象。</p><p>DDL 的核心指令是 CREATE、ALTER、DROP。</p><h3 id="数据操纵语言（DML）"><a href="#数据操纵语言（DML）" class="headerlink" title="数据操纵语言（DML）"></a>数据操纵语言（DML）</h3><p>数据操纵语言（Data Manipulation Language, DML）是用于数据库操作，对数据库其中的对象和数据运行访问工作的编程语句。</p><p>DML 的主要功能是 访问数据，因此其语法都是以读写数据库为主。</p><p>DML 的核心指令是 INSERT、UPDATE、DELETE、SELECT。这四个指令合称 CRUD(Create, Read, Update, Delete)，即增删改查。</p><h3 id="事务控制语言（TCL）"><a href="#事务控制语言（TCL）" class="headerlink" title="事务控制语言（TCL）"></a>事务控制语言（TCL）</h3><p>事务控制语言 (Transaction Control Language, TCL) 用于管理数据库中的事务。这些用于管理由 DML 语句所做的更改。它还允许将语句分组为逻辑事务。</p><p>TCL 的核心指令是 COMMIT、ROLLBACK。</p><h3 id="数据控制语言（DCL）"><a href="#数据控制语言（DCL）" class="headerlink" title="数据控制语言（DCL）"></a>数据控制语言（DCL）</h3><p>数据控制语言 (Data Control Language, DCL) 是一种可对数据访问权进行控制的指令，它可以控制特定用户账户对数据表、查看表、预存程序、用户自定义函数等数据库对象的控制权。</p><p>DCL 的核心指令是 GRANT、REVOKE。</p><p>DCL 以控制用户的访问权限为主，因此其指令做法并不复杂，可利用 DCL 控制的权限有：CONNECT、SELECT、INSERT、UPDATE、DELETE、EXECUTE、USAGE、REFERENCES。</p><p>根据不同的 DBMS 以及不同的安全性实体，其支持的权限控制也有所不同。</p><h2 id="什么是MYSQL？"><a href="#什么是MYSQL？" class="headerlink" title="什么是MYSQL？"></a>什么是MYSQL？</h2><p>MySQL是一种开源的关系型数据库管理系统（RDBMS），它是最流行和广泛使用的数据库之一。MySQL由瑞典公司MySQL AB开发，并在2008年被甲骨文公司收购。它支持多用户、多线程和多个存储引擎，可以在各种操作系统上运行。</p><p>MySQL具有以下特点：</p><ol><li><p>可靠性：MySQL以其稳定性和可靠性而闻名。它经过广泛测试和验证，被许多大型组织和网站用于处理大量数据。</p></li><li><p>性能：MySQL被设计为高性能数据库。它采用了各种优化技术，如索引、查询缓存和内存管理，以提供快速的数据访问和处理能力。</p></li><li><p>可扩展性：MySQL支持水平和垂直扩展。水平扩展通过分布式架构和数据分片来增加系统的容量和吞吐量。垂直扩展通过增加硬件资源（如CPU、内存）来提高单个服务器的性能。</p></li><li><p>简单易用：MySQL提供了简单而直观的命令和语法，使得数据库的管理和查询变得容易。它还提供了丰富的图形界面工具和API，方便开发人员进行数据库操作。</p></li><li><p>兼容性：MySQL遵循SQL标准，并提供了广泛的功能和特性，包括事务支持、触发器、存储过程和视图等。它还支持多种编程语言和开发框架。</p></li></ol><h2 id="MYSQL工具"><a href="#MYSQL工具" class="headerlink" title="MYSQL工具"></a>MYSQL工具</h2><ol><li>MySQL命令实用工具： 通过mysql的基础命令操作使用数据库</li><li>phpMyAdmin： phpMyAdmin是一个基于Web的MySQL数据库管理工具，它提供了一个易于使用的界面来管理数据库。通过phpMyAdmin，你可以执行SQL查询、导入和导出数据、创建和修改表结构、用户管理等。它支持多语言和跨平台，并且具有良好的扩展性，可以通过插件来增加额外的功能。phpMyAdmin是一个开源工具，广泛应用于各种Web开发项目中。</li><li>Navicat for MySQL：Navicat for MySQL是一款强大的数据库管理和开发工具，适用于MySQL和MariaDB。它提供了直观的用户界面，使得用户可以轻松地进行数据库设计、数据导入导出、SQL查询和脚本编写等操作。Navicat for MySQL支持多个平台，并且具有高级的数据可视化和报表生成功能。此外，它还提供了团队协作和版本控制的特性，方便多人共同开发和管理数据库。</li></ol><h2 id="使用MYSQL"><a href="#使用MYSQL" class="headerlink" title="使用MYSQL"></a>使用MYSQL</h2><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p>主机名（计算机名）——如果连接到本地MySQL服务器，为localhost； </p><p>端口（如果使用默认端口3306之外的端口）；</p><p> 一个合法的用户名； </p><p>用户口令（如果需要）；</p><h3 id="选择与了解"><a href="#选择与了解" class="headerlink" title="选择与了解"></a>选择与了解</h3><pre class=" language-sql"><code class="language-sql"><span class="token keyword">show</span> <span class="token keyword">database</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">#查看数据库</span><span class="token keyword">use</span> <span class="token keyword">database</span>；    <span class="token comment" spellcheck="true">#使用数据库</span><span class="token keyword">show</span> <span class="token keyword">tables</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">#查看表</span><span class="token keyword">show</span> <span class="token keyword">status</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">#查看广泛的服务器状态信息</span><span class="token keyword">show</span> grants<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">#显示授予用户的安全权限</span><span class="token keyword">show</span> error<span class="token punctuation">;</span>    <span class="token keyword">show</span> <span class="token keyword">warnings</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">#显示服务器错误或警告消息</span>help <span class="token keyword">show</span>；    <span class="token comment" spellcheck="true">#查看show的使用帮助</span></code></pre><blockquote><p>什么是自动增量？ 某些表列需要唯一值。例如，订单编号\雇员ID或（如上面例子中所示的顾客ID。在每个行添加到表 中时，MySQL可以自动地为每个行分配下一个可用编号，不用在添加一行时手动分配唯一值（这样做必须记住最后一次使 用的值）这个功能就是所谓的自动增量。如果需要它，则必须在用CREATE语句创建表时把它作为表定义的组成部分。</p></blockquote><h2 id="MYSQL语句的法则！！"><a href="#MYSQL语句的法则！！" class="headerlink" title="MYSQL语句的法则！！"></a>MYSQL语句的法则！！</h2><h3 id="书写顺序与执行顺序！！"><a href="#书写顺序与执行顺序！！" class="headerlink" title="书写顺序与执行顺序！！"></a>书写顺序与执行顺序！！</h3><pre class=" language-sql"><code class="language-sql"><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span> <span class="token keyword">SELECT</span> <span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token keyword">DISTINCT</span><span class="token operator">&lt;</span>Select_list<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">FROM</span> <span class="token operator">&lt;</span>left_table<span class="token operator">></span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span>join_type<span class="token operator">></span><span class="token keyword">JOIN</span><span class="token operator">&lt;</span>right_table<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">ON</span><span class="token operator">&lt;</span>join_condition<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token keyword">WHERE</span><span class="token operator">&lt;</span>where_condition<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token keyword">GROUP</span> <span class="token keyword">BY</span><span class="token operator">&lt;</span>group_by_list<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span> <span class="token keyword">WITH</span> {CUBE<span class="token operator">|</span>ROLLUP}<span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span> <span class="token keyword">HAVING</span><span class="token operator">&lt;</span>having_condtion<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">ORDER</span> <span class="token keyword">BY</span><span class="token operator">&lt;</span>order_by_list<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">LIMIT</span><span class="token operator">&lt;</span>limit_number<span class="token operator">></span></code></pre><p>书写顺序为此排列，执行顺序为（1）~（11）</p><p>SELECT子句是必选的，其它子句如WHERE子句、GROUP BY子句等是可选的。一个select语句中，子句的顺序是固定的。必须严格按照上述的顺序书写 </p><h3 id="法则："><a href="#法则：" class="headerlink" title="法则："></a>法则：</h3><p>SELECT col,col,col 找什么？ FROM table 从哪找？ WHERE col 条件 条件是啥？</p><p>这个法则教你怎么一步步写一个查询SQL，可以当做一种写SQL的思维</p><p>简言之，写任何一个查询语句，都分解成3步：</p><p>第一步：思考FROM后面的（也即是表）</p><p>第二步：思考WHERE条件（查手册就可以）</p><p>第三步：完善SELECT后面的（也就是老板要显示的数据）</p><h3 id="条件：数字-where"><a href="#条件：数字-where" class="headerlink" title="条件：数字(where)"></a>条件：数字(where)</h3><pre><code>当查找条件col是数字</code></pre><p><code>select * from table where col = 1</code>;</p><table><thead><tr><th>Operator</th><th>Condition</th><th>SQL Example</th><th>解释</th></tr></thead><tbody><tr><td>=, !=, &lt; ,&lt;=, &gt;, &gt;=</td><td>Standard numerical operators</td><td>col != 4</td><td>等于 大于 小于</td></tr><tr><td>BETWEEN … AND …</td><td>Number is within range of two values (inclusive)</td><td>col BETWEEN 1.5 AND 10.5</td><td>在 X 和 X之间</td></tr><tr><td>NOT BETWEEN … AND …</td><td>Number is not within range of two values (inclusive)</td><td>co NOT BETWEEN 1 AND10</td><td>不在 X 和 X之间</td></tr><tr><td>IN (…)</td><td>Number exists in a list</td><td>col IN (2, 4, 6)</td><td>在 X 集合</td></tr><tr><td>NOT IN (…)</td><td>Number does not exist in a list</td><td>col NOT IN (1, 3, 5)</td><td>不在 X 集合</td></tr></tbody></table><h3 id="条件：文本-where"><a href="#条件：文本-where" class="headerlink" title="条件：文本(where)"></a>条件：文本(where)</h3><pre><code>当查找条件col是文本</code></pre><p><code>select * from table where col like &#39;%jin&#39;</code>;</p><table><thead><tr><th>Operator</th><th>Condition</th><th>SQL Example</th><th>解释</th></tr></thead><tbody><tr><td>=</td><td>Case sensitive exact string comparison (notice the single equals)</td><td>col = “abc”</td><td>等于</td></tr><tr><td>!= or &lt;&gt;</td><td>Case sensitive exact string inequality comparison</td><td>col != “abcd”</td><td>不等于</td></tr><tr><td>LIKE</td><td>Case insensitive exact string comparison</td><td>col LIKE “ABC”</td><td>等于</td></tr><tr><td>NOT LIKE</td><td>Case insensitive exact string inequality comparison</td><td>col NOT LIKE “ABCD”</td><td>不等于</td></tr><tr><td>%</td><td>Used anywhere in a string to match a sequence of zero or more characters (only with LIKE or NOT LIKE)</td><td>col LIKE “%AT%” (matches “AT”, “ATTIC”, “CAT” or even “BATS”)</td><td>模糊匹配</td></tr><tr><td>_</td><td>Used anywhere in a string to match a single character (only with LIKE or NOT LIKE)</td><td>col LIKE “AN_” (matches “AND”, but not “AN”)</td><td>模糊匹配单字符</td></tr><tr><td>IN (…)</td><td>String exists in a list</td><td>col IN (“A”, “B”, “C”)</td><td>在集合</td></tr><tr><td>NOT IN (…)</td><td>String does not exist in a list</td><td>co NOT IN (“D”, “E”, “F”)</td><td>不在集合</td></tr></tbody></table><h3 id="排序-rows"><a href="#排序-rows" class="headerlink" title="排序(rows)"></a>排序(rows)</h3><pre><code>需要对结果rows排序和筛选部分rowsselect * from table where col &gt; 1 order by col asc limit 2 offset 2</code></pre><table><thead><tr><th>Operator</th><th>Condition</th><th>SQL Example</th><th>解释</th></tr></thead><tbody><tr><td>ORDER BY</td><td>.</td><td>ORDER BY col ASC/DESC</td><td>按col排序</td></tr><tr><td>ASC</td><td>.</td><td>ORDER BY col ASC/DESC</td><td>升序</td></tr><tr><td>DESC</td><td>.</td><td>ORDER BY col ASC/DESC</td><td>降序</td></tr><tr><td>LIMIT OFFSET</td><td>.</td><td>LIMIT num_limit OFFSET num_offset</td><td>从offset取limit</td></tr><tr><td>ORDER BY</td><td>.</td><td>ORDER BY col1 ASC,col2 DESC</td><td>多列排序</td></tr></tbody></table><h3 id="join-连表-table"><a href="#join-连表-table" class="headerlink" title="join:连表(table)"></a>join:连表(table)</h3><pre><code>当查找的数据在多张关联table里select * from table1 left join table2 on table1.id = table2.id where col &gt; 1</code></pre><table><thead><tr><th>Operator</th><th>Condition</th><th>SQL Example</th><th>解释</th></tr></thead><tbody><tr><td>JOIN .. ON ..</td><td>.</td><td>t1 JOIN t2 ON t1.id = t2.id</td><td>按ID连成1个表</td></tr><tr><td>INNER JOIN</td><td>.</td><td>t1 INNER JOIN t2 ON t1.id = t2.id</td><td>只保留id相等的row</td></tr><tr><td>LEFT JOIN</td><td>.</td><td>t1 LEFT JOIN t2 ON t1.id = t2.id</td><td>保留t1的所有row</td></tr><tr><td>RIGHT JOIN</td><td>.</td><td>t1 RIGHT JOIN t2 ON t1.id = t2.id</td><td>保留t2的所有row</td></tr><tr><td>IS/IS NOT NULL</td><td>.</td><td>col IS/IS NOT NULL</td><td>col是不是为null</td></tr></tbody></table><h3 id="算式-select-where"><a href="#算式-select-where" class="headerlink" title="算式(select / where)"></a>算式(select / where)</h3><pre><code>当需要对select的col 或 where条件的col 经过一定计算后才能使用select *,col*2 from table where col/2 &gt; 1</code></pre><table><thead><tr><th>Operator</th><th>Condition</th><th>SQL Example</th><th>解释</th></tr></thead><tbody><tr><td>+ - * / %</td><td>.</td><td>col1 + col2</td><td>col加减乘除</td></tr><tr><td>substr</td><td>.</td><td>substr(col,0,4)</td><td>字符串截取</td></tr><tr><td>AS</td><td>.</td><td>col * 2 AS col_new</td><td>col取别名</td></tr><tr><td>…</td><td></td><td></td><td>还有很多</td></tr></tbody></table><h3 id="统计（select）"><a href="#统计（select）" class="headerlink" title="统计（select）"></a>统计（select）</h3><pre><code>对查找的rows需要按col分组统计的情况select count(*),avg(col),col from table where col &gt; 1 group by col</code></pre><table><thead><tr><th>Operator</th><th>Condition</th><th>SQL Example</th><th>解释</th></tr></thead><tbody><tr><td>COUNT(*), COUNT(column)</td><td>A common function used to counts the number of rows in the group if no column name is specified. Otherwise, count the number of rows in the group with non-NULL values in the specified column.</td><td>count(col)</td><td>计数</td></tr><tr><td>MIN(column)</td><td>Finds the smallest numerical value in the specified column for all rows in the group.</td><td>min(col)</td><td>最小</td></tr><tr><td>MAX(column)</td><td>Finds the largest numerical value in the specified column for all rows in the group.</td><td>max(col)</td><td>最大</td></tr><tr><td>AVG(column)</td><td>Finds the average numerical value in the specified column for all rows in the group.</td><td>avg(col)</td><td>平均</td></tr><tr><td>SUM(column)</td><td>Finds the sum of all numerical values in the specified column for the rows in the group.</td><td>sum(col)</td><td>求和</td></tr><tr><td>GROUP BY</td><td>.</td><td>group by col,col2</td><td>分组</td></tr><tr><td>HAVING</td><td>.</td><td>HAVING col&gt;100</td><td>分组后条件</td></tr></tbody></table><h3 id="子表-table"><a href="#子表-table" class="headerlink" title="子表 (table)"></a>子表 (table)</h3><pre><code>一次select的结果rows作为下一次select的临时table才能得到最终结果select * from (select * from table where col &gt; 1) as tmp where col &lt; 1</code></pre><table><thead><tr><th>Operator</th><th>Condition</th><th>SQL Example</th><th>解释</th></tr></thead><tbody><tr><td>（select -）as tmp</td><td></td><td>（select -）as tmp</td><td>select结果做子表</td></tr><tr><td>in（select -）</td><td></td><td>in（select -）</td><td>select结果做条件</td></tr><tr><td>avg（select -）</td><td></td><td>avg（select -）</td><td>select结果做条件</td></tr></tbody></table><h1 id="增"><a href="#增" class="headerlink" title="增"></a>增</h1><h2 id="创建和操纵表"><a href="#创建和操纵表" class="headerlink" title="创建和操纵表"></a>创建和操纵表</h2><h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><h4 id="创建表-1"><a href="#创建表-1" class="headerlink" title="创建表"></a>创建表</h4><p>你可以使用 CREATE TABLE 语句。这个语句定义了表的结构，包括列名、数据类型和约束等信息 </p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> 表名 <span class="token punctuation">(</span>    列名<span class="token number">1</span> 数据类型<span class="token number">1</span> 约束<span class="token punctuation">,</span>    列名<span class="token number">2</span> 数据类型<span class="token number">2</span> 约束<span class="token punctuation">,</span>    列名<span class="token number">3</span> 数据类型<span class="token number">3</span> 约束<span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="使用null值"><a href="#使用null值" class="headerlink" title="使用null值"></a>使用null值</h4><blockquote><p>理解NULL 不要把NULL值与空串相混淆。NULL值是没有值，它不是空串。如果指定’’（两个单引号，其间没有字符），这在NOT NULL列中是允许的。空串是一个有效的值，它不是无值。NULL值用关键字NULL而不是空串指定</p></blockquote><h4 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h4><blockquote><p>主键和NULL值 第1章介绍过，主键为其值唯一标识表中每个行的列。主键中只能使用不允许NULL值的列。允许NULL值的列不能作为唯一标识。</p></blockquote><h4 id="AUTO-INCREMENT"><a href="#AUTO-INCREMENT" class="headerlink" title="AUTO_INCREMENT"></a>AUTO_INCREMENT</h4><blockquote><p> 一个列属性，用于自动分配唯一的递增值给该列， 常用于为表的主键列分配唯一标识符 </p></blockquote><p>1.定义 AUTO_INCREMENT：可以在创建表时或者修改表结构时，为某个列指定 AUTO_INCREMENT 属性。一般情况下，这个列通常作为表的主键列。 </p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> 表名 <span class="token punctuation">(</span>    列<span class="token number">1</span> 数据类型 <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>列<span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ol start="2"><li><p>获取 AUTO_INCREMENT 值：插入数据后，你可以使用 <code>LAST_INSERT_ID()</code> 函数来获取最后插入的 AUTO_INCREMENT 值。</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> 表名 <span class="token punctuation">(</span>列<span class="token number">1</span><span class="token punctuation">,</span> 列<span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'value1'</span><span class="token punctuation">,</span> <span class="token string">'value2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> LAST_INSERT_ID<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><p>自定义起始值和步长：使用 <code>AUTO_INCREMENT = value</code> 语句可以设置 AUTO_INCREMENT 列的起始值，并且可以使用 <code>AUTO_INCREMENT = value, INCREMENT BY value</code> 语句设置步长 </p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> 表名 <span class="token keyword">AUTO_INCREMENT</span> <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> 表名 <span class="token keyword">AUTO_INCREMENT</span> <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">,</span> INCREMENT <span class="token keyword">BY</span> <span class="token number">5</span><span class="token punctuation">;</span></code></pre></li></ol><h3 id="更新表之alter、drop"><a href="#更新表之alter、drop" class="headerlink" title="更新表之alter、drop"></a>更新表之alter、drop</h3><h4 id="修改表名"><a href="#修改表名" class="headerlink" title="修改表名"></a>修改表名</h4><pre class=" language-mysql"><code class="language-mysql">ALTER TABLE 旧表名 RENAME TO 新表名;</code></pre><h4 id="修改列字段名"><a href="#修改列字段名" class="headerlink" title="修改列字段名"></a>修改列字段名</h4><pre class=" language-sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> 表名 CHANGE 旧列名 新列名 数据类型<span class="token punctuation">;</span></code></pre><h4 id="增加列字段"><a href="#增加列字段" class="headerlink" title="增加列字段"></a>增加列字段</h4><pre class=" language-sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> 表名 <span class="token keyword">ADD</span> <span class="token keyword">COLUMN</span> 列名 数据类型<span class="token punctuation">;</span></code></pre><h4 id="删除列字段"><a href="#删除列字段" class="headerlink" title="删除列字段"></a>删除列字段</h4><pre class=" language-sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> 表名 <span class="token keyword">DROP</span> <span class="token keyword">COLUMN</span> 列名<span class="token punctuation">;</span></code></pre><h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h3><pre class=" language-sql"><code class="language-sql"><span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> 表名<span class="token punctuation">;</span></code></pre><h3 id="重命名表"><a href="#重命名表" class="headerlink" title="重命名表"></a>重命名表</h3><pre class=" language-sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> 旧表名 <span class="token keyword">RENAME</span> <span class="token keyword">TO</span> 新表名<span class="token punctuation">;</span></code></pre><h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p>要在 MySQL 中插入数据，可以使用 INSERT INTO 语句。以下是插入数据的基本语法： </p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> 表名 <span class="token punctuation">(</span>列<span class="token number">1</span><span class="token punctuation">,</span> 列<span class="token number">2</span><span class="token punctuation">,</span> 列<span class="token number">3</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span>值<span class="token number">1</span><span class="token punctuation">,</span> 值<span class="token number">2</span><span class="token punctuation">,</span> 值<span class="token number">3</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="插入多个行"><a href="#插入多个行" class="headerlink" title="插入多个行"></a>插入多个行</h4><p>  MySQL 中插入多个行数据，可以使用 INSERT INTO 语句，并以 VALUES 子句指定多个值集。每个值集表示一行数据，用括号包围并用逗号分隔。以下是插入多个行数据的基本语法： </p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> 表名 <span class="token punctuation">(</span>列<span class="token number">1</span><span class="token punctuation">,</span> 列<span class="token number">2</span><span class="token punctuation">,</span> 列<span class="token number">3</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token keyword">VALUES</span>    <span class="token punctuation">(</span>值<span class="token number">1</span><span class="token punctuation">,</span> 值<span class="token number">2</span><span class="token punctuation">,</span> 值<span class="token number">3</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span>值<span class="token number">4</span><span class="token punctuation">,</span> 值<span class="token number">5</span><span class="token punctuation">,</span> 值<span class="token number">6</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">(</span>值<span class="token number">7</span><span class="token punctuation">,</span> 值<span class="token number">8</span><span class="token punctuation">,</span> 值<span class="token number">9</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>使用 INSERT INTO … SELECT 语句：可以通过 SELECT 查询语句获取多行数据，并将其插入到目标表中。例如：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> mytable <span class="token punctuation">(</span>column1<span class="token punctuation">,</span> column2<span class="token punctuation">,</span> column3<span class="token punctuation">)</span><span class="token keyword">SELECT</span> column1<span class="token punctuation">,</span> column2<span class="token punctuation">,</span> column3<span class="token keyword">FROM</span> othertable<span class="token keyword">WHERE</span> condition<span class="token punctuation">;</span></code></pre><h4 id="提高insert性能"><a href="#提高insert性能" class="headerlink" title="提高insert性能"></a>提高insert性能</h4><p>MySQL用单条INSERT语句处理多个插入比使用多条INSERT 语句快</p><p>使用这些方法，可以减少与数据库之间的通信次数，从而提高插入操作的性能。此外，考虑到性能，还可以考虑以下因素：</p><ul><li>批量提交（Batch Commit）：将多条 INSERT 语句或多个值集合并在一个事务中，然后一次性提交。这样可以减少事务处理的开销，提高插入性能。</li><li>索引管理：在大批量插入数据之前，暂时禁用索引、触发器等约束，插入完成后再重新启用。这避免了每次插入都触发索引维护，提高了插入性能。</li></ul><h1 id="删"><a href="#删" class="headerlink" title="删"></a>删</h1><h2 id="更新和删除数据"><a href="#更新和删除数据" class="headerlink" title="更新和删除数据"></a>更新和删除数据</h2><h3 id="更新数据之update"><a href="#更新数据之update" class="headerlink" title="更新数据之update"></a>更新数据之update</h3><pre class=" language-sql"><code class="language-sql"><span class="token keyword">UPDATE</span> 表名<span class="token keyword">SET</span> 列<span class="token number">1</span> <span class="token operator">=</span> 值<span class="token number">1</span><span class="token punctuation">,</span> 列<span class="token number">2</span> <span class="token operator">=</span> 值<span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">WHERE</span> 条件<span class="token punctuation">;</span></code></pre><h3 id="删除数据之drop、delete、truncate"><a href="#删除数据之drop、delete、truncate" class="headerlink" title="删除数据之drop、delete、truncate"></a>删除数据之drop、delete、truncate</h3><p> 在 MySQL 中，可以使用 DROP 语句来删除数据库、表或索引。请注意，<strong>DROP 操作是不可逆的</strong>，并且会永久删除目标对象及其关联的数据。  执行 DROP 语句之前请务必备份重要的数据，以防止数据丢失。 </p><h4 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h4><pre class=" language-sql"><code class="language-sql"><span class="token keyword">DROP</span> <span class="token keyword">DATABASE</span> 数据库名<span class="token punctuation">;</span></code></pre><h4 id="删除表-1"><a href="#删除表-1" class="headerlink" title="删除表"></a>删除表</h4><pre class=" language-sql"><code class="language-sql"><span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> 表名<span class="token punctuation">;</span></code></pre><h4 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h4><pre class=" language-sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> 表名<span class="token keyword">DROP</span> <span class="token keyword">INDEX</span> 索引名<span class="token punctuation">;</span></code></pre><h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><p>DELETE 语句删除表中的数据。DELETE 语句用于从表中删除满足指定条件的行。以下是 DELETE 命令的基本语法 </p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">DELETE</span> <span class="token keyword">FROM</span> 表名<span class="token keyword">WHERE</span> 条件<span class="token punctuation">;</span></code></pre><blockquote><p> 需要注意的是，如果不提供 WHERE 子句，则 DELETE 语句将删除表中的所有行。因此，请确保在删除之前仔细检查并设置正确的条件，以防止意外删除数据。 </p></blockquote><p> 如果只是想清空表中的数据而不是删除表本身，可以使用 TRUNCATE TABLE 命令。TRUNCATE TABLE 语句将删除表中的所有数据，但保留表的结构。 </p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">TRUNCATE</span> <span class="token keyword">TABLE</span> 表名<span class="token punctuation">;</span></code></pre><h3 id="更新和删除数据的指导原则"><a href="#更新和删除数据的指导原则" class="headerlink" title="更新和删除数据的指导原则"></a>更新和删除数据的指导原则</h3><p>下面是许多SQL程序员使用UPDATE或DELETE时所遵循的习惯。 </p><p>1除非确实打算更新和删除每一行，否则绝对不要使用不带WHERE子句的UPDATE或DELETE语句。 </p><p>2保证每个表都有主键（如果忘记这个内容，请参阅第15章），尽可能像WHERE子句那样使用它（可以指定各主键、多个值或值的范围）。 </p><p>3在对UPDATE或DELETE语句使用WHERE子句前，应该先用SELECT进行测试，保证它过滤的是正确的记录，以防编写的WHERE子句不正确。 </p><p>4 使用强制实施引用完整性的数据库，这样MySQL将不允许删除具有与其他表相关联的数据的行。</p><h1 id="查"><a href="#查" class="headerlink" title="查"></a>查</h1><h2 id="检索数据之select"><a href="#检索数据之select" class="headerlink" title="检索数据之select"></a>检索数据之select</h2><h3 id="SELECT-命令的基本语法："><a href="#SELECT-命令的基本语法：" class="headerlink" title="SELECT 命令的基本语法："></a>SELECT 命令的基本语法：</h3><p>在 MySQL 中，可以使用 SELECT 语句来检索数据。SELECT 语句用于从表中选择满足指定条件的数据行，并将其返回给用户</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> 列<span class="token number">1</span><span class="token punctuation">,</span> 列<span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">FROM</span> 表名<span class="token keyword">WHERE</span> 条件<span class="token punctuation">;</span></code></pre><h3 id="检索不同的行之distinct"><a href="#检索不同的行之distinct" class="headerlink" title="检索不同的行之distinct"></a>检索不同的行之distinct</h3><p> SELECT DISTINCT 用于从表中选择唯一的、不重复的行数据 </p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token keyword">DISTINCT</span> 列<span class="token number">1</span><span class="token punctuation">,</span> 列<span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">FROM</span> 表名<span class="token keyword">WHERE</span> 条件<span class="token punctuation">;</span></code></pre><h3 id="限制结果之limit"><a href="#限制结果之limit" class="headerlink" title="限制结果之limit"></a>限制结果之limit</h3><p> 要限制 SELECT 语句返回的结果行数，可以使用 LIMIT 子句。LIMIT 子句用于从检索到的数据中选择指定数量的行。以下是 LIMIT 子句的基本语法： </p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> 列<span class="token number">1</span><span class="token punctuation">,</span> 列<span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">FROM</span> 表名<span class="token keyword">WHERE</span> 条件<span class="token keyword">LIMIT</span> 数量<span class="token punctuation">;</span></code></pre><blockquote><p> LIMIT 子句的完整语法是 LIMIT m, n，其中 m 表示起始行的偏移量，n 表示要返回的行数。通过指定起始行和行数，可以实现分页查询或者一次只返回一部分结果；limit m,n:表示从第m+1条开始，取n条数据</p><p> LIMIT 子句可以有两个参数，第一个参数表示要返回的起始行的偏移量，第二个参数表示要返回的行数。例如，LIMIT 5, 10 表示从第6行开始返回 10 行数据。 </p><p> 起始行的偏移量是从 0 开始计数的，而不是从 1 开始。因此，LIMIT 0, 10 将返回前 10 行数据。 </p></blockquote><h3 id="使用完全限定的表名"><a href="#使用完全限定的表名" class="headerlink" title="使用完全限定的表名"></a>使用完全限定的表名</h3><p> 使用完全限定的表名，可以在查询中指定表的完整名称，包括数据库名称和表名称。这在多个数据库或模式中存在同名表时非常有用。以下是在查询中使用完全限定表名的示例： </p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> 列<span class="token number">1</span><span class="token punctuation">,</span> 列<span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">FROM</span> 数据库名<span class="token punctuation">.</span>模式名<span class="token punctuation">.</span>表名<span class="token keyword">WHERE</span> 条件<span class="token keyword">LIMIT</span> m<span class="token punctuation">,</span> n<span class="token punctuation">;</span></code></pre><h2 id="排序检索数据之order-by"><a href="#排序检索数据之order-by" class="headerlink" title="排序检索数据之order by"></a>排序检索数据之order by</h2><h3 id="排序数据"><a href="#排序数据" class="headerlink" title="排序数据"></a>排序数据</h3><p> 对数据进行排序，可以使用 SQL 中的 <code>ORDER BY</code> 子句。<code>ORDER BY</code> 子句允许您根据一个或多个列对查询结果进行排序。以下是在 SQL 查询中使用 <code>ORDER BY</code> 子句的基本语法： </p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> 列<span class="token number">1</span><span class="token punctuation">,</span> 列<span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">FROM</span> 表名<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> 列名 <span class="token punctuation">[</span><span class="token keyword">ASC</span><span class="token operator">|</span><span class="token keyword">DESC</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre><h3 id="按多个列排序"><a href="#按多个列排序" class="headerlink" title="按多个列排序"></a>按多个列排序</h3><p>要对多个列进行排序，您可以在 <code>ORDER BY</code> 子句中指定多个列名，并按照优先级从左到右进行排序。例如： </p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> 列<span class="token number">1</span><span class="token punctuation">,</span> 列<span class="token number">2</span><span class="token keyword">FROM</span> 表名<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> 列<span class="token number">1</span> <span class="token keyword">ASC</span><span class="token punctuation">,</span> 列<span class="token number">2</span> <span class="token keyword">DESC</span><span class="token punctuation">;</span></code></pre><h3 id="指定排序方向"><a href="#指定排序方向" class="headerlink" title="指定排序方向"></a>指定排序方向</h3><p>数据排序不限于升序排序（从A到Z）。这只是默认的排序顺序，还可以使用ORDER BY子句以降序（从Z到A）顺序排序。为了进行降序排序，必须指定DESC关键字。</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> 列<span class="token number">1</span><span class="token punctuation">,</span> 列<span class="token number">2</span><span class="token keyword">FROM</span> 表名<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> 列名 <span class="token keyword">ASC</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">-- 按列名升序排序</span><span class="token keyword">SELECT</span> 列<span class="token number">1</span><span class="token punctuation">,</span> 列<span class="token number">2</span><span class="token keyword">FROM</span> 表名<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> 列名 <span class="token keyword">DESC</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">-- 按列名降序排序</span></code></pre><blockquote><p><strong>区分大小写和排序顺序</strong> 在对文本性的数据进行排序时，A与 a相同吗？a位于B之前还是位于Z之后？这些问题不是理论问题，其答案取决于数据库如何设置。在字典（dictionary）排序顺序中，A被视为与a相同，这是MySQL （和大多数数据库管理系统）的默认行为。但是，许多数据库管理员能够在需要时改变这种行为（如果你的数据库包含大量外语字符，可能必须这样做）。 这里，关键的问题是，如果确实需要改变这种排序顺序，用简单的ORDER BY子句做不到。你必须请求数据库管理员的帮助。</p></blockquote><h2 id="过滤数据"><a href="#过滤数据" class="headerlink" title="过滤数据"></a>过滤数据</h2><h3 id="过滤数据之where"><a href="#过滤数据之where" class="headerlink" title="过滤数据之where"></a>过滤数据之where</h3><p> 在 SQL 查询中使用 <code>WHERE</code> 子句的基本语法： </p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> 列<span class="token number">1</span><span class="token punctuation">,</span> 列<span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">FROM</span> 表名<span class="token keyword">WHERE</span> 条件<span class="token punctuation">;</span></code></pre><p> 可以根据需要使用比较运算符（如 <code>=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>&lt;&gt;</code> 等）和逻辑运算符（如 <code>AND</code>, <code>OR</code>, <code>NOT</code>）来构建更复杂的条件。 还有between from  null等</p><h3 id="数据过滤"><a href="#数据过滤" class="headerlink" title="数据过滤"></a>数据过滤</h3><h4 id="组合WHERE子句"><a href="#组合WHERE子句" class="headerlink" title="组合WHERE子句"></a>组合WHERE子句</h4><p> 使用逻辑运算符（例如 <code>AND</code>、<code>OR</code> 和 <code>NOT</code>）组合多个条件，以创建更复杂的 <code>WHERE</code> 子句。这些逻辑运算符允许您在查询中同时测试多个条件，并根据需要进行组合。 </p><ol><li><p>使用 <code>AND</code> 运算符组合条件：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> 列<span class="token number">1</span><span class="token punctuation">,</span> 列<span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">FROM</span> 表名<span class="token keyword">WHERE</span> 条件<span class="token number">1</span> <span class="token operator">AND</span> 条件<span class="token number">2</span><span class="token punctuation">;</span></code></pre></li><li><p>使用 <code>OR</code> 运算符组合条件 ：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> 列<span class="token number">1</span><span class="token punctuation">,</span> 列<span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">FROM</span> 表名<span class="token keyword">WHERE</span> 条件<span class="token number">1</span> <span class="token operator">OR</span> 条件<span class="token number">2</span><span class="token punctuation">;</span></code></pre></li><li><p>使用 <code>NOT</code> 运算符否定条件 ：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> 列<span class="token number">1</span><span class="token punctuation">,</span> 列<span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">FROM</span> 表名<span class="token keyword">WHERE</span> <span class="token operator">NOT</span> 条件<span class="token punctuation">;</span></code></pre></li><li><p>还可以使用括号 <code>( )</code> 来明确指定运算顺序并进一步组合条件。例如： </p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> 列<span class="token number">1</span><span class="token punctuation">,</span> 列<span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">FROM</span> 表名<span class="token keyword">WHERE</span> <span class="token punctuation">(</span>条件<span class="token number">1</span> <span class="token operator">OR</span> 条件<span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">AND</span> 条件<span class="token number">3</span><span class="token punctuation">;</span></code></pre></li></ol><h4 id="IN操作符"><a href="#IN操作符" class="headerlink" title="IN操作符"></a>IN操作符</h4><p><code>IN</code> 操作符用于指定一个条件，以便从多个可能的值中选择匹配的行。<code>IN</code> 操作符用于简化多个 <code>OR</code> 条件的写法。</p><p>以下是 <code>IN</code> 操作符的基本语法：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> 列<span class="token number">1</span><span class="token punctuation">,</span> 列<span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">FROM</span> 表名<span class="token keyword">WHERE</span> 列名 <span class="token operator">IN</span> <span class="token punctuation">(</span>值<span class="token number">1</span><span class="token punctuation">,</span> 值<span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p> 还可以使用子查询作为 <code>IN</code> 操作符的值列表。例如： </p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> 列<span class="token number">1</span><span class="token punctuation">,</span> 列<span class="token number">2</span><span class="token punctuation">,</span> 列<span class="token number">3</span><span class="token keyword">FROM</span> 表名<span class="token keyword">WHERE</span> 列<span class="token number">1</span> <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> 列              <span class="token keyword">FROM</span> 表              <span class="token keyword">WHERE</span> 条件<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="NOT操作符"><a href="#NOT操作符" class="headerlink" title="NOT操作符"></a>NOT操作符</h4><p><code>NOT</code> 操作符用于否定一个条件，即取条件的反义。它允许您排除不满足指定条件的行。</p><p>以下是 <code>NOT</code> 操作符的基本语法：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> 列<span class="token number">1</span><span class="token punctuation">,</span> 列<span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">FROM</span> 表名<span class="token keyword">WHERE</span> <span class="token operator">NOT</span> 条件<span class="token punctuation">;</span></code></pre><p> 还可以在 <code>NOT</code> 操作符后面使用其他逻辑运算符（如 <code>AND</code> 和 <code>OR</code>）来进一步组合条件。例如： </p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> 列<span class="token number">1</span><span class="token punctuation">,</span> 列<span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">FROM</span> 表名<span class="token keyword">WHERE</span> <span class="token operator">NOT</span> <span class="token punctuation">(</span>条件<span class="token number">1</span> <span class="token operator">AND</span> 条件<span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="通配符过滤"><a href="#通配符过滤" class="headerlink" title="通配符过滤"></a>通配符过滤</h3><h4 id="LIKE操作符"><a href="#LIKE操作符" class="headerlink" title="LIKE操作符"></a>LIKE操作符</h4><p><code>LIKE</code> 操作符用于比较字符串列与模式之间的匹配。它通常与通配符一起使用来进行模糊匹配。</p><p>以下是 <code>LIKE</code> 操作符的基本语法：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> 列<span class="token number">1</span><span class="token punctuation">,</span> 列<span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">FROM</span> 表名<span class="token keyword">WHERE</span> 列名 <span class="token operator">LIKE</span> 模式<span class="token punctuation">;</span></code></pre><blockquote><p><code>LIKE</code> 操作符支持两种通配符：</p><ul><li><code>%</code>：表示匹配任意字符序列（包括空字符序列）。</li><li><code>_</code>：表示匹配任意单个字符。</li></ul></blockquote><h4 id="使用通配符的技巧"><a href="#使用通配符的技巧" class="headerlink" title="使用通配符的技巧"></a>使用通配符的技巧</h4><p>正如所见，MySQL的通配符很有用。但这种功能是有代价的：通配符搜索的处理一般要比前面讨论的其他搜索所花时间更长。这里给出一些使用通配符要记住的技巧。 </p><p>1不要过度使用通配符。如果其他操作符能达到相同的目的，应该使用其他操作符。 </p><p>2 在确实需要使用通配符时，除非绝对有必要，否则不要把它们用在搜索模式的开始处。把通配符置于搜索模式的开始处，搜索起来是最慢的。 </p><p>3仔细注意通配符的位置。如果放错地方，可能不会返回想要的数据。</p><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><h4 id="什么是正则表达式"><a href="#什么是正则表达式" class="headerlink" title="什么是正则表达式"></a>什么是正则表达式</h4><p> 正则表达式（Regular Expression），简称为正则或Regex，是一种用于描述字符串模式的工具。它是一种强大而灵活的文本处理工具，常用于文本匹配、搜索和替换。 </p><p> 正则表达式的使用广泛，几乎所有编程语言都支持正则表达式的操作。它在文本处理、数据验证、数据清理等领域都有很多应用。 </p><p> 以下是一些正则表达式的常见特性和用途： </p><blockquote><ol><li>字符匹配：可以使用普通字符来匹配与之相等的字符。例如，正则表达式 <code>abc</code> 可以匹配字符串中连续的 “abc”。</li><li>字符类（Character classes）：可以使用字符类来匹配一组字符中的任意一个。例如，<code>[abc]</code> 可以匹配字符 “a”、”b” 或 “c”。</li><li>量词（Quantifiers）：可以使用量词来指定前面的字符或字符类重复出现的次数。例如，<code>a{3}</code> 可以匹配连续的三个 “a”。</li><li>转义字符（Escape characters）：可以使用反斜杠 <code>\</code> 来转义特殊字符，使其具有普通字符的含义。例如，<code>\.</code> 可以匹配实际的句点字符 “.”。</li><li>边界匹配（Anchors）：可以使用边界匹配符号来指定字符串的开头和结尾。例如，<code>^abc</code> 匹配以 “abc” 开头的字符串。</li><li>分组和捕获（Grouping and capturing）：可以使用括号来分组正则表达式，并将分组作为单个单元进行处理和捕获结果。</li><li>替换操作：可以使用正则表达式来搜索和替换字符串中与模式匹配的部分。</li></ol></blockquote><p>注意！！！！！！ 正则表达式的语法和特性会因具体的编程语言和工具而有所差异，因此在实际使用时，请参考相关的文档或教程以了解具体的用法和语法规则 </p><h4 id="基本字符匹配regexp"><a href="#基本字符匹配regexp" class="headerlink" title="基本字符匹配regexp"></a>基本字符匹配regexp</h4><p> REGEXP 运算符：REGEXP 运算符用于在 WHERE 子句中进行正则表达式匹配。</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> table_name <span class="token keyword">WHERE</span> column_name <span class="token operator">REGEXP</span> <span class="token string">'pattern'</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">-- 使用正则表达式匹配</span></code></pre><p> LOCATE 函数：LOCATE 函数用于查找一个子字符串在目标字符串中的位置。 </p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> LOCATE<span class="token punctuation">(</span><span class="token string">'sub_string'</span><span class="token punctuation">,</span> <span class="token string">'string_value'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">-- 查找 'sub_string' 在 'string_value' 中的位置</span></code></pre><p>LIKE 运算符使用通配符进行模式匹配，而不是正则表达式。它支持通配符 <code>%</code> 和 <code>_</code>。</p><ul><li><p><code>%</code> 通配符：表示匹配任意字符（包括空字符）的序列，可以出现零次或多次。</p></li><li><p><code>_</code> 通配符：表示匹配任意单个字符。</p></li><li><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> table_name <span class="token keyword">WHERE</span> column_name <span class="token operator">LIKE</span> <span class="token string">'abc%'</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">-- 匹配以 "abc" 开头的字符串</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> table_name <span class="token keyword">WHERE</span> column_name <span class="token operator">LIKE</span> <span class="token string">'%xyz'</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">-- 匹配以 "xyz" 结尾的字符串</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> table_name <span class="token keyword">WHERE</span> column_name <span class="token operator">LIKE</span> <span class="token string">'%def%'</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">-- 匹配包含 "def" 的字符串</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> table_name <span class="token keyword">WHERE</span> column_name <span class="token operator">LIKE</span> <span class="token string">'a_c'</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">-- 匹配第一个字符为 "a"，第三个字符为 "c" 的字符串</span></code></pre></li></ul><p>使用 LIKE 运算符进行模式匹配时，不需要使用特殊的转义字符。</p><blockquote><p>LIKE与REGEXP 在LIKE和REGEXP之间有一个重要的差别</p><p> LIKE 只支持简单的通配符模式匹配，而 REGEXP 支持更复杂的正则表达式模式匹配。 </p><p>，LIKE匹配整个列。如果被匹配的文本在列值 中出现，LIKE将不会找到它，相应的行也不被返回（除非使用 通配符）。而REGEXP在列值内进行匹配，如果被匹配的文本在 列值中出现，REGEXP将会找到它，相应的行将被返回。这是一个非常重要的差别</p></blockquote><h4 id="进行OR匹配"><a href="#进行OR匹配" class="headerlink" title="进行OR匹配"></a>进行OR匹配</h4><p>为搜索两个串之一（或者为这个串，或者为另一个串），使用|，如下所示：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> table_name <span class="token keyword">WHERE</span> column_name <span class="token operator">REGEXP</span> <span class="token string">'pattern1|pattern2'</span><span class="token punctuation">;</span></code></pre><p>使用|从功能上类似于在SELECT语句中使用OR语句，多个OR条件可并入单个正则表达式。</p><blockquote><p>两个以上的OR条件 可以给出两个以上的OR条件。例如，’1000 | 2000 | 3000’将匹配1000或2000或3000。</p></blockquote><h4 id="匹配几个字符之一"><a href="#匹配几个字符之一" class="headerlink" title="匹配几个字符之一"></a>匹配几个字符之一</h4><p>要在正则表达式中匹配几个字符之一，可以使用字符类（Character Class）来实现。字符类用方括号 <code>[]</code> 包围需要匹配的字符，表示匹配其中任意一个字符。</p><p>以下是基本的用法示例：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> table_name <span class="token keyword">WHERE</span> column_name <span class="token operator">REGEXP</span> <span class="token string">'[abc]'</span><span class="token punctuation">;</span></code></pre><p> 还可以通过使用连字符 <code>-</code> 来指定一个字符范围。例如： </p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> table_name <span class="token keyword">WHERE</span> column_name <span class="token operator">REGEXP</span> <span class="token string">'[0-9]'</span><span class="token punctuation">;</span></code></pre><h4 id="匹配范围"><a href="#匹配范围" class="headerlink" title="匹配范围"></a>匹配范围</h4><p> 要匹配一个字符的范围，你可以在正则表达式中使用连字符 <code>-</code> 来表示范围 以下是一些示例：</p><ul><li><code>[a-z]</code>：匹配任何小写字母。</li><li><code>[A-Z]</code>：匹配任何大写字母。</li><li><code>[0-9]</code>：匹配任何数字字符。</li><li><code>[a-zA-Z]</code>：匹配任何字母（大写或小写）。</li><li><code>[a-zA-Z0-9]</code>：匹配任何字母或数字字符。</li></ul><p>你也可以结合多个范围来创建更复杂的匹配规则。例如，如果你想要匹配一个介于 1 到 5 之间的数字，你可以使用 <code>[1-5]</code>。</p><p>以下是一个示例查询，在名为 <code>table_name</code> 的表中查找列 <code>column_name</code> 包含的值是否匹配指定的范围：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> table_name <span class="token keyword">WHERE</span> column_name <span class="token operator">REGEXP</span> <span class="token string">'[1-5]'</span><span class="token punctuation">;</span></code></pre><h4 id="匹配特殊字符"><a href="#匹配特殊字符" class="headerlink" title="匹配特殊字符"></a>匹配特殊字符</h4><p>要在正则表达式中匹配特殊字符，你需要使用反斜杠 <code>\</code> 进行转义。因为一些字符在正则表达式中有特殊的含义，所以需要用反斜杠来转义它们，以表示字面意义。</p><p>以下是一些常见的特殊字符及其转义形式：</p><ul><li><code>.</code>：匹配除换行符外的任意字符，要匹配实际的点号，可以使用 <code>\.</code>。</li><li><code>*</code>：匹配前面的字符零次或多次，要匹配实际的星号，可以使用 <code>\*</code>。</li><li><code>+</code>：匹配前面的字符一次或多次，要匹配实际的加号，可以使用 <code>\+</code>。</li><li><code>?</code>：匹配前面的字符零次或一次，要匹配实际的问号，可以使用 <code>\?</code>。</li><li><code>[</code> 和 <code>]</code>：用于定义字符类，要匹配实际的方括号，可以使用 <code>\[</code> 和 <code>\]</code>。</li><li><code>{</code> 和 <code>}</code>：用于指定重复次数，要匹配实际的花括号，可以使用 <code>\{</code> 和 <code>\}</code>。</li><li><code>(</code> 和 <code>)</code>：用于分组，要匹配实际的圆括号，可以使用 <code>\(</code> 和 <code>\)</code>。</li></ul><p>例如，如果你想要匹配一个字符串中的点号和星号，可以使用以下正则表达式：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> table_name <span class="token keyword">WHERE</span> column_name <span class="token operator">REGEXP</span> <span class="token string">'[.*]'</span><span class="token punctuation">;</span></code></pre><blockquote><p> 注意，在不同的上下文中，特殊字符的转义方式可能会有所不同，所以要根据具体情况使用适当的转义形式。 </p></blockquote><h4 id="匹配字符类"><a href="#匹配字符类" class="headerlink" title="匹配字符类"></a>匹配字符类</h4><p>在正则表达式中，字符类（Character Class）用于匹配一组特定的字符。你可以使用方括号 <code>[]</code> 来定义一个字符类，并在其中列出你想要匹配的字符。</p><p>以下是一些字符类的示例：</p><ul><li><code>[abc]</code>：匹配字符 ‘a’、’b’ 或 ‘c’ 中的任意一个。</li><li><code>[aeiou]</code>：匹配任何一个元音字母（’a’、’e’、’i’、’o’、’u’）。</li><li><code>[0-9]</code>：匹配任何一个数字字符。</li><li><code>[A-Za-z]</code>：匹配任何一个字母（大写或小写）。</li></ul><p>你还可以在字符类中结合使用连字符 <code>-</code> 来指定一个字符范围。例如，<code>[a-z]</code> 表示匹配任何一个小写字母。</p><p>以下是一个示例查询，在名为 <code>table_name</code> 的表中查找列 <code>column_name</code> 包含的值是否匹配指定的字符类：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> table_name <span class="token keyword">WHERE</span> column_name <span class="token operator">REGEXP</span> <span class="token string">'[aeiou]'</span><span class="token punctuation">;</span></code></pre><h4 id="匹配多个实例"><a href="#匹配多个实例" class="headerlink" title="匹配多个实例"></a>匹配多个实例</h4><p>如果你想要匹配多个实例（即重复出现）的特定模式，你可以使用量词（Quantifier）来指定重复的次数。</p><p>以下是一些常用的量词：</p><ul><li><code>*</code>：匹配前面的模式零次或多次。</li><li><code>+</code>：匹配前面的模式一次或多次。</li><li><code>?</code>：匹配前面的模式零次或一次。</li><li><code>{n}</code>：精确匹配前面的模式出现 n 次。</li><li><code>{n,}</code>：匹配前面的模式至少出现 n 次。</li><li><code>{n,m}</code>：匹配前面的模式出现 n 到 m 次。</li></ul><p>例如，如果你想要匹配一个字符串中的连续数字（至少一位数字），可以使用以下正则表达式：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> table_name <span class="token keyword">WHERE</span> column_name <span class="token operator">REGEXP</span> <span class="token string">'[0-9]+'</span><span class="token punctuation">;</span></code></pre><h4 id="定位符"><a href="#定位符" class="headerlink" title="定位符"></a>定位符</h4><p>在正则表达式中，定位符（Anchors）用于指定模式的位置，而不是字符本身。它们帮助我们匹配字符串的特定位置。</p><p>以下是一些常用的定位符：</p><ul><li><code>^</code>：匹配字符串的开头。例如，<code>^abc</code> 可以匹配以 “abc” 开头的字符串。</li><li><code>$</code>：匹配字符串的结尾。例如，<code>xyz$</code> 可以匹配以 “xyz” 结尾的字符串。</li><li><code>\b</code>：匹配单词的边界。例如，<code>\bword\b</code> 可以匹配独立的单词 “word”，而不会匹配包含它的单词。</li><li><code>\B</code>：匹配非单词的边界。例如，<code>\Bing\B</code> 可以匹配字符串中不是单独单词的 “ing”。</li></ul><p>以下是一个示例查询，在名为 <code>table_name</code> 的表中查找列 <code>column_name</code> 中以 “abc” 结尾的值：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> table_name <span class="token keyword">WHERE</span> column_name <span class="token operator">REGEXP</span> <span class="token string">'abc$'</span><span class="token punctuation">;</span></code></pre><h2 id="汇总数据"><a href="#汇总数据" class="headerlink" title="汇总数据"></a>汇总数据</h2><h3 id="聚集函数"><a href="#聚集函数" class="headerlink" title="聚集函数"></a>聚集函数</h3><p>聚集函数（Aggregate Functions）是用于对数据库表中的数据进行聚合计算的函数。它们将多个行的值汇总为单个结果，并返回计算后的结果。</p><p>以下是一些常见的聚集函数：</p><ul><li><code>COUNT()</code>：用于计算指定列中的行数，可以使用 <code>COUNT(*)</code> 计算所有行的数目。</li><li><code>SUM()</code>：用于计算指定列中数值类型的总和。</li><li><code>AVG()</code>：用于计算指定列中数值类型的平均值。</li><li><code>MIN()</code>：用于找到指定列中的最小值。</li><li><code>MAX()</code>：用于找到指定列中的最大值。</li></ul><p>这些聚集函数可以与 SQL 查询语句中的 <code>SELECT</code> 和 <code>GROUP BY</code> 子句一起使用，以便根据特定条件对数据进行聚合计算。</p><p>以下是一个示例查询，使用 <code>SUM()</code> 函数计算名为 <code>sales</code> 的表中的销售总额：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token function">SUM</span><span class="token punctuation">(</span>amount<span class="token punctuation">)</span> <span class="token keyword">as</span> total_sales <span class="token keyword">FROM</span> sales<span class="token punctuation">;</span></code></pre><h3 id="聚集不同值"><a href="#聚集不同值" class="headerlink" title="聚集不同值"></a>聚集不同值</h3><p>想对数据库表中的某一列进行聚集并计算其不同值的数量，你可以使用 <code>COUNT(DISTINCT)</code> 函数。<code>COUNT(DISTINCT)</code> 函数用于计算指定列中不重复值的数量。</p><p>以下是一个示例查询，使用 <code>COUNT(DISTINCT)</code> 函数计算名为 <code>products</code> 的表中不同产品的数量：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token keyword">DISTINCT</span> product_name<span class="token punctuation">)</span> <span class="token keyword">as</span> distinct_products <span class="token keyword">FROM</span> products<span class="token punctuation">;</span></code></pre><h3 id="组合聚集函数"><a href="#组合聚集函数" class="headerlink" title="组合聚集函数"></a>组合聚集函数</h3><p>组合多个聚合函数来按照不同的方式对数据进行计算和汇总。这样可以得到更详细和灵活的结果。</p><p>以下是一些示例组合聚合函数的情况：</p><ol><li><p>计算销售表中不同产品的总销售额和平均销售额：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> product_name<span class="token punctuation">,</span> <span class="token function">SUM</span><span class="token punctuation">(</span>amount<span class="token punctuation">)</span> <span class="token keyword">as</span> total_sales<span class="token punctuation">,</span> <span class="token function">AVG</span><span class="token punctuation">(</span>amount<span class="token punctuation">)</span> <span class="token keyword">as</span> average_sales<span class="token keyword">FROM</span> sales<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> product_name<span class="token punctuation">;</span></code></pre><p> 上述查询将根据产品名称分组，计算每个产品的总销售额和平均销售额。 </p></li><li><p>找到订单表中销售额最高和最低的产品：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token function">MAX</span><span class="token punctuation">(</span>amount<span class="token punctuation">)</span> <span class="token keyword">as</span> max_sales<span class="token punctuation">,</span> <span class="token function">MIN</span><span class="token punctuation">(</span>amount<span class="token punctuation">)</span> <span class="token keyword">as</span> min_sales<span class="token keyword">FROM</span> orders<span class="token punctuation">;</span></code></pre><p> 上述查询将计算订单表中的最高销售额和最低销售额。 </p></li><li><p>计算某一时间范围内销售表中不同产品的总销售额：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> product_name<span class="token punctuation">,</span> <span class="token function">SUM</span><span class="token punctuation">(</span>amount<span class="token punctuation">)</span> <span class="token keyword">as</span> total_sales<span class="token keyword">FROM</span> sales<span class="token keyword">WHERE</span> sale_date <span class="token operator">BETWEEN</span> <span class="token string">'2023-01-01'</span> <span class="token operator">AND</span> <span class="token string">'2023-12-31'</span><span class="token keyword">GROUP</span> <span class="token keyword">BY</span> product_name<span class="token punctuation">;</span></code></pre><p> 上述查询将根据指定的时间范围内的销售数据，计算每个产品的总销售额。 </p></li></ol><blockquote><p><strong>取别名</strong> 在指定别名以包含某个聚集函数的结果时，不应该使 用表中实际的列名。虽然这样做并非不合法，但使用唯一的名字会使你的SQL更易于理解和使用（以及将来容易排除故障）。</p></blockquote><h2 id="分组数据"><a href="#分组数据" class="headerlink" title="分组数据"></a>分组数据</h2><h3 id="数据分组之group-by"><a href="#数据分组之group-by" class="headerlink" title="数据分组之group by"></a>数据分组之group by</h3><p>数据分组是在 SQL 查询中使用 <code>GROUP BY</code> 子句对数据进行分组的过程。通过数据分组，你可以根据一个或多个列的值将数据划分为不同的组，并对每个组应用聚合函数来计算汇总结果。</p><p>以下是一个基本的数据分组示例：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> column1<span class="token punctuation">,</span> column2<span class="token punctuation">,</span> aggregate_function<span class="token punctuation">(</span>column3<span class="token punctuation">)</span><span class="token keyword">FROM</span> <span class="token keyword">table</span><span class="token keyword">GROUP</span> <span class="token keyword">BY</span> column1<span class="token punctuation">,</span> column2<span class="token punctuation">;</span></code></pre><h3 id="过滤分组之having"><a href="#过滤分组之having" class="headerlink" title="过滤分组之having"></a>过滤分组之having</h3><blockquote><p>HAVING支持所有WHERE操作符</p></blockquote><p><code>HAVING</code> 子句用于在对数据进行分组后，对分组结果进行过滤。<code>HAVING</code> 子句中的条件是应用于聚合函数的结果。</p><p>以下是一些关于 <code>HAVING</code> 子句的使用示例：</p><ol><li><p>筛选出销售额总和大于 1000 的产品组：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> product_name<span class="token punctuation">,</span> <span class="token function">SUM</span><span class="token punctuation">(</span>amount<span class="token punctuation">)</span> <span class="token keyword">as</span> total_sales<span class="token keyword">FROM</span> sales<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> product_name<span class="token keyword">HAVING</span> total_sales <span class="token operator">></span> <span class="token number">1000</span><span class="token punctuation">;</span></code></pre><p> 上述查询根据产品名称对销售数据进行分组，并计算每个组的销售额总和。<code>HAVING</code> 子句筛选出销售额总和大于 1000 的产品组。 </p></li><li><p>筛选出订单数量超过平均订单数的销售代表组：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> sales_rep<span class="token punctuation">,</span> <span class="token function">COUNT</span><span class="token punctuation">(</span>order_id<span class="token punctuation">)</span> <span class="token keyword">as</span> orders_count<span class="token keyword">FROM</span> orders<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> sales_rep<span class="token keyword">HAVING</span> <span class="token function">COUNT</span><span class="token punctuation">(</span>order_id<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token function">AVG</span><span class="token punctuation">(</span>orders_count<span class="token punctuation">)</span> <span class="token keyword">FROM</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token function">COUNT</span><span class="token punctuation">(</span>order_id<span class="token punctuation">)</span> <span class="token keyword">as</span> orders_count <span class="token keyword">FROM</span> orders <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> sales_rep<span class="token punctuation">)</span> <span class="token keyword">as</span> subquery<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>上述查询根据销售代表对订单进行分组，并计算每个组的订单数量。<code>HAVING</code> 子句使用子查询来比较订单数量是否超过平均订单数。 </p></li></ol><blockquote><p> 请注意，<code>HAVING</code> 子句必须在 <code>GROUP BY</code> 子句之后使用，用于对分组后的结果进行过滤。如果需要对原始数据进行过滤，请使用 <code>WHERE</code> 子句。 </p></blockquote><h3 id="分组和排序"><a href="#分组和排序" class="headerlink" title="分组和排序"></a>分组和排序</h3><p>​                                                                    ORDER BY与GROUP BY的差别</p><table><thead><tr><th>ORDER BY</th><th>GROUP BY</th></tr></thead><tbody><tr><td>排序产生的输出</td><td>分组行。但输出可能不是分组的顺序</td></tr><tr><td>任意列都可以使用（甚至非选择的列也可以使用）</td><td>只可能使用选择列或表达式列，而且必须使用每个选择列表达式</td></tr><tr><td>不一定需要</td><td>如果与聚集函数一起使用列（或表达式），则必须使用</td></tr></tbody></table><h2 id="复杂查询"><a href="#复杂查询" class="headerlink" title="复杂查询"></a>复杂查询</h2><h3 id="使用子查询"><a href="#使用子查询" class="headerlink" title="使用子查询"></a>使用子查询</h3><h4 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h4><p>子查询是指在 SQL 查询中嵌套使用的内部查询。子查询在外部查询的条件、选择列表或其他子句中使用，允许我们从嵌套的查询中检索数据并将其用作外部查询的一部分 </p><p> 子查询可以用于以下几个方面： </p><ol><li><p>在 <code>WHERE</code> 子句中使用子查询进行过滤：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> column1<span class="token punctuation">,</span> column2<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">FROM</span> <span class="token keyword">table</span><span class="token keyword">WHERE</span> column1 <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> column1 <span class="token keyword">FROM</span> another_table <span class="token keyword">WHERE</span> condition<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p> 上述查询中，子查询 <code>(SELECT column1 FROM another_table WHERE condition)</code> 用于选择满足特定条件的值，然后外部查询根据这些值对数据进行筛选 </p></li><li><p>在 <code>SELECT</code> 子句中使用子查询获取计算结果：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> column1<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">FROM</span> another_table<span class="token punctuation">)</span> <span class="token keyword">AS</span> total_rows<span class="token keyword">FROM</span> <span class="token keyword">table</span><span class="token punctuation">;</span></code></pre><p> 上述查询中，子查询 <code>(SELECT COUNT(*) FROM another_table)</code> 用于获取 <code>another_table</code> 中的行数，并将其作为别名为 <code>total_rows</code> 的计算结果返回到外部查询中。 </p></li><li><p>在 <code>FROM</code> 子句中使用子查询作为临时表：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> column1<span class="token punctuation">,</span> column2<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">FROM</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> column1<span class="token punctuation">,</span> column2 <span class="token keyword">FROM</span> table1 <span class="token keyword">UNION</span> <span class="token keyword">SELECT</span> column1<span class="token punctuation">,</span> column2 <span class="token keyword">FROM</span> table2<span class="token punctuation">)</span> <span class="token keyword">AS</span> temp_table<span class="token punctuation">;</span></code></pre><p> 上述查询中，子查询 <code>(SELECT column1, column2 FROM table1 UNION SELECT column1, column2 FROM table2)</code> 将两个表的数据组合起来，并将其作为临时表 <code>temp_table</code> 在外部查询中使用。 </p></li></ol><h4 id="利用子查询进行过滤"><a href="#利用子查询进行过滤" class="headerlink" title="利用子查询进行过滤"></a>利用子查询进行过滤</h4><p>利用子查询进行过滤是一种常见的使用场景，可以根据内部查询的结果来筛选外部查询的数据。下面是一些示例：</p><ol><li>使用子查询筛选符合条件的数据：</li></ol><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> column1<span class="token punctuation">,</span> column2<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">FROM</span> <span class="token keyword">table</span><span class="token keyword">WHERE</span> column1 <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> column1 <span class="token keyword">FROM</span> another_table <span class="token keyword">WHERE</span> condition<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>上述查询中，子查询 <code>(SELECT column1 FROM another_table WHERE condition)</code> 返回满足特定条件的值，并将这些值用于外部查询中的 <code>WHERE</code> 子句，以筛选表 <code>table</code> 的数据。</p><ol start="2"><li>使用子查询排除符合条件的数据：</li></ol><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> column1<span class="token punctuation">,</span> column2<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">FROM</span> <span class="token keyword">table</span><span class="token keyword">WHERE</span> column1 <span class="token operator">NOT</span> <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> column1 <span class="token keyword">FROM</span> another_table <span class="token keyword">WHERE</span> condition<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>上述查询中，子查询 <code>(SELECT column1 FROM another_table WHERE condition)</code> 返回满足特定条件的值，并将这些值用于外部查询中的 <code>WHERE</code> 子句的 <code>NOT IN</code> 条件，以排除表 <code>table</code> 中包含这些值的数据。</p><ol start="3"><li>使用子查询进行范围过滤：</li></ol><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> column1<span class="token punctuation">,</span> column2<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">FROM</span> <span class="token keyword">table</span><span class="token keyword">WHERE</span> column1 <span class="token operator">></span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token function">AVG</span><span class="token punctuation">(</span>column1<span class="token punctuation">)</span> <span class="token keyword">FROM</span> another_table<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>上述查询中，子查询 <code>(SELECT AVG(column1) FROM another_table)</code> 返回列 <code>column1</code> 的平均值，并将其用于外部查询中的 <code>WHERE</code> 子句，以筛选出表 <code>table</code> 中大于平均值的数据。</p><h4 id="使用子查询作为计算字段"><a href="#使用子查询作为计算字段" class="headerlink" title="使用子查询作为计算字段"></a>使用子查询作为计算字段</h4><p>使用子查询作为计算字段是一种常见的用法，可以在查询结果中包含根据子查询计算得到的额外信息。下面是一个示例：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> column1<span class="token punctuation">,</span> column2<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">FROM</span> another_table<span class="token punctuation">)</span> <span class="token keyword">AS</span> total_rows<span class="token keyword">FROM</span> <span class="token keyword">table</span><span class="token punctuation">;</span></code></pre><p>上述查询中，子查询 <code>(SELECT COUNT(*) FROM another_table)</code> 用于获取表 <code>another_table</code> 中的行数，并将其作为计算字段 <code>total_rows</code> 包含在查询结果中。这样，查询结果就会返回每一行数据的 <code>column1</code>、<code>column2</code> 字段值，以及额外的计算字段 <code>total_rows</code>。</p><blockquote><p>子查询作为计算字段必须只返回单个值。如果子查询返回了多个值，将会引发错误。</p></blockquote><h3 id="组合查询"><a href="#组合查询" class="headerlink" title="组合查询"></a>组合查询</h3><h4 id="组合查询-1"><a href="#组合查询-1" class="headerlink" title="组合查询"></a>组合查询</h4><p>多数SQL查询都只包含从一个或多个表中返回数据的单条SELECT语句。MySQL也允许执行多个查询（多条SELECT语句），并将结果作为单个查询结果集返回。这些组合查询通常称为并（union）或复合查询（compound query）。</p><h4 id="创建组合查询union"><a href="#创建组合查询union" class="headerlink" title="创建组合查询union"></a>创建组合查询union</h4><p>要创建组合查询，可以使用 UNION、INTERSECT 或 EXCEPT 运算符来合并多个查询的结果集。下面是一个示例：</p><ol><li>使用 UNION 运算符合并查询结果：</li></ol><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> column1<span class="token punctuation">,</span> column2 <span class="token keyword">FROM</span> table1<span class="token keyword">UNION</span><span class="token keyword">SELECT</span> column1<span class="token punctuation">,</span> column2 <span class="token keyword">FROM</span> table2<span class="token punctuation">;</span></code></pre><p>上述查询将从表 <code>table1</code> 和 <code>table2</code> 中选择 <code>column1</code> 和 <code>column2</code> 字段的结果，并将两个结果集合并在一起。如果有重复的行，将只返回一次。</p><ol start="2"><li>使用 INTERSECT 运算符获取查询结果的交集：</li></ol><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> column1<span class="token punctuation">,</span> column2 <span class="token keyword">FROM</span> table1<span class="token keyword">INTERSECT</span><span class="token keyword">SELECT</span> column1<span class="token punctuation">,</span> column2 <span class="token keyword">FROM</span> table2<span class="token punctuation">;</span></code></pre><p>上述查询将返回同时在表 <code>table1</code> 和 <code>table2</code> 中存在的行，且只包含 <code>column1</code> 和 <code>column2</code> 字段。</p><ol start="3"><li>使用 EXCEPT 运算符排除一个查询结果中存在的行：</li></ol><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> column1<span class="token punctuation">,</span> column2 <span class="token keyword">FROM</span> table1<span class="token keyword">EXCEPT</span><span class="token keyword">SELECT</span> column1<span class="token punctuation">,</span> column2 <span class="token keyword">FROM</span> table2<span class="token punctuation">;</span></code></pre><p>上述查询将从表 <code>table1</code> 中选择 <code>column1</code> 和 <code>column2</code> 字段的结果，排除在表 <code>table2</code> 中存在的行。</p><blockquote><p>注意，在使用这些运算符时，两个结果集的列数和列的数据类型必须相同。</p></blockquote><h4 id="UNION规则"><a href="#UNION规则" class="headerlink" title="UNION规则"></a>UNION规则</h4><p>当使用 UNION 运算符合并多个查询结果时，需要遵循以下规则：</p><ol><li><p>结果集的列数必须相同：所有查询语句中选择的列数必须一致。如果列数不匹配，则会导致错误。</p></li><li><p>列的数据类型必须兼容：相应位置上的列数据类型必须是兼容的，否则会导致错误。例如，数字列和字符串列不能直接相加，因此它们的数据类型不兼容。</p></li><li><p>结果集的列顺序必须一致：每个 SELECT 语句中选择的列的顺序必须相同，否则将导致结果集中的列顺序混乱。</p></li><li><p>去除重复行：UNION 运算符默认会去除结果集中的重复行。如果想保留重复行，可以使用 UNION ALL 运算符。</p></li></ol><p>示例：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> column1<span class="token punctuation">,</span> column2 <span class="token keyword">FROM</span> table1<span class="token keyword">UNION</span><span class="token keyword">SELECT</span> column1<span class="token punctuation">,</span> column2 <span class="token keyword">FROM</span> table2<span class="token punctuation">;</span></code></pre><p>上述查询将从表 <code>table1</code> 和 <code>table2</code> 中选择 <code>column1</code> 和 <code>column2</code> 字段的结果，合并为一个结果集，并去除重复行。</p><p>总之，使用 UNION 运算符时，要确保查询语句的列数、列的数据类型和列顺序都一致，以及根据需要决定是否去除重复行。</p><h4 id="包含或取消重复的行"><a href="#包含或取消重复的行" class="headerlink" title="包含或取消重复的行"></a>包含或取消重复的行</h4><p>要在组合查询中包含或取消重复的行，可以使用 UNION ALL 运算符或 DISTINCT 关键字。</p><ol><li>使用 UNION ALL 运算符：这个运算符会将所有查询的结果集合并在一起，并保留所有的行，包括重复的行。</li></ol><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> column1<span class="token punctuation">,</span> column2 <span class="token keyword">FROM</span> table1<span class="token keyword">UNION</span> <span class="token keyword">ALL</span><span class="token keyword">SELECT</span> column1<span class="token punctuation">,</span> column2 <span class="token keyword">FROM</span> table2<span class="token punctuation">;</span></code></pre><p>上述查询将从表 <code>table1</code> 和 <code>table2</code> 中选择 <code>column1</code> 和 <code>column2</code> 字段的结果，合并为一个结果集，并保留重复的行。</p><ol start="2"><li>使用 DISTINCT 关键字：这个关键字用于消除结果集中的重复行。</li></ol><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token keyword">DISTINCT</span> column1<span class="token punctuation">,</span> column2 <span class="token keyword">FROM</span> <span class="token keyword">table</span><span class="token punctuation">;</span></code></pre><p>上述查询将从表 <code>table</code> 中选择 <code>column1</code> 和 <code>column2</code> 字段的结果，并且只返回不重复的行。</p><blockquote><p>UNION ALL 可以更快地执行，因为它不涉及去重的操作。而使用 DISTINCT 会对结果进行去重处理，可能会导致一些性能开销。</p></blockquote><h4 id="对组合结果进行排序"><a href="#对组合结果进行排序" class="headerlink" title="对组合结果进行排序"></a>对组合结果进行排序</h4><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> column1<span class="token punctuation">,</span> column2 <span class="token keyword">FROM</span> table1<span class="token keyword">UNION</span><span class="token keyword">SELECT</span> column1<span class="token punctuation">,</span> column2 <span class="token keyword">FROM</span> table2<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> column1 <span class="token keyword">ASC</span><span class="token operator">/</span><span class="token keyword">DESC</span><span class="token punctuation">;</span></code></pre><h2 id="计算字段"><a href="#计算字段" class="headerlink" title="计算字段"></a>计算字段</h2><h3 id="创建字段"><a href="#创建字段" class="headerlink" title="创建字段"></a>创建字段</h3><h4 id="计算字段-1"><a href="#计算字段-1" class="headerlink" title="计算字段"></a>计算字段</h4><p>计算字段是在 SELECT 语句中使用表达式或函数来计算出的一个新字段。它不是数据库表中的实际列，而是在查询结果中动态生成的。以下是几个常见的计算字段示例：</p><ol><li>使用表达式计算字段：</li></ol><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> column1<span class="token punctuation">,</span> column2<span class="token punctuation">,</span> column3<span class="token punctuation">,</span> <span class="token punctuation">(</span>column1 <span class="token operator">+</span> column2<span class="token punctuation">)</span> <span class="token keyword">AS</span> sum <span class="token keyword">FROM</span> <span class="token keyword">table</span><span class="token punctuation">;</span></code></pre><p>上述查询中，<code>(column1 + column2)</code> 表达式计算出了一个名为 <code>sum</code> 的计算字段，表示 <code>column1</code> 和 <code>column2</code> 列的和。</p><ol start="2"><li>使用函数计算字段：</li></ol><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> column1<span class="token punctuation">,</span> column2<span class="token punctuation">,</span> column3<span class="token punctuation">,</span> UPPER<span class="token punctuation">(</span>column1<span class="token punctuation">)</span> <span class="token keyword">AS</span> uppercase <span class="token keyword">FROM</span> <span class="token keyword">table</span><span class="token punctuation">;</span></code></pre><p>上述查询中，<code>UPPER(column1)</code> 函数将 <code>column1</code> 列的值转换为大写，并创建了一个名为 <code>uppercase</code> 的计算字段。</p><ol start="3"><li>使用条件判断计算字段：</li></ol><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> column1<span class="token punctuation">,</span> column2<span class="token punctuation">,</span> column3<span class="token punctuation">,</span> <span class="token keyword">CASE</span> <span class="token keyword">WHEN</span> column1 <span class="token operator">></span> column2 <span class="token keyword">THEN</span> <span class="token string">'Greater'</span> <span class="token keyword">ELSE</span> <span class="token string">'Less or equal'</span> <span class="token keyword">END</span> <span class="token keyword">AS</span> comparison <span class="token keyword">FROM</span> <span class="token keyword">table</span><span class="token punctuation">;</span></code></pre><p>上述查询中，使用 CASE 表达式根据条件判断创建了一个名为 <code>comparison</code> 的计算字段，如果 <code>column1</code> 大于 <code>column2</code>，则为 ‘Greater’，否则为 ‘Less or equal’。</p><blockquote><p>使用计算字段时，你可以给该字段起一个别名（AS 别名），以便在结果中显示更友好的列名。</p></blockquote><h4 id="拼接字段"><a href="#拼接字段" class="headerlink" title="拼接字段"></a>拼接字段</h4><p>在查询中，可以使用 CONCAT 函数来拼接字段。 CONCAT 函数可以将多个字段或字符串连接在一起形成一个新的字符串。</p><p>以下是几个示例：</p><ol><li>拼接两个字段：</li></ol><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> column1<span class="token punctuation">,</span> column2<span class="token punctuation">,</span> CONCAT<span class="token punctuation">(</span>column1<span class="token punctuation">,</span> column2<span class="token punctuation">)</span> <span class="token keyword">AS</span> concatenated <span class="token keyword">FROM</span> <span class="token keyword">table</span><span class="token punctuation">;</span></code></pre><p>上述查询中，<code>CONCAT(column1, column2)</code> 将 <code>column1</code> 和 <code>column2</code> 的值拼接在一起，并创建一个名为 <code>concatenated</code> 的计算字段。</p><ol start="2"><li>拼接字段和字符串：</li></ol><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> column1<span class="token punctuation">,</span> column2<span class="token punctuation">,</span> CONCAT<span class="token punctuation">(</span>column1<span class="token punctuation">,</span> <span class="token string">' is the value of column1'</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> result <span class="token keyword">FROM</span> <span class="token keyword">table</span><span class="token punctuation">;</span></code></pre><p>上述查询中，<code>CONCAT(column1, &#39; is the value of column1&#39;)</code> 将 <code>column1</code> 的值和一个字符串拼接在一起，并创建一个名为 <code>result</code> 的计算字段。</p><ol start="3"><li>拼接多个字段和字符串：</li></ol><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> column1<span class="token punctuation">,</span> column2<span class="token punctuation">,</span> CONCAT<span class="token punctuation">(</span>column1<span class="token punctuation">,</span> <span class="token string">' - '</span><span class="token punctuation">,</span> column2<span class="token punctuation">,</span> <span class="token string">' - '</span><span class="token punctuation">,</span> column3<span class="token punctuation">)</span> <span class="token keyword">AS</span> combined <span class="token keyword">FROM</span> <span class="token keyword">table</span><span class="token punctuation">;</span></code></pre><p>上述查询中，<code>CONCAT(column1, &#39; - &#39;, column2, &#39; - &#39;, column3)</code> 将 <code>column1</code>、<code>column2</code> 和 <code>column3</code> 的值以及一些字符串连接在一起，并创建一个名为 <code>combined</code> 的计算字段。</p><h4 id="执行算术计算"><a href="#执行算术计算" class="headerlink" title="执行算术计算"></a>执行算术计算</h4><p>在 SQL 查询中，可以使用内置的数学函数来执行算术计算。下面是几个常用的数学函数示例：</p><ol><li>加法：</li></ol><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> column1<span class="token punctuation">,</span> column2<span class="token punctuation">,</span> <span class="token punctuation">(</span>column1 <span class="token operator">+</span> column2<span class="token punctuation">)</span> <span class="token keyword">AS</span> sum <span class="token keyword">FROM</span> <span class="token keyword">table</span><span class="token punctuation">;</span></code></pre><p>上述查询中，<code>(column1 + column2)</code> 执行了列 <code>column1</code> 和 <code>column2</code> 的加法操作，并创建了一个名为 <code>sum</code> 的计算字段。</p><ol start="2"><li>减法：</li></ol><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> column1<span class="token punctuation">,</span> column2<span class="token punctuation">,</span> <span class="token punctuation">(</span>column1 <span class="token operator">-</span> column2<span class="token punctuation">)</span> <span class="token keyword">AS</span> difference <span class="token keyword">FROM</span> <span class="token keyword">table</span><span class="token punctuation">;</span></code></pre><p>上述查询中，<code>(column1 - column2)</code> 执行了列 <code>column1</code> 减去 <code>column2</code> 的操作，并创建了一个名为 <code>difference</code> 的计算字段。</p><ol start="3"><li>乘法：</li></ol><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> column1<span class="token punctuation">,</span> column2<span class="token punctuation">,</span> <span class="token punctuation">(</span>column1 <span class="token operator">*</span> column2<span class="token punctuation">)</span> <span class="token keyword">AS</span> product <span class="token keyword">FROM</span> <span class="token keyword">table</span><span class="token punctuation">;</span></code></pre><p>上述查询中，<code>(column1 * column2)</code> 执行了列 <code>column1</code> 和 <code>column2</code> 的乘法操作，并创建了一个名为 <code>product</code> 的计算字段。</p><ol start="4"><li>除法：</li></ol><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> column1<span class="token punctuation">,</span> column2<span class="token punctuation">,</span> <span class="token punctuation">(</span>column1 <span class="token operator">/</span> column2<span class="token punctuation">)</span> <span class="token keyword">AS</span> quotient <span class="token keyword">FROM</span> <span class="token keyword">table</span><span class="token punctuation">;</span></code></pre><p>上述查询中，<code>(column1 / column2)</code> 执行了列 <code>column1</code> 除以 <code>column2</code> 的操作，并创建了一个名为 <code>quotient</code> 的计算字段。</p><h3 id="使用数据处理函数"><a href="#使用数据处理函数" class="headerlink" title="使用数据处理函数"></a>使用数据处理函数</h3><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>与其他大多数计算机语言一样，SQL支持利用函数来处理数据。函数一般是在数据上执行的，它给数据的转换和处理提供了方便。</p><h4 id="使用函数"><a href="#使用函数" class="headerlink" title="使用函数"></a>使用函数</h4><p>在 SQL 查询中，可以使用各种数据处理函数来处理数据。以下是几个常用的数据处理函数示例：</p><ol><li>字符串处理函数：</li></ol><ul><li>UPPER：将字符串转换为大写。</li><li>LOWER：将字符串转换为小写。</li><li>LENGTH：返回字符串的长度。</li><li>SUBSTRING：提取字符串的子串。</li></ul><p>例如：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> UPPER<span class="token punctuation">(</span><span class="token keyword">column</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> uppercase<span class="token punctuation">,</span> LOWER<span class="token punctuation">(</span><span class="token keyword">column</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> lowercase<span class="token punctuation">,</span> LENGTH<span class="token punctuation">(</span><span class="token keyword">column</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> length<span class="token punctuation">,</span> SUBSTRING<span class="token punctuation">(</span><span class="token keyword">column</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> substring <span class="token keyword">FROM</span> <span class="token keyword">table</span><span class="token punctuation">;</span></code></pre><ol start="2"><li>数值处理函数：</li></ol><ul><li>ROUND：将数值四舍五入到指定精度。</li><li>CEILING：将数值向上取整。</li><li>FLOOR：将数值向下取整。</li><li>ABS：返回数值的绝对值。</li></ul><p>例如：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token function">ROUND</span><span class="token punctuation">(</span><span class="token keyword">column</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> rounded<span class="token punctuation">,</span> CEILING<span class="token punctuation">(</span><span class="token keyword">column</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> ceiling<span class="token punctuation">,</span> FLOOR<span class="token punctuation">(</span><span class="token keyword">column</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> floor<span class="token punctuation">,</span> ABS<span class="token punctuation">(</span><span class="token keyword">column</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> absolute <span class="token keyword">FROM</span> <span class="token keyword">table</span><span class="token punctuation">;</span></code></pre><ol start="3"><li>日期和时间处理函数：</li></ol><ul><li>DATEPART：提取日期或时间部分（年、月、日、小时、分钟等）的值。</li><li>DATEADD：根据指定的日期或时间间隔添加或减去值。</li><li>DATEDIFF：计算两个日期之间的差异。</li></ul><p>例如：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> DATEPART<span class="token punctuation">(</span>year<span class="token punctuation">,</span> date_column<span class="token punctuation">)</span> <span class="token keyword">AS</span> year_part<span class="token punctuation">,</span> DATEADD<span class="token punctuation">(</span>month<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> date_column<span class="token punctuation">)</span> <span class="token keyword">AS</span> added_month<span class="token punctuation">,</span> DATEDIFF<span class="token punctuation">(</span>day<span class="token punctuation">,</span> date_column1<span class="token punctuation">,</span> date_column2<span class="token punctuation">)</span> <span class="token keyword">AS</span> day_difference <span class="token keyword">FROM</span> <span class="token keyword">table</span><span class="token punctuation">;</span></code></pre><h2 id="表联结"><a href="#表联结" class="headerlink" title="表联结"></a>表联结</h2><h3 id="联结"><a href="#联结" class="headerlink" title="联结"></a>联结</h3><p>SQL最强大的功能之一就是能在数据检索查询的执行中联结（join）表。联结是利用SQL的SELECT能执行的最重要的操作，很好地理解联结及其语法是学习SQL的一个极为重要的组成部分。</p><h4 id="关系表"><a href="#关系表" class="headerlink" title="关系表"></a>关系表</h4><p> 关系表（Relational Table）是关系型数据库中的基本组成部分之一，它由行和列组成，用于存储和组织数据。关系表是以二维表格形式呈现的，其中每一列表示一个属性（字段），每一行表示一个记录（元组）。 </p><p>关系表的设计通常遵循数据库设计的规范，包括主键（用于唯一标识每条记录）、外键（用于与其他表建立关联）等约束。 </p><h4 id="为什么要使用联结"><a href="#为什么要使用联结" class="headerlink" title="为什么要使用联结"></a>为什么要使用联结</h4><p>分解数据为多个表能更有效地存储，更方便地处理，且具有更大的可伸缩性。但这些好处是有代价的；</p><p>在关系型数据库中，使用联结（Join）是一种重要的操作，用于将多个关系表中的数据按照特定的关联条件进行合并。下面是一些使用联结的原因：</p><ol><li>数据关联：当数据分布在多个表中，并且这些表之间存在关联关系时，使用联结可以根据关联条件将相关数据连接在一起，从而获得更完整和详细的信息。</li><li>数据查询：通过联结，可以执行更复杂和灵活的查询操作。联结允许同时查询和获取多个关联表中的数据，从而得到更准确和全面的查询结果。</li><li>数据完整性：联结可以确保数据的完整性和一致性。通过将关联表的数据合并在一起，可以避免数据冗余和不一致问题，提高数据库的数据质量。</li><li>数据分析：联结可以帮助进行复杂的数据分析任务。通过将多个表中的数据合并，可以进行更深入和综合的数据分析，发现更多的关联和模式。</li><li>优化性能：在某些情况下，通过联结来优化查询性能。通过联结，可以减少需要多次查询的数据访问次数，从而提高查询效率。</li></ol><blockquote><p> 联结操作需要谨慎使用，尤其是对于包含大量数据的表或复杂的联结操作。合理设计数据库的关系、索引和查询语句是确保联结操作高效和准确的关键。 </p></blockquote><h3 id="创建联结"><a href="#创建联结" class="headerlink" title="创建联结"></a>创建联结</h3><p>在关系型数据库中，可以使用 SQL 语句来创建联结（JOIN），将多个表中的数据按照特定的关联条件进行合并。常见的联结类型包括内联结（INNER JOIN）、左联结（LEFT JOIN）、右联结（RIGHT JOIN）和全联结（FULL JOIN）。</p><p>以下是基本的联结语法示例：</p><ol><li>内联结（INNER JOIN）：</li></ol><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> column1<span class="token punctuation">,</span> column2<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">FROM</span> table1<span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> table2 <span class="token keyword">ON</span> table1<span class="token punctuation">.</span><span class="token keyword">column</span> <span class="token operator">=</span> table2<span class="token punctuation">.</span><span class="token keyword">column</span><span class="token punctuation">;</span></code></pre><ol start="2"><li>左联结（LEFT JOIN）：</li></ol><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> column1<span class="token punctuation">,</span> column2<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">FROM</span> table1<span class="token keyword">LEFT</span> <span class="token keyword">JOIN</span> table2 <span class="token keyword">ON</span> table1<span class="token punctuation">.</span><span class="token keyword">column</span> <span class="token operator">=</span> table2<span class="token punctuation">.</span><span class="token keyword">column</span><span class="token punctuation">;</span></code></pre><ol start="3"><li>右联结（RIGHT JOIN）：</li></ol><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> column1<span class="token punctuation">,</span> column2<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">FROM</span> table1<span class="token keyword">RIGHT</span> <span class="token keyword">JOIN</span> table2 <span class="token keyword">ON</span> table1<span class="token punctuation">.</span><span class="token keyword">column</span> <span class="token operator">=</span> table2<span class="token punctuation">.</span><span class="token keyword">column</span><span class="token punctuation">;</span></code></pre><ol start="4"><li>全联结（FULL JOIN）：</li></ol><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> column1<span class="token punctuation">,</span> column2<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">FROM</span> table1<span class="token keyword">FULL</span> <span class="token keyword">JOIN</span> table2 <span class="token keyword">ON</span> table1<span class="token punctuation">.</span><span class="token keyword">column</span> <span class="token operator">=</span> table2<span class="token punctuation">.</span><span class="token keyword">column</span><span class="token punctuation">;</span></code></pre><p>在上述示例中，table1 和 table2 是要进行联结的两个表，ON 子句指定了关联条件，用于指定两个表之间要匹配的列。SELECT 子句中列出了想要查询的字段。</p><h3 id="创建高级联结"><a href="#创建高级联结" class="headerlink" title="创建高级联结"></a>创建高级联结</h3><h4 id="使用表别名"><a href="#使用表别名" class="headerlink" title="使用表别名"></a>使用表别名</h4><p>当需要进行更复杂的联结操作时，可以结合表别名使用高级联结。</p><p>别名除了用于列名和计算字段外，SQL还允许给表名起别名。这样做有两个主要理由： </p><p>1缩短SQL语句； </p><p>2允许在单条SELECT语句中多次使用相同的表。</p><p>以下是一个示例，演示如何使用表别名进行内联结和左联结：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> t1<span class="token punctuation">.</span>column1<span class="token punctuation">,</span> t2<span class="token punctuation">.</span>column2<span class="token keyword">FROM</span> table1 <span class="token keyword">AS</span> t1<span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> table2 <span class="token keyword">AS</span> t2 <span class="token keyword">ON</span> t1<span class="token punctuation">.</span>id <span class="token operator">=</span> t2<span class="token punctuation">.</span>id<span class="token keyword">WHERE</span> t1<span class="token punctuation">.</span>column3 <span class="token operator">=</span> <span class="token string">'value'</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> t1<span class="token punctuation">.</span>column1<span class="token punctuation">,</span> t2<span class="token punctuation">.</span>column2<span class="token keyword">FROM</span> table1 <span class="token keyword">AS</span> t1<span class="token keyword">LEFT</span> <span class="token keyword">JOIN</span> table2 <span class="token keyword">AS</span> t2 <span class="token keyword">ON</span> t1<span class="token punctuation">.</span>id <span class="token operator">=</span> t2<span class="token punctuation">.</span>id<span class="token keyword">WHERE</span> t1<span class="token punctuation">.</span>column3 <span class="token operator">=</span> <span class="token string">'value'</span><span class="token punctuation">;</span></code></pre><p>在上述示例中，我们使用表别名 “t1” 和 “t2” 分别代替了表 table1 和 table2。通过表别名，我们可以在查询中引用相应的表，并指定它们之间的关联条件。</p><p>第一个示例展示了一个内联结，使用 INNER JOIN 关键字将表 t1 和 t2 进行联结，并在 ON 子句中指定了关联条件。这个查询只返回满足 t1.column3 = ‘value’ 条件的结果。</p><p>第二个示例展示了一个左联结，使用 LEFT JOIN 关键字将表 t1 和 t2 进行联结，并在 ON 子句中指定了关联条件。这个查询同样只返回满足 t1.column3 = ‘value’ 条件的结果，但保留了 t1 表中没有匹配的记录。</p><h4 id="使用不同类型的联结"><a href="#使用不同类型的联结" class="headerlink" title="使用不同类型的联结"></a>使用不同类型的联结</h4><p>当处理一张表内的数据关联时，可以使用自联结（self-join），而当需要联结两个具有相同结构的表时，可以使用自然联结（natural join）。此外，当需要获取包括不符合联结条件的行时，可以使用外部联结（outer join）。</p><p>下面是使用不同类型的联结的示例：</p><ol><li>自联结（Self-Join）：</li></ol><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> t1<span class="token punctuation">.</span>column1<span class="token punctuation">,</span> t2<span class="token punctuation">.</span>column2<span class="token keyword">FROM</span> <span class="token keyword">table</span> <span class="token keyword">AS</span> t1<span class="token keyword">JOIN</span> <span class="token keyword">table</span> <span class="token keyword">AS</span> t2 <span class="token keyword">ON</span> t1<span class="token punctuation">.</span>id <span class="token operator">=</span> t2<span class="token punctuation">.</span>related_id<span class="token punctuation">;</span></code></pre><p>在自联结中，我们使用相同的表别名 “t1” 和 “t2” 来引用同一张表，并指定它们之间的关联条件。这可以用于将表中的某一行与同一表中的其他行进行比较和关联。</p><ol start="2"><li>自然联结（Natural Join）：</li></ol><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span><span class="token keyword">FROM</span> table1<span class="token keyword">NATURAL</span> <span class="token keyword">JOIN</span> table2<span class="token punctuation">;</span></code></pre><p>自然联结会自动根据两个表中列名相同的列进行关联。该操作省略了使用 ON 子句指定关联条件的步骤。</p><ol start="3"><li>外部联结（Outer Join）：</li></ol><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> t1<span class="token punctuation">.</span>column1<span class="token punctuation">,</span> t2<span class="token punctuation">.</span>column2<span class="token keyword">FROM</span> table1 <span class="token keyword">AS</span> t1<span class="token keyword">LEFT</span> <span class="token keyword">JOIN</span> table2 <span class="token keyword">AS</span> t2 <span class="token keyword">ON</span> t1<span class="token punctuation">.</span>id <span class="token operator">=</span> t2<span class="token punctuation">.</span>id<span class="token punctuation">;</span></code></pre><p>外部联结可以分为左外部联结（LEFT OUTER JOIN）和右外部联结（RIGHT OUTER JOIN）。上述示例演示了左外部联结，返回左表（table1）中的所有行，以及与右表（table2）中符合关联条件的匹配行。如果没有匹配行，则右表中的列将用 NULL 值表示。</p><h4 id="使用带聚集函数的联结"><a href="#使用带聚集函数的联结" class="headerlink" title="使用带聚集函数的联结"></a>使用带聚集函数的联结</h4><p>可以在联结操作中使用聚合函数来对联结后的数据进行聚合计算。以下是使用带有聚合函数的联结的示例：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> t1<span class="token punctuation">.</span><span class="token keyword">column</span><span class="token punctuation">,</span> <span class="token function">COUNT</span><span class="token punctuation">(</span>t2<span class="token punctuation">.</span><span class="token keyword">column</span><span class="token punctuation">)</span><span class="token keyword">FROM</span> table1 <span class="token keyword">AS</span> t1<span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> table2 <span class="token keyword">AS</span> t2 <span class="token keyword">ON</span> t1<span class="token punctuation">.</span>id <span class="token operator">=</span> t2<span class="token punctuation">.</span>id<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> t1<span class="token punctuation">.</span><span class="token keyword">column</span><span class="token punctuation">;</span></code></pre><p>上述示例中，使用了内联结（INNER JOIN）将表1（table1）和表2（table2）进行联结，并使用关联条件 t1.id = t2.id 进行匹配。然后，通过聚合函数 COUNT(t2.column) 对联结后的数据进行计数。使用 GROUP BY 子句按照 t1.column 进行分组，以便为每个不同的 t1.column 值计算对应的 COUNT(t2.column) 值。</p><p>可以根据需要使用其他聚集函数，例如 SUM、AVG、MIN、MAX 等等来对联结后的数据进行聚合计算。</p><h4 id="使用联结和联结条件"><a href="#使用联结和联结条件" class="headerlink" title="使用联结和联结条件"></a>使用联结和联结条件</h4><p>1注意所使用的联结类型。一般我们使用内部联结，但使用外部联结也是有效的。 </p><p>2保证使用正确的联结条件，否则将返回不正确的数据。 </p><p>3应该总是提供联结条件，否则会得出笛卡儿积。 </p><p>4在一个联结中可以包含多个表，甚至对于每个联结可以采用不同 的联结类型。虽然这样做是合法的，一般也很有用，但应该在一起测试它们前，分别测试每个联结。这将使故障排除更为简单。</p><h2 id="使用视图"><a href="#使用视图" class="headerlink" title="使用视图"></a>使用视图</h2><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p>视图是虚拟的表。与包含数据的表不一样，视图只包含使用时动态检索数据的查询</p><h3 id="为什么使用视图"><a href="#为什么使用视图" class="headerlink" title="为什么使用视图"></a>为什么使用视图</h3><p>使用视图有以下几个常见的优点和用途：</p><ol><li>简化复杂的查询：视图可以将多个表关联和筛选操作封装在一个视图中，从而简化复杂查询的编写过程。用户只需使用视图进行查询，而不必关心底层表的结构和关系。</li><li>数据安全性和权限控制：通过视图，可以限制用户对底层表的直接访问，从而提高数据的安全性。你可以定义一个仅包含所需的列和行的视图，然后将该视图授予特定的用户或角色。这样，用户只能通过视图访问被授权的数据，而无法直接访问表。</li><li>数据抽象和逻辑分离：视图可以提供数据的抽象层，将数据库的物理结构与逻辑操作进行分离。这有助于简化应用程序开发过程，使得应用程序可以基于视图进行操作，而不必直接处理底层表的复杂性。</li><li>维护和变更管理：如果数据库的底层表结构发生变化，例如添加或删除列，但视图的定义保持不变，那么应用程序也不需要进行大量的更改。视图提供了一种独立于底层数据结构的方式来访问数据，从而减少了维护工作和代码的重构。</li><li>提供数据重用：通过创建视图，可以将常用的查询逻辑封装起来并重复使用。这样可以提高代码的可维护性和代码重用性，减少冗余代码的编写。</li></ol><h3 id="视图的规则和限制"><a href="#视图的规则和限制" class="headerlink" title="视图的规则和限制"></a>视图的规则和限制</h3><p>视图在使用时有一些规则和限制，下面是常见的一些规则和限制：</p><ol><li><p>视图必须基于一个或多个已存在的表或其他视图。视图无法直接基于其他视图。</p></li><li><p>视图只能查询数据，不能修改数据。这意味着你不能通过视图进行插入、更新或删除操作。如果想要修改数据，需要直接操作底层的表。</p></li><li><p>视图的列名可以是自定义的，不一定与底层表的列名相同。但是在查询时，仍然需要使用视图中定义的列名。</p></li><li><p>视图的定义可以包含筛选条件，用于限制结果集中的行。这可以通过在创建视图时使用 WHERE 子句来实现。</p></li><li><p>视图的定义可以包含连接操作，用于关联多个表。这可以通过在创建视图时使用 JOIN 子句来实现。</p></li><li><p>视图可以嵌套，即一个视图可以基于另一个视图进行定义。但是要注意，嵌套的视图可能会影响查询性能，因此需要谨慎使用。</p></li><li><p>视图可以具有授权和权限限制。只有具有足够权限的用户才能够查询和使用视图。</p></li><li><p>视图的性能可能会受到影响。复杂的视图查询可能会导致性能下降，特别是当涉及到大量数据和多个表时。在设计视图时应考虑性能方面的问题。</p></li></ol><h3 id="使用视图-1"><a href="#使用视图-1" class="headerlink" title="使用视图"></a>使用视图</h3><p>视图用CREATE VIEW语句来创建</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">VIEW</span> view_name <span class="token keyword">AS</span><span class="token keyword">SELECT</span> column1<span class="token punctuation">,</span> column2<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">FROM</span> table_name<span class="token keyword">WHERE</span> condition<span class="token punctuation">;</span></code></pre><p>使用SHOW CREATE VIEW viewname；来查看创建视图的语句</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SHOW</span> <span class="token keyword">CREATE</span> <span class="token keyword">VIEW</span> view_name<span class="token punctuation">;</span></code></pre><p>用DROP删除视图，其语法为DROP VIEW viewname</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">DROP</span> <span class="token keyword">VIEW</span> view_name<span class="token punctuation">;</span></code></pre><p>更新视图时，可以先用DROP再用CREATE，也可以直接用CREATE OR  REPLACE VIEW。如果要更新的视图不存在，则第2条更新语句会创建一个视图；如果要更新的视图存在，则第2条更新语句会替换原有视图。</p><h4 id="利用视图简化复杂的联结"><a href="#利用视图简化复杂的联结" class="headerlink" title="利用视图简化复杂的联结"></a>利用视图简化复杂的联结</h4><p>使用视图可以简化复杂的联结操作。通过创建视图，将多个表的联结逻辑封装起来，并且在需要时直接使用视图进行查询，而无需编写繁琐的联结语句。</p><p>以下是一个示例，展示如何使用视图简化联结操作：</p><p>假设你有两个表：<code>orders</code> 和 <code>customers</code>，它们之间通过 <code>customer_id</code> 列进行关联。你想要查询订单信息以及对应的顾客信息。首先，你可以创建一个名为 <code>order_details</code> 的视图，该视图包含订单信息和对应的顾客信息。创建视图的语句如下：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">VIEW</span> order_details <span class="token keyword">AS</span><span class="token keyword">SELECT</span> o<span class="token punctuation">.</span>order_id<span class="token punctuation">,</span> o<span class="token punctuation">.</span>order_date<span class="token punctuation">,</span> <span class="token number">c</span><span class="token punctuation">.</span>customer_name<span class="token keyword">FROM</span> orders o<span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> customers <span class="token number">c</span> <span class="token keyword">ON</span> o<span class="token punctuation">.</span>customer_id <span class="token operator">=</span> <span class="token number">c</span><span class="token punctuation">.</span>customer_id<span class="token punctuation">;</span></code></pre><p>在上述语句中，我们通过联结 <code>orders</code> 表和 <code>customers</code> 表来获取订单信息和对应的顾客信息，并将结果保存为 <code>order_details</code> 视图。</p><p>一旦视图创建完成，你可以直接使用该视图进行查询，而无需编写联结语句。例如，你可以执行以下查询命令来获取订单信息以及对应的顾客信息：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> order_details<span class="token punctuation">;</span></code></pre><p>这样，你就可以轻松地获取到订单信息和对应的顾客信息，而无需手动编写联结语句。</p><p>通过使用视图，你可以将复杂的联结操作封装为一个可重复使用的对象，并提高查询的简洁性和可读性。</p><h4 id="用视图重新格式化检索出的数据"><a href="#用视图重新格式化检索出的数据" class="headerlink" title="用视图重新格式化检索出的数据"></a>用视图重新格式化检索出的数据</h4><p>使用视图可以重新格式化检索出的数据。在创建视图时，通过查询语句对数据进行适当的格式化操作，以满足需求。</p><p>以下是一个示例，展示如何使用视图重新格式化检索出的数据：</p><p>假设你有一个名为 <code>employees</code> 的表，其中包含员工的姓名和薪资信息。你想要将这些数据按照一定的格式进行检索，例如将姓名的首字母大写，并显示薪资的千位分隔符。</p><p>首先，你可以创建一个名为 <code>formatted_employees</code> 的视图，该视图重新格式化了员工表中的数据。创建视图的语句如下：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">VIEW</span> formatted_employees <span class="token keyword">AS</span><span class="token keyword">SELECT</span>   CONCAT<span class="token punctuation">(</span><span class="token function">UCASE</span><span class="token punctuation">(</span><span class="token keyword">LEFT</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> LOWER<span class="token punctuation">(</span>SUBSTRING<span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> formatted_name<span class="token punctuation">,</span>  <span class="token function">FORMAT</span><span class="token punctuation">(</span>salary<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> formatted_salary<span class="token keyword">FROM</span> employees<span class="token punctuation">;</span></code></pre><p>在上述语句中，我们使用了字符串函数 <code>CONCAT</code> 和 <code>UCASE</code> 来将姓名的首字母大写，并使用了字符串函数 <code>LOWER</code> 和 <code>SUBSTRING</code> 来保持其余部分小写。我们还使用了函数 <code>FORMAT</code> 来添加薪资的千位分隔符。</p><p>一旦视图创建完成，你可以直接使用该视图进行查询，以获取已经重新格式化的数据。例如，你可以执行以下查询命令来获取重新格式化后的员工数据：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> formatted_employees<span class="token punctuation">;</span></code></pre><p>这样，你就可以获得按照特定格式重新处理过的员工数据。通过使用视图，你可以在数据库中创建一个虚拟表，该表包含经过格式化的数据，以便于查询和使用。</p><h4 id="用视图过滤不想要的数据"><a href="#用视图过滤不想要的数据" class="headerlink" title="用视图过滤不想要的数据"></a>用视图过滤不想要的数据</h4><p>使用视图可以方便地过滤掉你不想要的数据，只返回符合指定条件的数据。你可以在创建视图时，通过添加筛选条件来过滤数据。</p><p>以下是一个示例，展示如何使用视图过滤不想要的数据：</p><p>假设你有一个名为 <code>products</code> 的表，其中包含产品的名称、价格和库存信息。你想要创建一个视图，只包含价格高于100的产品信息。</p><p>你可以使用以下语句创建一个名为 <code>high_priced_products</code> 的视图：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">VIEW</span> high_priced_products <span class="token keyword">AS</span><span class="token keyword">SELECT</span> <span class="token operator">*</span><span class="token keyword">FROM</span> products<span class="token keyword">WHERE</span> price <span class="token operator">></span> <span class="token number">100</span><span class="token punctuation">;</span></code></pre><p>在上述语句中，我们在查询语句中包含了一个筛选条件 <code>WHERE price &gt; 100</code>，它将仅返回价格高于100的产品信息。</p><p>创建完成后，你可以直接使用该视图进行查询，以获取满足条件的产品信息。例如，你可以执行以下查询命令来获取价格高于100的产品：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> high_priced_products<span class="token punctuation">;</span></code></pre><p>这样，你就可以获得符合条件的产品信息，而不包括价格低于或等于100的产品。通过使用视图进行数据过滤，你可以创建一个过滤后的虚拟表，使得查询结果更加精确和符合特定需求。</p><h4 id="使用视图与计算字段"><a href="#使用视图与计算字段" class="headerlink" title="使用视图与计算字段"></a>使用视图与计算字段</h4><p>使用视图和计算字段可以在数据库中创建一个虚拟表，其中包含经过计算的字段。视图可以简化复杂的计算操作，并使其更易于查询和使用。</p><p>以下是一个示例，展示如何在视图中使用计算字段：</p><p>假设你有一个名为 <code>sales</code> 的表，其中包含销售订单的信息，包括产品名称、单价和销售数量。你想要创建一个视图，包含订单的总价和利润率。</p><p>你可以使用以下语句创建一个名为 <code>sales_summary</code> 的视图：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">VIEW</span> sales_summary <span class="token keyword">AS</span><span class="token keyword">SELECT</span>   product_name<span class="token punctuation">,</span>  unit_price<span class="token punctuation">,</span>  quantity<span class="token punctuation">,</span>  unit_price <span class="token operator">*</span> quantity <span class="token keyword">AS</span> total_price<span class="token punctuation">,</span>  <span class="token punctuation">(</span>unit_price <span class="token operator">*</span> quantity <span class="token operator">-</span> cost_price <span class="token operator">*</span> quantity<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token punctuation">(</span>unit_price <span class="token operator">*</span> quantity<span class="token punctuation">)</span> <span class="token keyword">AS</span> profit_margin<span class="token keyword">FROM</span> sales<span class="token punctuation">;</span></code></pre><p>在上述语句中，我们在查询语句中定义了两个计算字段：<code>total_price</code> 和 <code>profit_margin</code>。<code>total_price</code> 计算了订单的总价，通过将单价与销售数量相乘；<code>profit_margin</code> 计算了订单的利润率，通过使用销售利润与总价的比率来计算。</p><p>创建完成后，你可以直接使用该视图进行查询，以获取包含计算字段的信息。例如，你可以执行以下查询命令来获取销售订单的摘要信息：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> sales_summary<span class="token punctuation">;</span></code></pre><p>这样，你就可以获得包含了订单总价和利润率的摘要信息。</p><p>通过使用视图和计算字段，你可以在数据库中创建一个方便查询的虚拟表，其中包含经过计算的字段，使得数据分析和报表生成更加便捷。</p><h4 id="更新视图"><a href="#更新视图" class="headerlink" title="更新视图"></a>更新视图</h4><p>视图的数据能否更新？答案视情况而定</p><p>通常，视图是可更新的（即，可以对它们使用INSERT、UPDATE和DELETE）。更新一个视图将更新其基表（可以回忆一下，视图本身没有数据）。如果你对视图增加或删除行，实际上是对其基表增加或删除行</p><p>并非所有视图都是可更新的。基本上可以说，如果MySQL不能正确地确定被更新的基数据，则不允许更新（包括插入和删除）。这实际上意味着，如果视图定义中有以下操作，则不能进行视图的更新：</p><p> 分组（使用GROUP BY和HAVING）； </p><p> 联结； </p><p> 子查询； </p><p> 并； </p><p> 聚集函数（Min()、Count()、Sum()等）</p><p> DISTINCT； </p><p> 导出（计算）列</p><blockquote><p>将视图用于检索 一般，应该将视图用于检索（SELECT语句） </p><p>而不用于更新（INSERT、UPDATE和DELETE）</p></blockquote><h1 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h1><h2 id="使用存储过程"><a href="#使用存储过程" class="headerlink" title="使用存储过程"></a>使用存储过程</h2><h3 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h3><p>存储过程是一组预定义的SQL语句集合，它们被存储在数据库中，并可以作为一个单元来执行。存储过程具有以下优点：</p><ol><li><p>代码封装：存储过程将一组相关的SQL语句封装在一个单元中，使得代码更易于维护和管理。</p></li><li><p>提高性能：存储过程在数据库中预编译，因此执行速度较快。此外，存储过程还可以减少与数据库服务器的通信次数，提高整体性能。</p></li><li><p>安全性：通过存储过程，可以限制用户直接访问表，而只允许通过存储过程来执行特定的操作。这样可以增强数据库的安全性。</p></li><li><p>代码重用：存储过程可以在不同的应用程序中重用，从而减少了代码的编写量，提高了开发效率。</p></li></ol><p>下面是一个简单的存储过程示例，展示如何创建和执行存储过程：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">PROCEDURE</span> GetProductCount<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">BEGIN</span>    <span class="token keyword">SELECT</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> total_products <span class="token keyword">FROM</span> products<span class="token punctuation">;</span><span class="token keyword">END</span><span class="token punctuation">;</span></code></pre><p>上述存储过程名为 <code>GetProductCount</code>，它使用<code>SELECT COUNT(*)</code>语句来获取表 <code>products</code> 的总行数，并将结果存储在一个名为 <code>total_products</code> 的列中。</p><p>要执行该存储过程，可以使用以下语句：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CALL</span> GetProductCount<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>执行存储过程后，将返回一个结果集，其中包含产品总数。</p><h3 id="为什么要使用存储过程"><a href="#为什么要使用存储过程" class="headerlink" title="为什么要使用存储过程"></a>为什么要使用存储过程</h3><p>使用存储过程有多种好处和用途，以下是一些常见的原因和情景：</p><ol><li><p>提高性能：存储过程在数据库中预编译，并且可以进行优化。这意味着存储过程的执行速度通常比简单的SQL查询更快。此外，存储过程可以减少与数据库服务器的通信次数，从而提高整体性能。</p></li><li><p>代码重用：存储过程可以在不同的应用程序中重复使用。通过将常用的业务逻辑封装在存储过程中，可以避免在每个应用程序中重复编写相同的代码，从而提高开发效率和代码的可维护性。</p></li><li><p>安全性控制：存储过程可以用于限制用户对数据库的直接访问，并只允许他们通过存储过程执行特定的操作。这样可以增强数据库的安全性，同时更好地控制数据的访问和修改权限。</p></li><li><p>简化复杂的业务逻辑：存储过程可以容纳包含多个SQL语句和逻辑的复杂业务操作。通过将这些操作封装在一个存储过程中，可以简化应用程序中的代码，并使其更易于理解和维护。</p></li><li><p>数据一致性和完整性：存储过程可以确保特定的业务规则和约束得到遵守。通过在存储过程中定义相应的数据验证、更新和插入规则，可以确保数据的一致性和完整性。</p></li><li><p>数据库层面的错误处理：存储过程允许在数据库层面上进行错误处理和异常处理。可以使用条件语句和异常处理机制来捕获和处理数据库操作中的错误，从而提供更加可靠和稳定的应用程序。</p></li></ol><h3 id="使用存储过程-1"><a href="#使用存储过程-1" class="headerlink" title="使用存储过程"></a>使用存储过程</h3><ol><li><h4 id="执行存储过程："><a href="#执行存储过程：" class="headerlink" title="执行存储过程："></a>执行存储过程：</h4></li></ol><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CALL</span> 存储过程名称<span class="token punctuation">;</span></code></pre><p>通过使用 <code>CALL</code> 关键字，可以执行指定名称的存储过程。</p><ol start="2"><li><h4 id="创建存储过程："><a href="#创建存储过程：" class="headerlink" title="创建存储过程："></a>创建存储过程：</h4></li></ol><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">PROCEDURE</span> 存储过程名称<span class="token punctuation">(</span>参数列表<span class="token punctuation">)</span><span class="token keyword">BEGIN</span>    存储过程体<span class="token keyword">END</span><span class="token punctuation">;</span></code></pre><p>使用 <code>CREATE PROCEDURE</code> 关键字和合适的语法，可以创建一个新的存储过程。参数列表和存储过程体都是可选的，根据需要进行定义。</p><ol start="3"><li><h4 id="删除存储过程："><a href="#删除存储过程：" class="headerlink" title="删除存储过程："></a>删除存储过程：</h4></li></ol><pre class=" language-sql"><code class="language-sql"><span class="token keyword">DROP</span> <span class="token keyword">PROCEDURE</span> <span class="token keyword">IF</span> <span class="token keyword">EXISTS</span> 存储过程名称<span class="token punctuation">;</span></code></pre><p>使用 <code>DROP PROCEDURE</code> 关键字可以删除指定名称的存储过程。<code>IF EXISTS</code> 部分用于检查存储过程是否存在，避免出现错误。</p><ol start="4"><li><h4 id="使用参数："><a href="#使用参数：" class="headerlink" title="使用参数："></a>使用参数：</h4><p>存储过程可以接收输入参数、输出参数或输入输出参数，用于动态地处理数据。在创建存储过程时，可以在参数列表中定义这些参数，并在存储过程体中使用它们。</p><p>以下是一个示例，展示如何在存储过程中使用参数：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">PROCEDURE</span> ProcessData<span class="token punctuation">(</span><span class="token operator">IN</span> input_param <span class="token keyword">INT</span><span class="token punctuation">,</span> <span class="token keyword">OUT</span> output_param <span class="token keyword">INT</span><span class="token punctuation">)</span><span class="token keyword">BEGIN</span>    <span class="token comment" spellcheck="true">-- 在存储过程中使用输入参数</span>    <span class="token keyword">SELECT</span> column1<span class="token punctuation">,</span> column2     <span class="token keyword">FROM</span> <span class="token keyword">table</span>    <span class="token keyword">WHERE</span> condition <span class="token operator">=</span> input_param<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">-- 在存储过程中使用输出参数</span>    <span class="token keyword">SET</span> output_param <span class="token operator">=</span> input_param <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token keyword">END</span><span class="token punctuation">;</span></code></pre><p>上述示例中的存储过程 <code>ProcessData</code> 接收一个输入参数 <code>input_param</code> 和一个输出参数 <code>output_param</code>。具体的实现逻辑包括：</p><ul><li>使用 <code>IN</code> 关键字声明输入参数 <code>input_param</code> 的类型。</li><li>在存储过程体中，可以使用输入参数 <code>input_param</code> 来进行条件查询，根据不同的条件动态处理数据。</li><li>使用 <code>OUT</code> 关键字声明输出参数 <code>output_param</code> 的类型。</li><li>在存储过程体中，可以对输出参数 <code>output_param</code> 进行赋值操作，以便将结果传递给调用者。</li></ul></li></ol><ol start="5"><li><h4 id="建立智能存储过程："><a href="#建立智能存储过程：" class="headerlink" title="建立智能存储过程："></a>建立智能存储过程：</h4><p>智能存储过程是指具有逻辑判断和条件处理能力的存储过程。您可以在存储过程的主体中添加条件、循环和控制语句来实现更复杂的业务逻辑。</p><p>下面是一个示例，展示如何在存储过程中使用条件语句和控制流程语句：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">PROCEDURE</span> IntelligentProcedure<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">BEGIN</span>    <span class="token keyword">DECLARE</span> total_sales <span class="token keyword">DECIMAL</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">DECLARE</span> bonus <span class="token keyword">DECIMAL</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">-- 计算总销售额</span>    <span class="token keyword">SELECT</span> <span class="token function">SUM</span><span class="token punctuation">(</span>sales_amount<span class="token punctuation">)</span> <span class="token keyword">INTO</span> total_sales <span class="token keyword">FROM</span> sales<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">-- 根据销售额计算奖金</span>    <span class="token keyword">IF</span> total_sales <span class="token operator">></span> <span class="token number">100000</span> <span class="token keyword">THEN</span>        <span class="token keyword">SET</span> bonus <span class="token operator">=</span> total_sales <span class="token operator">*</span> <span class="token number">0.1</span><span class="token punctuation">;</span>    ELSEIF total_sales <span class="token operator">></span> <span class="token number">50000</span> <span class="token keyword">THEN</span>        <span class="token keyword">SET</span> bonus <span class="token operator">=</span> total_sales <span class="token operator">*</span> <span class="token number">0.05</span><span class="token punctuation">;</span>    <span class="token keyword">ELSE</span>        <span class="token keyword">SET</span> bonus <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">END</span> <span class="token keyword">IF</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">-- 输出结果</span>    <span class="token keyword">SELECT</span> bonus <span class="token keyword">AS</span> <span class="token string">'Bonus Amount'</span><span class="token punctuation">;</span><span class="token keyword">END</span><span class="token punctuation">;</span></code></pre><p>上述示例中的存储过程 <code>IntelligentProcedure</code> 实现了一个简单的逻辑：根据总销售额的不同范围，计算出相应的奖金金额。具体的实现逻辑包括：</p><ul><li>定义两个变量 <code>total_sales</code> 和 <code>bonus</code> 来保存总销售额和奖金金额。</li><li>使用 <code>SELECT...INTO</code> 语句将总销售额查询结果赋值给 <code>total_sales</code> 变量。</li><li>使用条件语句 <code>IF...ELSEIF...ELSE</code> 根据不同的销售额范围计算奖金金额，并将结果赋值给 <code>bonus</code> 变量。</li><li>最后，使用 <code>SELECT</code> 语句输出奖金金额。</li></ul><p>通过这种方式，您可以根据实际需求，在存储过程中添加适当的条件、循环和控制流程语句，以实现更智能的业务逻辑。</p></li><li><h4 id="检查存储过程："><a href="#检查存储过程：" class="headerlink" title="检查存储过程："></a>检查存储过程：</h4></li></ol><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SHOW</span> <span class="token keyword">CREATE</span> <span class="token keyword">PROCEDURE</span> 存储过程名称<span class="token punctuation">;</span></code></pre><p>使用 <code>SHOW CREATE PROCEDURE</code> 命令可以查看指定存储过程的创建语句。这对于检查存储过程的定义和结构非常有用。</p><h2 id="使-用-游-标"><a href="#使-用-游-标" class="headerlink" title="使 用 游 标"></a>使 用 游 标</h2><p>游标（Cursor）是一种用于在存储过程或函数中遍历结果集的机制。通过使用游标，您可以逐行处理查询结果，并对每一行执行特定的操作。</p><p>以下是一个示例，展示如何在存储过程中使用游标：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">PROCEDURE</span> ProcessData<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">BEGIN</span>    <span class="token keyword">DECLARE</span> done <span class="token keyword">INT</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">FALSE</span><span class="token punctuation">;</span>    <span class="token keyword">DECLARE</span> column1 <span class="token keyword">INT</span><span class="token punctuation">;</span>    <span class="token keyword">DECLARE</span> column2 <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">-- 声明游标</span>    <span class="token keyword">DECLARE</span> cur <span class="token keyword">CURSOR</span> <span class="token keyword">FOR</span> <span class="token keyword">SELECT</span> column1<span class="token punctuation">,</span> column2 <span class="token keyword">FROM</span> <span class="token keyword">table</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">-- 定义异常处理程序</span>    <span class="token keyword">DECLARE</span> <span class="token keyword">CONTINUE</span> <span class="token keyword">HANDLER</span> <span class="token keyword">FOR</span> <span class="token operator">NOT</span> FOUND <span class="token keyword">SET</span> done <span class="token operator">=</span> <span class="token boolean">TRUE</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">-- 打开游标</span>    <span class="token keyword">OPEN</span> cur<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">-- 循环遍历结果集</span>    read_loop: LOOP        <span class="token comment" spellcheck="true">-- 读取下一行数据</span>        <span class="token keyword">FETCH</span> cur <span class="token keyword">INTO</span> column1<span class="token punctuation">,</span> column2<span class="token punctuation">;</span>        <span class="token keyword">IF</span> done <span class="token keyword">THEN</span>            LEAVE read_loop<span class="token punctuation">;</span>        <span class="token keyword">END</span> <span class="token keyword">IF</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">-- 在此处对每一行数据执行特定操作</span>        <span class="token comment" spellcheck="true">-- 示例：输出列值</span>        <span class="token keyword">SELECT</span> column1<span class="token punctuation">,</span> column2<span class="token punctuation">;</span>    <span class="token keyword">END</span> LOOP<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">-- 关闭游标</span>    <span class="token keyword">CLOSE</span> cur<span class="token punctuation">;</span><span class="token keyword">END</span><span class="token punctuation">;</span></code></pre><p>上述示例中的存储过程 <code>ProcessData</code> 使用游标来遍历查询结果集并对每一行数据执行特定的操作。具体的实现逻辑包括：</p><ul><li>声明变量 <code>done</code> 来表示游标是否已经遍历完所有行。</li><li>声明与查询结果集对应的变量，例如 <code>column1</code> 和 <code>column2</code>。</li><li>声明游标 <code>cur</code> 并将查询结果集赋值给游标。</li><li>定义异常处理程序，用于在遍历结果集时捕获异常（例如结果集为空）。</li><li>打开游标以准备遍历结果集。</li><li>使用循环语句 <code>LOOP</code> 和条件判断 <code>IF done THEN LEAVE read_loop; END IF;</code> 来循环遍历结果集，并在每次迭代中读取下一行数据。</li><li>在循环体中，您可以对每一行数据执行特定的操作，例如输出列值。</li><li>最后，关闭游标以释放资源。</li></ul><h2 id="使用触发器"><a href="#使用触发器" class="headerlink" title="使用触发器"></a>使用触发器</h2><p>触发器（Trigger）是数据库对象，可以在指定的数据库操作（例如插入、更新、删除）发生时自动执行一段代码。通过使用触发器，您可以在特定的数据变动事件上执行自定义逻辑，实现数据的约束、验证、派生等操作。</p><p>以下是一个示例，展示如何创建触发器：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TRIGGER</span> trigger_nameBEFORE <span class="token keyword">INSERT</span> <span class="token keyword">ON</span> table_name<span class="token keyword">FOR EACH ROW</span><span class="token keyword">BEGIN</span>    <span class="token comment" spellcheck="true">-- 在此处编写触发器的逻辑</span>    <span class="token comment" spellcheck="true">-- 示例：自动生成创建时间</span>    <span class="token keyword">SET</span> NEW<span class="token punctuation">.</span>create_time <span class="token operator">=</span> <span class="token function">NOW</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">END</span><span class="token punctuation">;</span></code></pre><p>上述示例中，我们创建了一个名为 <code>trigger_name</code> 的触发器，并指定它在表 <code>table_name</code> 上的插入操作之前执行。关键的配置包括：</p><ul><li>使用 <code>CREATE TRIGGER</code> 语句创建触发器，并为触发器指定一个名称。</li><li>使用 <code>BEFORE INSERT ON table_name</code> 指定触发器在表 <code>table_name</code> 上的插入操作之前执行。您可以根据需要选择不同的触发时机，如 <code>AFTER INSERT</code>、<code>BEFORE UPDATE</code>、<code>AFTER DELETE</code> 等。</li><li>使用 <code>FOR EACH ROW</code> 指定触发器对每一行数据都执行。</li><li>在 <code>BEGIN</code> 和 <code>END</code> 之间编写触发器的逻辑。在示例中，我们将新插入的行的 <code>create_time</code> 列设置为当前时间。</li></ul><h2 id="管理事务处理"><a href="#管理事务处理" class="headerlink" title="管理事务处理"></a>管理事务处理</h2><p>在数据库中，事务（Transaction）是一组数据库操作的逻辑单元，要么全部成功执行，要么全部回滚（撤销）。事务处理可以确保数据库在并发操作时维持数据的一致性和完整性。</p><p>以下是管理事务处理的示例：</p><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 启动事务</span><span class="token keyword">START</span> <span class="token keyword">TRANSACTION</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 在此处执行数据库操作</span><span class="token comment" spellcheck="true">-- 示例：插入数据</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> table_name <span class="token punctuation">(</span>column1<span class="token punctuation">,</span> column2<span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span>value1<span class="token punctuation">,</span> value2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 示例：更新数据</span><span class="token keyword">UPDATE</span> table_name <span class="token keyword">SET</span> column1 <span class="token operator">=</span> new_value <span class="token keyword">WHERE</span> condition<span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 示例：删除数据</span><span class="token keyword">DELETE</span> <span class="token keyword">FROM</span> table_name <span class="token keyword">WHERE</span> condition<span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 提交事务</span><span class="token keyword">COMMIT</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 或者回滚事务</span><span class="token keyword">ROLLBACK</span><span class="token punctuation">;</span></code></pre><p>上述示例中，我们使用 <code>START TRANSACTION</code> 开始一个事务，并在 <code>COMMIT</code> 处提交事务。如果需要回滚事务则可以使用 <code>ROLLBACK</code>。</p><p>在事务内，我们可以执行各种数据库操作，如插入、更新和删除等。这些操作将被视为一个逻辑单元，要么全部成功提交，要么全部回滚。</p><p>在实际应用中，为了确保事务的正确性和一致性，还应考虑以下几点：</p><ul><li>使用异常处理（例如使用存储过程或触发器）来捕获错误并决定是否回滚事务。</li><li>设置适当的隔离级别，以控制并发访问时数据的可见性和一致性。</li><li>避免长时间持有事务，以减少数据库锁的冲突和资源占用。</li></ul><h2 id="全球化和本地化"><a href="#全球化和本地化" class="headerlink" title="全球化和本地化"></a>全球化和本地化</h2><p>全球化（Globalization）和本地化（Localization）是软件开发领域中与跨国界应用程序的适配性和可用性相关的两个概念。字符集和校对顺序在全球化和本地化中起着重要的作用。</p><ol><li><p>字符集（Character Set）：</p><ul><li>字符集定义了一个字符到数字代码的映射规则。不同的字符集支持不同的字符范围，如 ASCII、Unicode 和 UTF-8。</li><li>全球化应用程序应该使用支持广泛的字符集，如UTF-8，以确保能够正确处理各种语言的字符和文本。</li></ul></li><li><p>校对顺序（Collation Order）：</p><ul><li>校对顺序定义了字符排序的规则和算法。它决定了在排序和比较字符串时字符的顺序和优先级。</li><li>不同的语言和地区使用不同的校对顺序来满足其特定的语言和文化需求。例如，英文通常使用字典排序，而中文通常使用拼音排序。</li><li>在本地化过程中，校对顺序需要根据特定的语言和地区进行配置，以确保正确的排序和比较。</li></ul></li></ol><p>在使用字符集和校对顺序时，需要注意以下几点：</p><ol><li><p>数据库配置：</p><ul><li>在数据库中，选择适当的字符集和校对顺序进行配置。不同的数据库管理系统（如MySQL、Oracle等）提供了相关配置选项。</li><li>确保数据库中使用的字符集和校对顺序与应用程序需要处理的语言和文本一致。</li></ul></li><li><p>应用程序开发：</p><ul><li>在应用程序开发中，使用与目标受众语言和文化相匹配的字符集和校对顺序进行编码和处理文本。</li><li>避免硬编码字符集和校对顺序，而是使用配置文件或在运行时动态设置。</li></ul></li><li><p>测试和验证：</p><ul><li>在全球化和本地化过程中，进行充分的测试和验证以确保字符集和校对顺序的正确性。</li><li>包括输入输出测试、排序和比较测试，以及特定语言和文化下的正确性验证。</li></ul></li></ol><h2 id="安-全-管-理"><a href="#安-全-管-理" class="headerlink" title="安 全 管 理"></a>安 全 管 理</h2><h3 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h3><ol><li>访问控制：<ul><li>MySQL使用权限模型来控制用户对数据库的访问。可以使用GRANT语句为用户分配权限。</li><li>GRANT语句用于授予用户特定的权限（如SELECT、INSERT、UPDATE、DELETE等）和访问级别（全局、数据库、表或列级别）。</li><li>使用REVOKE语句可以撤销已经授权的权限。</li></ul></li></ol><h3 id="管理用户"><a href="#管理用户" class="headerlink" title="管理用户"></a>管理用户</h3><ol><li><p>管理用户：</p><ul><li><p>创建用户：可以使用CREATE USER语句创建新用户。示例：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">USER</span> <span class="token string">'username'</span>@'localhost<span class="token string">' IDENTIFIED BY '</span>password'<span class="token punctuation">;</span></code></pre><p>可以指定用户名、主机名以及密码。</p></li><li><p>删除用户：使用DROP USER语句删除指定的用户。示例：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">DROP</span> <span class="token keyword">USER</span> <span class="token string">'username'</span><span class="token variable">@'localhost'</span><span class="token punctuation">;</span></code></pre></li></ul></li></ol><ul><li><p>设置访问权限：使用GRANT语句为用户分配特定权限。示例：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">GRANT</span> <span class="token keyword">SELECT</span><span class="token punctuation">,</span> <span class="token keyword">INSERT</span> <span class="token keyword">ON</span> <span class="token keyword">database</span><span class="token punctuation">.</span><span class="token operator">*</span> <span class="token keyword">TO</span> <span class="token string">'username'</span><span class="token variable">@'localhost'</span><span class="token punctuation">;</span></code></pre></li></ul><ul><li><p>更改口令：使用ALTER USER语句或SET PASSWORD语句更改用户的口令。示例：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">USER</span> <span class="token string">'username'</span>@'localhost<span class="token string">' IDENTIFIED BY '</span>new_password'<span class="token punctuation">;</span></code></pre></li></ul><h2 id="数据库维护"><a href="#数据库维护" class="headerlink" title="数据库维护"></a>数据库维护</h2><p>数据库维护是确保数据库系统正常运行和保障数据安全性的重要工作。下面是一些常见的数据库维护任务及相应的方法：</p><h3 id="备份数据："><a href="#备份数据：" class="headerlink" title="备份数据："></a>备份数据：</h3><ul><li><p>MySQL提供多种备份方法，包括物理备份和逻辑备份。常用的备份工具有<code>mysqldump</code>和<code>mysqlpump</code>。</p></li><li><p>使用<code>mysqldump</code>命令可以导出整个数据库或指定表的内容。例如，</p><pre class=" language-sql"><code class="language-sql">mysqldump <span class="token operator">-</span>u <span class="token operator">&lt;</span>username<span class="token operator">></span> <span class="token operator">-</span>p <span class="token operator">&lt;</span>databasename<span class="token operator">></span> <span class="token operator">></span> <span class="token keyword">backup</span><span class="token punctuation">.</span>sql</code></pre><p>将整个数据库导出到backup.sql文件中。</p></li><li><p><code>mysqlpump</code>是MySQL 5.7及更新版本提供的备份工具，具有更高的性能和更多的选项。使用方法与<code>mysqldump</code>类似。</p></li></ul><h3 id="进行数据库维护："><a href="#进行数据库维护：" class="headerlink" title="进行数据库维护："></a>进行数据库维护：</h3><ul><li>定期优化数据库以提高性能，可以使用<code>OPTIMIZE TABLE</code>命令来优化表。</li><li>清理不必要的或过期的数据，可以使用<code>DELETE</code>语句或<code>TRUNCATE TABLE</code>命令。</li><li>检查并修复损坏的表，可以使用<code>CHECK TABLE</code>和<code>REPAIR TABLE</code>命令。</li></ul><h3 id="诊断启动问题："><a href="#诊断启动问题：" class="headerlink" title="诊断启动问题："></a>诊断启动问题：</h3><ul><li>如果数据库无法启动，首先可以检查错误日志文件，位于MySQL数据目录下的<code>error.log</code>文件，了解具体的错误信息。</li><li>可以使用<code>systemctl</code>命令（适用于使用systemd的系统）或<code>service</code>命令（适用于其他系统）来启动、停止、重启和查看MySQL服务的状态。例如，<code>systemctl start mysql</code>启动MySQL服务。</li></ul><h3 id="查看日志文件："><a href="#查看日志文件：" class="headerlink" title="查看日志文件："></a>查看日志文件：</h3><ul><li>MySQL记录了各种事件和错误信息，这些信息可以在错误日志文件中找到。错误日志的路径和文件名在MySQL配置文件中进行配置。</li><li>可以使用文本编辑器打开错误日志文件进行查看，或者使用<code>tail</code>命令实时查看最新的日志内容。例如，<code>tail -f /var/log/mysql/error.log</code>。</li></ul><h2 id="改-善-性-能"><a href="#改-善-性-能" class="headerlink" title="改 善 性 能"></a>改 善 性 能</h2><ol><li><p>优化查询：</p><ul><li>确保正确使用索引：合理设计表结构和索引，避免全表扫描。可以使用<code>EXPLAIN</code>语句来分析查询的执行计划，以确定是否有效使用了索引。</li><li>编写高效的查询语句：避免不必要的连接和子查询，优化复杂的SQL语句，提高查询的效率。</li><li>使用适当的数据类型：避免使用过大或不合适的数据类型，减少存储空间和I/O操作。</li></ul></li><li><p>调整配置：</p><ul><li>配置合适的缓冲区大小：如<code>innodb_buffer_pool_size</code>和<code>key_buffer_size</code>等，根据系统资源和负载情况进行调整，提高内存利用率。</li><li>优化连接池设置：增加或减少<code>max_connections</code>参数，根据实际需求合理配置连接数。</li><li>调整日志设置：合理配置日志的级别和写入方式，避免过多的日志写入对性能造成影响。</li></ul></li><li><p>硬件升级：</p><ul><li>提升硬件性能：增加CPU核心数、内存容量和磁盘I/O速度，以提高系统的处理能力和响应速度。</li><li>使用SSD存储：将磁盘替换为SSD可以显著提升I/O性能，加快读写速度。</li></ul></li><li><p>实施缓存策略：</p><ul><li>使用查询缓存：启用适当的查询缓存（如果可用），可减少数据库重复查询的开销。</li><li>使用应用层缓存：如Redis或Memcached等，将热门数据缓存在内存中，减少对数据库的访问。</li></ul></li><li><p>定期维护和监控：</p><ul><li>定期进行数据库优化和碎片整理：使用<code>OPTIMIZE TABLE</code>命令优化表，清理无效数据和索引碎片。</li><li>监控数据库性能：使用MySQL自带的性能监控工具或第三方监控工具，及时发现瓶颈并采取相应措施。</li></ul></li></ol><h1 id="MYSQL附录"><a href="#MYSQL附录" class="headerlink" title="MYSQL附录"></a>MYSQL附录</h1><h2 id="MYSQL必知必会导图"><a href="#MYSQL必知必会导图" class="headerlink" title="MYSQL必知必会导图"></a>MYSQL必知必会导图</h2><img src="https://cdn.jsdelivr.net/gh/Bevis23/blog-pic/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A.jpg" alt="mysql必知必会" style="zoom: 25%;"><h2 id="查看帮助文档"><a href="#查看帮助文档" class="headerlink" title="查看帮助文档"></a>查看帮助文档</h2><ul><li>在MySQL命令行客户端中，可以通过输入<code>help</code>或<code>\h</code>命令获取基本查询语法的帮助信息。</li><li>若要了解特定命令或函数的详细信息，可以使用<code>help</code>命令后面接上相应的命令或函数，例如：<code>help SELECT</code>。</li><li>还可以使用<code>man</code>命令（仅限于UNIX/Linux系统），如<code>man mysql</code>或<code>man mysqldump</code>来查看相关的手册页。</li></ul><h2 id="注意要点"><a href="#注意要点" class="headerlink" title="注意要点"></a>注意要点</h2><p><strong>distinct关键字：</strong>作用于所有的列，不仅仅是跟在其后的那一列。eg: select distinct vend_id,prod_price from products;  </p><p>除非指定的两列完全相同，否则所有的列都会被检索出来。</p><p><strong>order by 子句的位置</strong>：必须是语句中最后一条的句子，否则会输出错误信息；order by 位于where之后</p><p><strong>何时使用引号：</strong>单引号用来限制字符串。 将数值与字符串进行比较，就需要限定引号。</p><p><strong>in：</strong>where子句中用来指定要匹配值的清单关键字，功能与or相同</p><p><strong>通配符：</strong></p><p>1有一种情况吧通配符放在搜索模式的中间很有用，根据邮件地址的一部分来查找电子邮件eg：WHERE email like ‘b%@forta.com’</p><p>2通配符%不可以匹配null值</p><p>3 不要过度使用通配符，尽量不要把它们放在搜索模式的开始处（导致搜索慢），要注意位置，否则会报错</p><p><strong>计算字段</strong></p><p><strong>trim（）：去掉两边的空格  rtrim ltrim 右和左</strong></p><p>select concat（x, ‘(‘, y, ‘)’) as z from X order by x;  as最好使用它</p><p><strong>常用的文本处理函数</strong></p><p>soundex ：将任何文本串转化为描述其语音表示的字母数字模式算法</p><p>avg函数忽略null 的行</p><p>count函数 ：count（*）对行中所有的书进行计算，不管是包含的还是空值  count（）则忽略</p><p>distinct不能用于count（*）  必须使用列名 不能用于计算或表达式</p><p><strong>别名：</strong>在指定别名以包含某个聚集函数的结果时，不应该使用表中的实际列名；表别名只在查询中使用，与列别名不一样，表别名不返回到客户机</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p> 感谢你的阅读，祝你在 MySQL 的学习和实践中取得更大的成功！  让我们在 MySQL 的海洋中探索更多、学习更多^_^</p>]]></content>
      
      
      <categories>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术分享 </tag>
            
            <tag> 数据分析 </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>frp内网穿透：打开局域网的远程大门</title>
      <link href="/ji-zhu-fen-xiang-frp-nei-wang-chuan-tou.html"/>
      <url>/ji-zhu-fen-xiang-frp-nei-wang-chuan-tou.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在现代科技发展的背景下，越来越多的人需要远程访问他们家庭或办公室网络中的设备。然而，由于网络安全限制，我们常常无法直接从外部访问局域网中的设备。这就是为什么内网穿透技术变得如此重要的原因。本文将向您介绍一种强大的<strong>内网穿透工具——frp</strong>，并向您展示如何使用它轻松实现远程访问。 </p><h1 id="内网穿透"><a href="#内网穿透" class="headerlink" title="内网穿透"></a>内网穿透</h1><h2 id="什么是内网穿透"><a href="#什么是内网穿透" class="headerlink" title="什么是内网穿透"></a>什么是内网穿透</h2><p><strong>内网穿透（NAT穿透）是一种网络技术，用于让外部网络可以访问位于私有内部网络中的设备或服务。</strong>在常见的网络环境中，私有内部网络（如家庭网络或公司局域网）通常使用了网络地址转换（Network Address Translation, NAT）来实现与公共互联网的连接，并将内部网络中的多个设备共享同一个公共IP地址 。</p><h2 id="为什么需要内网穿透"><a href="#为什么需要内网穿透" class="headerlink" title="为什么需要内网穿透"></a>为什么需要内网穿透</h2><p>由于NAT的存在，外部网络无法直接访问内部网络中的设备，因为它们位于不同的网络地址空间中。内网穿透技术通过一些特殊的手段，克服了这个限制，使得外部网络能够穿透NAT，直接与内部网络中的设备进行通信；</p><p><strong>应用场景：</strong></p><p>内网穿透广泛应用于各种场景，例如远程访问家庭网络中的摄像头、远程桌面控制内部计算机、在内网环境中搭建服务器并对外提供服务等。这些应用都依赖于内网穿透技术，使得外部用户能够通过公共网络安全地访问私有网络资源。 </p><h2 id="如何进行内网穿透"><a href="#如何进行内网穿透" class="headerlink" title="如何进行内网穿透"></a>如何进行内网穿透</h2><ol><li>选择合适的内网穿透工具：市场上有许多可供选择的工具，如Ngrok、FRP、花生壳等。根据你的需求和技术要求选择一个适合的工具。</li><li>下载和安装工具：根据所选工具的官方文档，下载并安装相应的内网穿透工具。确保你的操作系统和网络环境与工具的要求相符。</li><li>配置内网穿透工具：每个工具都有自己的配置方式，通常需要指定本地服务的端口号和要使用的域名或公网 IP 地址。按照工具的说明，进行必要的配置。</li><li>启动内网穿透工具：运行工具并启动内网穿透服务。工具会分配一个公共域名或 IP 地址，并将其映射到你指定的本地服务。</li><li>测试连接：使用外部网络，尝试通过工具提供的公共域名或 IP 地址访问你的本地服务。确保能够成功连接和使用。</li></ol><blockquote><p>本文将展示的为 frp内网穿透工具，服务器为centos系统</p></blockquote><h1 id="frp内网穿透"><a href="#frp内网穿透" class="headerlink" title="frp内网穿透"></a>frp内网穿透</h1><h2 id="frp简介"><a href="#frp简介" class="headerlink" title="frp简介"></a>frp简介</h2><p>frp 是一个开源、简洁易用、高性能的内网穿透和反向代理软件，支持 tcp, udp, http, https等协议。</p><p>frp 项目官网是：<a href="https://github.com/fatedier/frp" target="_blank" rel="noopener">https://github.com/fatedier/frp</a></p><p>中文文档：<a href="https://github.com/fatedier/frp/blob/master/README_zh.md" target="_blank" rel="noopener">https://github.com/fatedier/frp/blob/master/README_zh.md</a></p><p>除了安装过程，中文文档对使用过程已经介绍的非常详细，如遇到问题，建议先查看官方文档。</p><h2 id="frp原理"><a href="#frp原理" class="headerlink" title="frp原理"></a>frp原理</h2><ol><li>服务端配置：在公网上搭建一个 FRP 服务器作为中转节点。这个服务器需要有公网 IP 地址或域名，并安装配置好 FRP 服务器软件。</li><li>客户端配置：在内网中需要访问的设备上安装配置 FRP 客户端软件。客户端需要与服务端建立连接，因此需要知道服务器的 IP 地址或域名以及相应的端口号。</li><li>端口映射：在客户端配置文件中指定要映射到公网的本地服务的端口号。当外部请求到达 FRP 服务器时，服务器会将请求转发给客户端，并将客户端上对应端口的数据发送回客户端。</li><li>通信加密：FRP 支持对通信进行加密，以确保数据的安全传输。可以使用预共享密钥或证书来配置加密选项。</li><li>建立连接：客户端通过与 FRP 服务器建立长连接，实时保持与服务器的通信，并监听外部请求。</li><li>外部访问：当外部网络请求到达 FRP 服务器时，服务器将请求转发给客户端，客户端再将请求转发到本地的目标服务，从而实现了内网穿透。</li></ol><h2 id="frp部署"><a href="#frp部署" class="headerlink" title="frp部署"></a>frp部署</h2><h3 id="frp服务端"><a href="#frp服务端" class="headerlink" title="frp服务端"></a>frp服务端</h3><p>服务端建议部署在国内VPS，以提供良好的访问体验。</p><ol><li><p>打开 <a href="https://github.com/fatedier/frp/releases" target="_blank" rel="noopener">frp下载页面</a>，下载最新版的 <code>frp_0.51.0_linux_amd64.tar.gz</code>，然后上传到服务器连接Linux服务器，也可以ssh连接到服务器后用wget下载：</p><pre><code>wget https://github.com/fatedier/frp/releases/download/v0.51.0/frp_0.51.0_linux_amd64.tar.gz</code></pre></li><li><p>服务器上解压安装包： </p><pre><code>tar -zxvf frp_0.51.0_linux_amd64.tar.gz</code></pre></li><li><p>进入解压目录，找到 frps.ini ，填入以下内容：</p><p>vim vim frps.ini </p><pre><code>[common]bind_port = 7000    # frp监听的端口，默认是7000，可以改成其他的token = 3212344784    # 授权码，请改成更复杂的# frp管理后台端口，请按自己需求更改dashboard_port = 7500# frp管理后台用户名和密码，请改成自己的dashboard_user = bevis23dashboard_pwd = 3212344784enable_prometheus = true# frp日志配置log_file = /var/log/frps.loglog_level = infolog_max_days = 3</code></pre></li></ol><ol start="4"><li><p>设置和启动frp服务： </p><pre><code>mkdir -p /etc/frp    ## 创建一个名为 /etc/frp 的目录cp frps.ini /etc/frp    ## 将名为 frps.ini 的文件复制到 /etc/frp 目录中cp frps /usr/bin    ## 将名为 frps 的可执行文件复制到 /usr/bin 目录中，文件负责启动和运行 frps 服务</code></pre><p>创建frps.service文件，该文件用于启动和管理 frps 服务</p><pre><code>vim /etc/systemd/system/frps.service</code></pre><p>填下以下内容</p><pre><code>## 描述了服务的基本信息，如描述和依赖关系[Unit]Description=frps serviceAfter=network.target## 定义了服务的启动参数和命令，ExecStart 指定了启动 frps 的命令行，并通过 -c 参数指定了 frps.ini 配置文件的路径；estart=on-failure 表示在服务失败时会自动重启；User=frps 指定了服务以 frps 用户身份运行。LimitNOFILE=4096 设置了文件描述符的限制，可以根据需要进行调整。[Service]ExecStart=/usr/bin/frps -c /etc/frp/frps.iniRestart=on-failureUser=frpsLimitNOFILE=4096## 指定了服务的安装位置。WantedBy=multi-user.target 表示服务将被添加到多用户目标，以便在系统启动时自动启动。[Install]WantedBy=multi-user.target</code></pre><p>启动服务</p><pre><code>systemctl enable frpssystemctl start frps</code></pre></li><li><p>防火墙放行端口： </p><pre><code>firewall-cmd --permanent --add-port=7000/tcp    ## 添加监听端口firewall-cmd --permanent --add-port=7500/tcp    ## 添加管理后台端口   firewall-cmd --reload</code></pre></li><li><p>浏览器打开“http://服务器IP:后台管理端口” ，输入用户名和密码 </p></li></ol><h3 id="frp客户端"><a href="#frp客户端" class="headerlink" title="frp客户端"></a>frp客户端</h3><ol><li><p>客户端则同上下载对应的压缩包，客户端win，mac，linux对应下载对应的压缩包便可</p></li><li><p>解压，进入压缩包内</p></li><li><p>编辑frp.ini</p><blockquote><p>注意：</p><ol><li><p>一个服务端可以同时给多个客户端使用</p></li><li><p>[ssh]这样的名称必须全局唯一，即就算有多个客户端，也只能使用一次，其他的可以用[ssh2]、[ssh3]等；</p></li><li><p>除了type为http/https，端口只能被一个服务使用</p></li></ol></blockquote></li></ol><pre><code>   [common]    server_addr = 服务器ip   server_port = 7000    ## 请换成设置的服务器端口   token = 3212344784   # 配置ssh服务   [ssh]   type = tcp   local_ip = 127.0.0.1   local_port = 22   remote_port = 自定义的远程服务器端口 如2222   # 配置http服务，可用于小程序开发、远程调试等   [web]   type = http   local_ip = 127.0.0.1   local_port = 8080   subdomain = 子域名   remote_port = 自定义的远程服务器端口 如8080</code></pre><ol start="4"><li><p>登录服务器，防火墙放行监听的端口：</p><pre><code>firewall-cmd --permanent --add-port=2222/tcp  firewall-cmd --permanent --add-port=8080/tcpfirewall-cmd --reload</code></pre></li><li><p>运行</p><p>在windows上，在解压文件夹用./frpc.exe -c frpc.ini</p><p>在linux上，同服务器端设置服务</p></li><li><p>登录frp管理后台，客户端已连接上</p></li></ol><h2 id="frp安全性"><a href="#frp安全性" class="headerlink" title="frp安全性"></a>frp安全性</h2><p>在使用frp进行内网穿透时，安全性是至关重要的。以下是一些安全考虑和最佳实践：</p><ul><li>使用强密码：在frp配置文件中设置强密码以保护服务器和客户端的访问权限。</li><li>加密通信：启用frp的加密功能，确保数据在传输过程中的安全。</li><li>定期更新frp版本：及时更新frp软件以获取最新的安全补丁和功能改进。</li><li>防火墙和访问控制：根据需要，在服务器和客户端上配置防火墙规则和访问控制列表，限制访问权限。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p> 在本文中，我们深入了解了frp内网穿透工具，并展示了它如何帮助我们轻松实现远程访问。通过理解内网穿透技术的背景、掌握frp的原理和配置方法，以及遵循安全考虑和最佳实践，您可以打开局域网的远程大门，轻松访问位于内网的设备。无论是家庭网络、办公网络还是其他场景，frp都是一款功能强大且易于使用的工具，为我们提供了便利和灵活性。现在，您可以尝试使用frp，享受远程访问的便捷与自由！ </p>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> 技术分享 </tag>
            
            <tag> 网络安全 </tag>
            
            <tag> frp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客历程与优化记录</title>
      <link href="/sui-bi-bo-ke-li-cheng-yu-you-hua-ji-lu.html"/>
      <url>/sui-bi-bo-ke-li-cheng-yu-you-hua-ji-lu.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><!-- 本文会记录本站自上线后的一系列优化和美化操作 --><!--同时记录使用的一些相关软件与技术--><blockquote><p> 本文会记录本站自上线后的一系列优化和美化操作 </p><p>同时记录使用的一些相关软件与技术</p></blockquote><p>一直有阅读和记录的习惯，以前都是使用有道云笔记、幕布、来记录自己的资源合集，所见所闻，所思所想； 个人热衷于利用技术工具解决问题，提高效率，享受通过科技创造和创新的过程 ；由于有道云笔记、幕布相对闭源，个人有着开源共享的精神，便萌生了建立这个博客网站的想法，开始搭建网站，选择hexo搭建，原因：完全免费且可以根据自己喜好更改</p><h2 id="为什么写博客，做博客网站："><a href="#为什么写博客，做博客网站：" class="headerlink" title="为什么写博客，做博客网站："></a><strong>为什么写博客，做博客网站：</strong></h2><ol><li>对知识点总结、回顾、思考 、 加深对技术理解 ， 给自己的岁月留下痕迹</li><li>提高个人的技术写作和思维能力 ， 提高快速解决问题的思维角度</li><li>锻炼自己规划，构建项目的能力，站在巨人的肩膀上，自己再对个人博客网站布局，模块设计，功能增加</li><li>帮助别人， 别人通过我的博客学习到一些知识，技能，解决问题的方法</li><li>更好的介绍自己 ，认识更多志同道合朋友</li><li>拥有一片只属于自己的净土，自由无拘束，写写文章，在这个世界上多留下点自己来过的痕迹</li></ol><blockquote><p>该博客主要采用的框架为Hexo，主题为matery，主要环境配置为 Node.js， npm包管理器， 博客托管于github page，到此，我的博客网站便初步搭建完成了。有关hexo和matery、其他的操作这里不再做赘述 </p></blockquote><h1 id="相关技术支持与使用"><a href="#相关技术支持与使用" class="headerlink" title="相关技术支持与使用"></a>相关技术支持与使用</h1><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p>Sublime Text：用于编辑代码，修改配置文件等</p><p>Typora：作为markdown编辑器，用于写文章</p><p>PicGo：图片上传工具，配合github作为图床</p><p>Snipaste：截图工具</p><p>git：hexo部署，上传</p><h2 id="技术支持"><a href="#技术支持" class="headerlink" title="技术支持"></a>技术支持</h2><p>github page：用于托管网站</p><p>github仓库：搭建图床</p><p>jsdlivr：图床cdn加速</p><p>netlify：整个网站托管，cdn加速</p><h1 id="美化优化"><a href="#美化优化" class="headerlink" title="美化优化"></a>美化优化</h1><h2 id="主题CSS样式配置"><a href="#主题CSS样式配置" class="headerlink" title="主题CSS样式配置"></a>主题CSS样式配置</h2><p>全局css样式配置，导航栏颜色渐变， 让博客网站具有独特的外观和风格 </p><h2 id="首页轮播图渐变更新"><a href="#首页轮播图渐变更新" class="headerlink" title="首页轮播图渐变更新"></a>首页轮播图渐变更新</h2><p>轮播图通过渐变更新的方式，可以展示多个精选文章或特色内容，让读者快速了解网站的亮点 </p><h2 id="不蒜子计数"><a href="#不蒜子计数" class="headerlink" title="不蒜子计数"></a>不蒜子计数</h2><p> 实时显示每篇文章的访问数量，网站浏览量，访问人数，提供数据参考和反馈 </p><h2 id="动态线条构建"><a href="#动态线条构建" class="headerlink" title="动态线条构建"></a>动态线条构建</h2><p>背景涌动线条，增加网站的动感和现代感 </p><h2 id="添加看板娘"><a href="#添加看板娘" class="headerlink" title="添加看板娘"></a>添加看板娘</h2><p> 增加博客网站的趣味性和人情味，眼部追随鼠标点击方向</p><h2 id="护眼模式昼夜转换"><a href="#护眼模式昼夜转换" class="headerlink" title="护眼模式昼夜转换"></a>护眼模式昼夜转换</h2><p> 添加夜间与白天模式切换功能 ， 可以根据自己的喜好选择合适的页面背景和文本颜色 </p><h2 id="天气插件"><a href="#天气插件" class="headerlink" title="天气插件"></a>天气插件</h2><p> 添加一个天气插件，显示当前的天气信息，可以方便地查看天气情况，为未来的出行或活动做准备 </p><h2 id="导航栏功能增加"><a href="#导航栏功能增加" class="headerlink" title="导航栏功能增加"></a>导航栏功能增加</h2><p>添加极客导航一栏，实现链接跳转，从静态网站跳转到个人可以方便更新，方便交互，且分类清晰的“库”，这是个人巧妙利用了其它可开源的记录软件结合，让博客有更好的资源收集跳转地，也方便读者寻找我所收集的资源</p><h2 id="每日60秒读懂世界"><a href="#每日60秒读懂世界" class="headerlink" title="每日60秒读懂世界"></a>每日60秒读懂世界</h2><p> 增加博客网站的独特性和更新频率，通过调用api，每天更新15则新闻和一条微语， 读者在短时间内获取有价值的知识和信息 </p><h2 id="文章右侧目录联动"><a href="#文章右侧目录联动" class="headerlink" title="文章右侧目录联动"></a>文章右侧目录联动</h2><p>文章旁侧的目录导航，可进度拖动</p><h2 id="全局滚动条更改"><a href="#全局滚动条更改" class="headerlink" title="全局滚动条更改"></a>全局滚动条更改</h2><p>更改滚动条样式美化</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>Hexo博客的搭建，是一点点优化起来的，Hexo 的灵活性较高，可以自定义主题、布局和功能，满足更多定制化需求。根据自己的喜好，打造一个自己喜欢的网站作品，这不断优化的期间，让自己收获不少；</p><p>个人博客网站，是一个属于自己的天地，乐在其中<del>~</del></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
            <tag> 随笔 </tag>
            
            <tag> 分享 </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>samba服务器搭建配置与连接公网</title>
      <link href="/ji-zhu-fen-xiang-samba.html"/>
      <url>/ji-zhu-fen-xiang-samba.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>本文将呈现 ： 1.samba服务的相关背景与原理  2.samba服务的搭建与配置（针对内网）  3.配置win10连接公网ip连接samba服务（针对公网）</p><p>之前服务器于搭建chatgpt的微信机器人后，闲暇之余想做个文件服务器，选择了samba做文件共享，轻松搞定于局域网共享，但由于要给远方的朋友也使用，便有了让远方朋友连接公网ip的samba服务器，由于考虑到端口问题，比如445端口（注释），所以得突破这个点，后面有了一个思路，便是通过 netsh来设置端口映射</p><blockquote><p>注释！</p><p>samba是默认使用445端口进行通信，且服务针对windows， windows 默认连的是 445 端口 </p><p>2017年5月，出现了永恒之蓝病毒（比特币勒索病毒）， 永恒之蓝（EternalBlue）是一种利用Windows操作系统中的漏洞进行攻击的网络蠕虫病毒。它最初由美国国家安全局（NSA）开发，在泄露后被黑客组织使用，给全球范围内的计算机系统带来了严重的影响。  由此导致运营商（内地三大运营服务商）把 445 端口封了，因此现在无法通过 445 端口连接你的 linux 服务器了</p></blockquote><h1 id="1-samba服务简介"><a href="#1-samba服务简介" class="headerlink" title="1.samba服务简介"></a>1.samba服务简介</h1><h2 id="1-1什么是samba服务"><a href="#1-1什么是samba服务" class="headerlink" title="1.1什么是samba服务"></a>1.1什么是samba服务</h2><p> Samba是一个能让Linux系统应用Microsoft网络通讯协议的软件，而SMB是<strong>Server Message Block</strong>的缩写，即为服务器消息块 ，SMB主要是作为Microsoft的网络通讯协议，后来Samba将SMB通信协议应用到了Linux系统上，就形成了现在的Samba软件；Samba提供了一种在不同操作系统之间共享文件、打印机和其他资源的方法。它的本质是一个实现了SMB/CIFS协议的服务器软件，允许不同操作系统的计算机之间进行文件共享和通信。</p><h2 id="1-2samba服务的应用"><a href="#1-2samba服务的应用" class="headerlink" title="1.2samba服务的应用"></a>1.2samba服务的应用</h2><p><strong>Samba能做什么？</strong></p><ul><li><p>分享档案与打印机服务</p></li><li><p>可以提供用户登入Samba主机时的身份认证，以提供不同身份者的个别数据。</p></li><li><p>可以进行windows网络上的主机名解析</p></li><li><p>可以进行装置的分享</p><p><strong>Samba服务器的应用实例：</strong></p></li><li><p>利用软件直接编修WWW主机上面的网页数据</p><ul><li>用FTP修改，后上传；不方便，很有可能传上去旧版本的。</li><li>在线修改比较能迅速看到结果。</li></ul></li><li><p>做成可直接联机的文件服务器</p><ul><li>因为每个人登陆的账户名不同，这样对目录的权限也不同，实现权限控制。</li></ul></li></ul><h1 id="2-samba服务器的搭建（内网）"><a href="#2-samba服务器的搭建（内网）" class="headerlink" title="2.samba服务器的搭建（内网）"></a>2.samba服务器的搭建（内网）</h1><h2 id="第一步：安装samba服务"><a href="#第一步：安装samba服务" class="headerlink" title="第一步：安装samba服务"></a>第一步：安装samba服务</h2><pre class=" language-linux"><code class="language-linux">yum -y install samba*    ## 安装samba服务systemctl start smb      ## 启动服务systemctl enable smb    ##让系统在引导时自动启动 Samba 服务firewall-cmd --permanent --add-service=samba## 防火墙添加 Samba 服务的规则，允许传入和传出与 Samba 相关的网络流量，--permanent 参数表示将规则永久保存，以便在系统重启后仍然有效firewall-cmd --reload   ## 有permanent参数的时候需要马上重载生效getenforce ## 获取 SELinux 当前的执行模式，此时为permissive模式便可，否则使用命令：setenforce 0          ## Enforcing：表示 SELinux 正在强制执行安全策略，并且会拒绝违反策略的操作。          ## Permissive：表示 SELinux 已被启用，但仅会记录违反策略的操作而不阻止它们。          ## Disabled：表示 SELinux 已被禁用，不会对系统进行强制访问控制。</code></pre><h2 id="第二步：Samba服务的配置"><a href="#第二步：Samba服务的配置" class="headerlink" title="第二步：Samba服务的配置"></a>第二步：Samba服务的配置</h2><p> Samba服务的主要配置文件为：/etc/sambs/smb.conf , 主配置文件由两部分构成：Global 部分和 Share 部分</p><h3 id="1-global部分："><a href="#1-global部分：" class="headerlink" title="1.global部分："></a>1.global部分：</h3><p>该设置都是与Samba服务整体运行环境有关的选项，它的设置项目是针对所有共享资源的</p><pre><code>cat /etc/samba/smb.conf  # 查看配置文件内容# 文件内容如下,更详细的smb.conf配置内容可以上网查找，这里做部分注释# See smb.conf.example for a more detailed config file or# read the smb.conf manpage.# Run &#39;testparm&#39; to verify the config is correct after# you modified it.[global] #全局参数：该设置都是与Samba服务整体运行环境有关的选项，它的设置项目是针对所有共享资源的        workgroup =MYGROUP           #设定Samba Server所要加入的工作组或域        security = user        #安装验证方式，总共有四种，目前不再支持share级别        passdb backend = tdbsam        #定义用户后台类型，总共有三种        printing = cups        printcap name = cups        load printers = yes        #设置在Samba服务启动时是否共享打印机设备        cups options = raw        #打印机的选项[homes]        comment = Home Directories #描述信息        valid users = %S, %D%w%S  #有效访问用户        path = ~         #文件路径        browseable = No   #指定共享信息是否在“网上邻居”中可见        read only = No    #是否只读        inherit acls = Yes [printers]        comment = All Printers        path = /var/tmp #共享文件的实际路径。        printable = Yes        create mask = 0600        browseable = No[print$]        comment = Printer Drivers        path = /var/lib/samba/drivers        write list = root        create mask = 0664        directory mask = 0775</code></pre><h3 id="2-share部分："><a href="#2-share部分：" class="headerlink" title="2.share部分："></a>2.share部分：</h3><p>该设置针对的是共享目录个别的设置，只对当前的共享资源起作用</p><pre><code>vim /etc/samba/smb.conf## 在文件最后添加以下，此为测试[share]    comment = Share Directories  ## 这个参数提供对共享资源的描述    path=/www/share  ## 指定了要共享的目录路径    public = yes    ## public用来指定该共享是否允许guest账户访问    browseable = yes ## 共享将在网络上可见    writable = yes    ## 设置共享的可写性</code></pre><p>：wq！保存退出</p><p>还有其他参数可自行 选择设置： <strong>valid users = 允许访问该共享的用户</strong> ； <strong>invalid users = 禁止访问该共享的用户</strong> ； <strong>write list = 允许写入该共享的用户</strong> </p><pre><code>systemctl restart smb.service    ## 重启smb服务## 添加Samba用户smbpasswd –a username    ## 设置Samba用户的密码pdbedit –a username        ## 向Samba数据库中添加用户pdbedit -L    ## 查看已注册的Samba用户列表在Windows运行中键入\\Server_IP验证注意：：：第二次连接更换用户需要运行：net  use  *  /d  /y</code></pre><p>到此，服务器配置便完成</p><h1 id="3-samba服务配置连接（公网）"><a href="#3-samba服务配置连接（公网）" class="headerlink" title="3.samba服务配置连接（公网）"></a>3.samba服务配置连接（公网）</h1><p>在引言已经提到，由于永恒之蓝病毒的影响，445端口已封，目前无法通过 445 端口连接你的 linux 服务器了，下面的操作便是利用 netsh 来绕过这个端口，接下来介绍该工具与实现方法</p><h2 id="netsh简介"><a href="#netsh简介" class="headerlink" title="netsh简介"></a>netsh简介</h2><p> <strong>功能：</strong>Netsh是Windows操作系统中的命令行脚本实用工具，用于管理和配置网络功能 </p><p><strong>命令语法：</strong> 命令语法：Netsh命令的基本语法为 netsh <context> <subcontext> command </subcontext></context></p><blockquote><p>想要更多关于特定”netsh”命令及其用法的信息，可以在命令提示符中输入<code>netsh /?</code>或<code>netsh command /?</code>来查看内置帮助系统 </p></blockquote><h2 id="netsh实现本机端口映射"><a href="#netsh实现本机端口映射" class="headerlink" title="netsh实现本机端口映射"></a>netsh实现本机端口映射</h2><blockquote><p>更换原本的445端口 设置本机端口映射到你那台 samba 的 linux 服务器的 1314 端口。最后，你就可以通过<code>\\127.0.0.1</code>访问你的文件共享服务了 </p></blockquote><ol><li><h3 id="配置smb-conf，更改端口，-修改-Samba-主配置文件：-etc-samba-smb-conf-通过参数smb-ports-将-Samba-的端口更改为：1314，然后重启服务"><a href="#配置smb-conf，更改端口，-修改-Samba-主配置文件：-etc-samba-smb-conf-通过参数smb-ports-将-Samba-的端口更改为：1314，然后重启服务" class="headerlink" title="配置smb.conf，更改端口， 修改 Samba 主配置文件：/etc/samba/smb.conf ;通过参数smb ports 将 Samba 的端口更改为：1314，然后重启服务"></a>配置smb.conf，更改端口， 修改 Samba 主配置文件：/etc/samba/smb.conf ;通过参数smb ports 将 Samba 的端口更改为：1314，然后重启服务</h3><pre><code>vim /etc/samba/smb.conf# See smb.conf.example for a more detailed config file or# read the smb.conf manpage.# Run &#39;testparm&#39; to verify the config is correct after# you modified it.[global]        workgroup = SAMBA        security = user        passdb backend = tdbsam        printing = cups        printcap name = cups        load printers = yes        cups options = raw        smb ports = 1314 ## 添加此行systemctl restart smb.service    ## 重启服务## 查看端口[root@miyi_server ~]# netstat -nplt | grep smbtcp        0      0 0.0.0.0:1314            0.0.0.0:*               LISTEN      7528/smbdtcp6       0      0 :::1314                 :::*                    LISTEN      7528/smbdsamba服务配置到此完成</code></pre></li><li><h3 id="配置win10"><a href="#配置win10" class="headerlink" title="配置win10"></a>配置win10</h3><ol><li><p><strong>关闭 windows 的 445 端口</strong> ：</p><pre><code>## 使用cmd命令行关闭，也可通过任务管理器的服务里找到， 445 端口应该是一直被 LanmanServer 占用的，Windows共享服务的显示名称为Server，实际服务名为LanmanServer，为文件共享服务；sc config LanmanServer start= disablednet stop LanmanServer</code></pre></li><li><p><strong>启动 windows 的 ip helper 服务</strong> ：</p><pre><code>## sc config iphlpsvc start= auto用于配置Windows中“IP Helper”服务的启动类型。通过将其设置为“自动”，您将指示Windows在系统启动期间自动启动IP Helper服务，此ip helper用来搞端口转发sc config iphlpsvc start= auto</code></pre></li><li><p><strong>设置 windows 端口转发</strong> ：</p><pre><code>## connectaddress后为公网ip地址，运行后无显示，后用netsh interface portproxy add v4tov4 listenport=445 connectaddress=xxx.xx.xxx.xx connectport=1314## 注意：必须重启电脑，且服务器对应开启1314端口## 查看转发的端口:netsh interface portproxy show v4tov4</code></pre><p><img src="https://cdn.jsdelivr.net/gh/Bevis23/blog-pic/%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84.png" alt="端口映射"></p></li><li><p><strong>输入<code>\\127.0.0.1</code>访问服务器文件</strong>：</p><p>同内网一样的用户操作，权限操作，区别就是内网访问是同个同个网段的ip访问，而这个是通过访问 本地回环地址 ， 通过监听的本地端口号 ， 进行端口转发，将传入的连接从本地计算机的445端口转发到指定的目标 IP 地址和端口号 </p></li></ol></li></ol><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>samba服务的内外网连接到此为止，对于内网上的samba是相当方便的，对于公网上的连接，有这样的一个思路和方法，同样也算不错的； </p><p>结束之余，也想到了用内网穿透的方法，这里没去实现，顺带提一下</p><h2 id="内网穿透"><a href="#内网穿透" class="headerlink" title="内网穿透"></a>内网穿透</h2><p>内网穿透一般的步骤和方法：</p><ol><li>配置Samba服务器：首先，您需要在本地网络中配置并启动Samba服务器。确保Samba服务器已正确设置并具有共享文件夹。</li><li>选择内网穿透工具：选择一个适合您需求的内网穿透工具。常用的内网穿透工具包括ngrok、frp、inlets等。这些工具允许您创建一个隧道，将公网请求转发到本地网络。</li><li>下载和配置内网穿透工具：根据您选择的工具，下载并安装相应的软件。按照工具提供的说明进行配置，将本地Samba服务器的端口映射到公网IP上。</li><li>启动内网穿透服务：运行内网穿透工具并启动隧道服务。该服务会为您生成一个公网可访问的地址，将流量转发到本地Samba服务器。</li><li>访问Samba服务器：使用生成的公网地址，您就可以从任何具有互联网连接的设备上访问Samba服务器了。只需将生成的地址输入到Samba客户端中，即可连接到Samba服务器并访问共享文件夹。</li></ol><p>使用内网穿透技术会涉及到网络安全方面的问题。确保已经采取了必要的安全措施，如设置强密码、使用加密连接等，以保护的Samba服务器和数据的安全性。</p><p>   记录<del>~</del>收工</p>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 服务器 </tag>
            
            <tag> 技术分享 </tag>
            
            <tag> samba </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>宝塔面板-简化服务器管理与部署的利器</title>
      <link href="/gong-ju-bao-ta.html"/>
      <url>/gong-ju-bao-ta.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p> 在当今数字化时代，拥有一个稳定高效的服务器以及能够轻松管理和部署应用程序的能力对于个人用户和小型企业来说至关重要。然而，服务器管理和应用程序部署常常需要专业知识和复杂的操作步骤，给非技术背景的用户带来了挑战。正是为了解决这一问题，宝塔面板应运而生。宝塔面板以其简单易用、功能强大的特点，成为了许多人理想的选择。 </p><h1 id="宝塔简介"><a href="#宝塔简介" class="headerlink" title="宝塔简介"></a>宝塔简介</h1><p> 宝塔面板是一款服务器管理软件，可以帮助用户建立网站，一键配置服务器环境，使得用户通过web界面就可以轻松的管理安装所用的服务器软件。  </p><!--主要特点和功能：--> <ol><li>简单易用：宝塔提供直观的Web界面，使服务器管理变得简单易用，即使对于没有专业技术知识的用户也能轻松上手。</li><li>多服务器管理：通过宝塔，您可以同时管理多个服务器，包括虚拟私有服务器（VPS）、独立服务器等，无需登录到每个服务器进行管理。</li><li>网站管理：宝塔支持快速创建、删除、备份和恢复网站，还可以管理域名、SSL证书、FTP账号等。</li><li>数据库管理：宝塔提供MySQL、Redis、MongoDB等常用数据库的管理功能，可以方便地创建数据库、导入导出数据、管理用户等。</li><li>文件管理：通过宝塔的文件管理器，您可以在Web界面中直接管理服务器上的文件和目录，进行上传、下载、编辑等操作。</li><li>应用程序部署：宝塔支持一键安装各种流行的Web应用程序，如WordPress、Joomla、Discuz等，让您能够快速搭建网站。</li><li>监控和统计：宝塔提供实时的服务器资源监控和统计数据，包括CPU、内存、磁盘使用情况等，方便您了解服务器的运行状态。</li><li>安全性：宝塔内置了防火墙、安全加固等功能，可以提高服务器的安全性，减少潜在的风险。</li></ol><h1 id="宝塔的安装"><a href="#宝塔的安装" class="headerlink" title="宝塔的安装"></a>宝塔的安装</h1><p> <strong>宝塔官网地址：<a href="https://www.bt.cn/new/index.html" target="_blank" rel="noopener">https://www.bt.cn/new/index.html</a></strong> </p><p>操作步骤：</p><ol><li><p>访问官网，点击“立即免费安装”</p></li><li><p>点击“安装脚本”</p></li><li><p>根据自己服务器系统，选择对应的脚本，我的服务器部署的是Centos系统，所以我这里选择的是Centos安装脚本</p></li><li><p>复制命令执行命令进行安装</p><pre class=" language-linux"><code class="language-linux">yum install -y wget && wget -O install.sh http://download.bt.cn/install/install_6.0.sh && sh install.sh</code></pre></li><li><p>安裝成功效果图，将端口信息和账号密码等保存记录起来</p><img src="https://cdn.jsdelivr.net/gh/Bevis23/blog-pic/%E9%9D%A2%E6%9D%BF%E5%AE%89%E8%A3%85%E6%88%90%E5%8A%9F.png" style="zoom:50%;"></li><li><p>服务器安全组添加36085端口规则</p><img src="https://cdn.jsdelivr.net/gh/Bevis23/blog-pic/%E5%AE%9D%E5%A1%94%E7%AB%AF%E5%8F%A3%E6%B7%BB%E5%8A%A0.png" style="zoom:50%;"></li></ol><h1 id="宝塔面板的使用"><a href="#宝塔面板的使用" class="headerlink" title="宝塔面板的使用"></a>宝塔面板的使用</h1><ol><li><h2 id="登录宝塔面板"><a href="#登录宝塔面板" class="headerlink" title="登录宝塔面板"></a>登录宝塔面板</h2><ol><li>在浏览器地址栏中输入所记录的外网面板地址，例如：<a href="http://ip：端口号/面板值" target="_blank" rel="noopener">http://ip：端口号/面板值</a></li><li>出现登录界面：输入刚才记录的账号和密码，点击“登录”</li><li>勾选“我已阅读并同意‘用户协议’”</li><li>绑定宝塔账号： 第一次登录需要绑定宝塔账号，要是有宝塔账号的直接登录就可以，没有的话就先去注册一个再进行登录 </li></ol></li><li><h2 id="安装环境套件"><a href="#安装环境套件" class="headerlink" title="安装环境套件"></a>安装环境套件</h2><ol><li>首次使用宝塔面板推荐安装一组套件，对于刚接触Linux环境部署的博友们，推荐使用<em>LNMP</em>，采用极速安装、一键安装的方式 <!-- LNMP和LAMP环境主要的区别在于web服务器上面，LNMP使用的是Nginx服务器，而LAMP使用的是Apache服务器。Nginx 性能稳定、功能丰富、运维简单、处理静态文件速度快且消耗系统资源极少。 --></li></ol></li><li><h2 id="宝塔面板首页介绍"><a href="#宝塔面板首页介绍" class="headerlink" title="宝塔面板首页介绍"></a>宝塔面板首页介绍</h2><p><img src="https://cdn.jsdelivr.net/gh/Bevis23/blog-pic/%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF%E4%BB%8B%E7%BB%8D.png" alt></p><ol><li>系统操作<br>显示当前服务器系统类型、服务器运行时间、面板版本、面板升级更新入口、并提供宝塔账号绑定、微信小程序绑定、服务器重启、面板重启、修复面板等快捷功能。</li><li>服务器状态<br>显示当前服务器CPU、内存、硬盘的使用率、内存清理，所有状态均取自服务器真实数据。<br>内存的清理：点击内存图标中的小火箭图标，即可实现清理功能。</li><li>站点信息<br>显示当前面板管理的站点、FTP、数据库数量，仅提供数量显示，如需添加站点，请在网站选项中添加站点。</li><li>软件管理<br>首页软件快速方式，可以实现拖动图片，更换顺序、管理软件等功能。</li><li>网络流量<br>实时显示当前服务器网络流量的上传和下载速度，总上传流量，总下载流量。<br>注：当前网络流量数据，直接取自网卡数据，包含内外网流量。</li></ol></li></ol><p>   到此为止宝塔面板便安装成功，使用的话针对各自需求来做， 宝塔面板作为一款简化服务器管理和应用程序部署的利器，具有诸多优势。它提供了直观的Web界面，使得服务器管理变得简单~ </p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>   总之，宝塔作为一款强大而全面的服务器管理面板软件，为用户提供了简化服务器管理和网站运维的便利。无论是初学者还是有经验的开发人员，都可以通过宝塔轻松地搭建、配置和管理自己的服务器和网站。它提供了丰富的功能，包括网站管理、数据库管理、文件管理、应用管理、服务器监控、安全设置和DNS管理等。通过宝塔，您可以更加高效地管理和维护您的服务器和网站，节省时间和精力，使您能够专注于更重要的任务和项目。无论是个人网站、企业网站还是开发团队，宝塔都是一个值得推荐和使用的优秀工具。 让它成为你提高效率的工具吧<del>~</del></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 工具 </tag>
            
            <tag> 可视化 </tag>
            
            <tag> 服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>chatgpt-prompt工程</title>
      <link href="/ai-chatgpt-prompt-gong-cheng.html"/>
      <url>/ai-chatgpt-prompt-gong-cheng.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>​        在人工智能技术的不断发展中，chatgpt 这一强大的聊天机器人应运而生 ；强大的AI模型，在聊天对话中，展示的能力有目共睹；在大家都享用AI带来的某些便利的时候，心细的人已经发现了一个问题——AI对于不同的提问，给出的回答，存在着一些差距；因此，提示词（prompt）的重要性便显现出来了；</p><p>​         本文将探讨如何充分利用 prompt 的力量，旨在帮助读者更好地与 GPT 进行互动。我们将介绍一些有效的 prompt 设计策略，并分享一些提示和技巧，使您能够通过巧妙构建 prompt 的方式，获得令人满意的回答和交流结果。 </p><!--注：本文根据开源文章，结合吴恩达prompt工程公开课总结，右边目录栏快速选择需要的内容--><blockquote><p>在我的导航栏里的AI板块，可以详见更多AI有关的知识；  针对prompt提示工程，有吴恩达的提示词公开课总结</p></blockquote><h1 id="Prompt-工程技术简介"><a href="#Prompt-工程技术简介" class="headerlink" title="Prompt 工程技术简介"></a>Prompt 工程技术简介</h1><h2 id="什么是-Prompt-工程？"><a href="#什么是-Prompt-工程？" class="headerlink" title="什么是 Prompt 工程？"></a>什么是 Prompt 工程？</h2><p> Prompt 工程是创建提示或指导像 ChatGPT 这样的语言模型输出的过程。它允许用户控制模型的输出并生成符合其特定需求的文本 </p><h2 id="prompt组成元素"><a href="#prompt组成元素" class="headerlink" title="prompt组成元素"></a>prompt组成元素</h2><ul><li>任务：对提示要求模型生成的内容进行清晰而简洁的陈述。</li><li>指令：在生成文本时模型应遵循的指令。</li><li>角色：模型在生成文本时应扮演的角色。</li></ul><h2 id="prompt原则"><a href="#prompt原则" class="headerlink" title="prompt原则"></a>prompt原则</h2><pre><code>​​Principles of PromptingPrinciple1——Write clear and specific instructionsPrinciple 2——Give the model time to think原则一：写清楚清晰和具体结构的指令策略1：使用分隔符Triple quotes:&quot;&quot;&quot;Triple backticks:&#39;&#39;&#39;Triple dashes:---Angle brackets:&lt; &gt;XML tags:策略2：要求结构化输出HTML、JSON策略3：要求模型检查是否满足指令条件 (ifelse)策略4：few-shot 提示给出完成任务的成功例子然后要求模型执行任务；即提供少量示例，如文本风格或语气原则二：给模型足够时间来思考策略1：指定完成任务所需的步骤策略2：指导模型自己尝试解答问题后再对需要决策的指令对比判断​​模型的局限性虚假知识:模型给出看似真实实则编造的知识，即“一本正经的胡说八道”解决方案按照两个原则进行提示要求模型找到文本中的任何相关引用要求模型使用引用来回答问题</code></pre><h2 id="prompt的优化迭代"><a href="#prompt的优化迭代" class="headerlink" title="prompt的优化迭代"></a>prompt的优化迭代</h2><pre><code>第一个提示是否有效不里要，重要的是找到最终有效提示的过程  一轮选代的步骤：  1.按照两个提示原则简化第一个提示  2.分析指令不清晰或未给足模型间思考的步骤  3.改进生成新的提示在多个样本上迭代开发测试比较性能‘让我们一步一步思考’——提升回答的逻辑性</code></pre><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p><img src="https://cdn.jsdelivr.net/gh/Bevis23/blog-pic/%E5%BA%94%E7%94%A8.png" alt="应用"></p><h1 id="指令提示技术"><a href="#指令提示技术" class="headerlink" title="指令提示技术"></a>指令提示技术</h1><p> 指令提示技术是通过为模型提供具体指令来引导ChatGPT的输出 ， 确保输出相关和高质量 内容；</p><pre><code>提示公式：“按照以下指示生成[任务]：[指令]”</code></pre><p>示例：</p><h2 id="生成客户服务响应："><a href="#生成客户服务响应：" class="headerlink" title="生成客户服务响应："></a><strong>生成客户服务响应：</strong></h2><ul><li>任务：生成响应客户查询</li><li>指令：响应应该专业且提供准确的信息</li><li>提示公式：“按照以下指示生成专业且准确的客户查询响应：响应应该专业且提供准确的信息。”</li></ul><h2 id="生成法律文件："><a href="#生成法律文件：" class="headerlink" title="生成法律文件："></a><strong>生成法律文件：</strong></h2><ul><li>任务：生成法律文件</li><li>指令：文件应符合相关法律法规</li><li>提示公式：“按照以下指示生成符合相关法律法规的法律文件：文件应符合相关法律法规。”</li></ul><h1 id="角色提示"><a href="#角色提示" class="headerlink" title="角色提示"></a>角色提示</h1><p> 角色提示技术是通过为ChatGPT指定一个特定的角色来引导其输出的一种方式，生成针对特定上下文或受众的文本 </p><pre><code>提示公式：“作为[角色]生成[任务]”</code></pre><p>示例：</p><h2 id="生成客户服务回复："><a href="#生成客户服务回复：" class="headerlink" title="生成客户服务回复："></a><strong>生成客户服务回复：</strong></h2><ul><li>任务：生成对客户查询的回复</li><li>角色：客户服务代表</li><li>提示公式：“作为客户服务代表，生成对客户查询的回复。”</li></ul><h2 id="生成法律文件：-1"><a href="#生成法律文件：-1" class="headerlink" title="生成法律文件："></a><strong>生成法律文件：</strong></h2><ul><li>任务：生成法律文件</li><li>角色：律师</li><li>提示公式：“作为律师，生成法律文件。”</li></ul><h2 id="角色提示技术与指令提示和种子词提示结合使用"><a href="#角色提示技术与指令提示和种子词提示结合使用" class="headerlink" title="角色提示技术与指令提示和种子词提示结合使用"></a>角色提示技术与指令提示和种子词提示结合使用</h2><p><strong>下面是一个示例，展示了如何将指令提示、角色提示和种子词提示技术结合使用：</strong></p><ul><li>任务：为新智能手机生成产品描述</li><li>指令：描述应该是有信息量的，具有说服力，并突出智能手机的独特功能</li><li>角色：市场代表 种子词：“创新的”</li><li>提示公式：“作为市场代表，生成一个有信息量的、有说服力的产品描述，突出新智能手机的创新功能。该智能手机具有以下功能[插入您的功能]”</li></ul><p>结合使用可以增强ChatGPT的输出 </p><h1 id="标准提示"><a href="#标准提示" class="headerlink" title="标准提示"></a>标准提示</h1><p> 标准提示是一种简单的方法，通过为模型提供一个特定的任务来引导ChatGPT的输出；</p><pre><code>提示公式：“生成一个[任务]”</code></pre><p>例如：</p><h2 id="生成新闻文章的摘要："><a href="#生成新闻文章的摘要：" class="headerlink" title="生成新闻文章的摘要："></a><strong>生成新闻文章的摘要：</strong></h2><ul><li>任务：总结这篇新闻文章</li><li>提示公式：“生成这篇新闻文章的摘要”</li></ul><h2 id="生成一篇产品评论："><a href="#生成一篇产品评论：" class="headerlink" title="生成一篇产品评论："></a><strong>生成一篇产品评论：</strong></h2><ul><li>任务：为一款新智能手机撰写评论</li><li>提示公式：“生成这款新智能手机的评论”</li></ul><h2 id="将标准提示、角色提示和种子词提示技术结合使用的示例："><a href="#将标准提示、角色提示和种子词提示技术结合使用的示例：" class="headerlink" title="将标准提示、角色提示和种子词提示技术结合使用的示例："></a><strong>将标准提示、角色提示和种子词提示技术结合使用的示例：</strong></h2><ul><li>任务：为一台新笔记本电脑撰写产品评论</li><li>说明：评论应客观、信息丰富，强调笔记本电脑的独特特点</li><li>角色：技术专家</li><li>种子词：“强大的”</li><li>提示公式：“作为一名技术专家，生成一个客观而且信息丰富的产品评论，强调新笔记本电脑的强大特点。”</li></ul><h1 id="零、一和少样本提示"><a href="#零、一和少样本提示" class="headerlink" title="零、一和少样本提示"></a>零、一和少样本提示</h1><p>零样本、一样本和少样本提示是用于从ChatGPT生成文本的技术，最少或没有任何示例。当特定任务的数据有限或任务是新的且未定义时，这些技术非常有用。</p><p>当任务没有可用的示例时，使用零样本提示技术。模型提供一个通用任务，根据对任务的理解生成文本。</p><p>当任务只有一个示例可用时，使用一样本提示技术。模型提供示例，并根据对示例的理解生成文本。</p><p>当任务只有有限数量的示例可用时，使用少样本提示技术。模型提供示例，并根据对示例的理解生成文本。</p><pre><code>提示公式：“基于[数量]个示例生成文本”</code></pre><p>例如：</p><h2 id="为没有可用示例的新产品编写产品描述："><a href="#为没有可用示例的新产品编写产品描述：" class="headerlink" title="为没有可用示例的新产品编写产品描述："></a><strong>为没有可用示例的新产品编写产品描述：</strong></h2><ul><li>任务：为新的智能手表编写产品描述</li><li>提示公式：“基于零个示例为这款新智能手表生成产品描述”</li></ul><h2 id="使用一个示例生成产品比较："><a href="#使用一个示例生成产品比较：" class="headerlink" title="使用一个示例生成产品比较："></a><strong>使用一个示例生成产品比较：</strong></h2><ul><li>任务：将新款智能手机与最新的iPhone进行比较</li><li>提示公式：“使用一个示例（最新的iPhone）为这款新智能手机生成产品比较”</li></ul><h2 id="使用少量示例生成产品评论："><a href="#使用少量示例生成产品评论：" class="headerlink" title="使用少量示例生成产品评论："></a><strong>使用少量示例生成产品评论：</strong></h2><ul><li>任务：为新的电子阅读器撰写评论</li><li>提示公式：“使用少量示例（3个其他电子阅读器）为这款新电子阅读器生成评论”</li></ul><h1 id="“让我们思考一下”提示"><a href="#“让我们思考一下”提示" class="headerlink" title="“让我们思考一下”提示"></a>“让我们思考一下”提示</h1><p> “让我们思考一下”提示是一种技巧，可鼓励ChatGPT生成反思和思考性的文本。这种技术适用于撰写论文、诗歌或创意写作等任务 。</p><p>例如：</p><h2 id="生成一篇反思性论文："><a href="#生成一篇反思性论文：" class="headerlink" title="生成一篇反思性论文："></a><strong>生成一篇反思性论文：</strong></h2><ul><li>任务：就个人成长主题写一篇反思性论文</li><li>提示公式：“让我们思考一下：个人成长”</li></ul><h2 id="生成一首诗："><a href="#生成一首诗：" class="headerlink" title="生成一首诗："></a><strong>生成一首诗：</strong></h2><ul><li>任务：写一首关于季节变化的诗</li><li>提示公式：“让我们思考一下：季节变化”</li></ul><p>这个提示要求对特定主题或想法展开对话或讨论。发言者邀请ChatGPT参与讨论相关主题。</p><p>模型提供了一个提示，作为对话或文本生成的起点。</p><p><strong>要使用“让我们思考一下提示”技术与ChatGPT，您可以遵循以下步骤：</strong></p><ol><li>确定您要讨论的主题或想法。</li><li>制定一个明确表达主题或想法的提示，并开始对话或文本生成。</li><li>用“让我们思考”或“让我们讨论”开头的提示，表明您正在启动对话或讨论。</li></ol><p><strong>以下是使用此技术的一些提示示例：</strong></p><ul><li>提示：“让我们思考气候变化对农业的影响”</li><li>提示：“让我们讨论人工智能的当前状态”</li><li>提示：“让我们谈谈远程工作的好处和缺点” 您还可以添加开放式问题、陈述或一段您希望模型继续或扩展的文本。</li></ul><p>提供提示后，模型将使用其训练数据和算法生成与提示相关的响应，并以连贯的方式继续对话。</p><p>这种独特的提示有助于ChatGPT以不同的视角和角度给出答案，从而产生更具动态性和信息性的段落。</p><h1 id="自洽提示"><a href="#自洽提示" class="headerlink" title="自洽提示"></a>自洽提示</h1><p> 自洽提示是一种技术，用于确保ChatGPT的输出与提供的输入一致。这种技术对于事实核查、数据验证或文本生成中的一致性检查等任务非常有用。 </p><h2 id="示例1：文本生成"><a href="#示例1：文本生成" class="headerlink" title="示例1：文本生成"></a><strong>示例1：文本生成</strong></h2><ul><li>任务：生成产品评论</li><li>指令：评论应与输入中提供的产品信息一致</li><li>提示公式：“生成与以下产品信息一致的产品评论[插入产品信息]”</li></ul><h2 id="示例2：文本摘要"><a href="#示例2：文本摘要" class="headerlink" title="示例2：文本摘要"></a><strong>示例2：文本摘要</strong></h2><ul><li>任务：概括一篇新闻文章</li><li>指令：摘要应与文章中提供的信息一致</li><li>提示公式：“用与提供的信息一致的方式概括以下新闻文章[插入新闻文章]”</li></ul><h2 id="示例3：文本完成"><a href="#示例3：文本完成" class="headerlink" title="示例3：文本完成"></a><strong>示例3：文本完成</strong></h2><ul><li>任务：完成一个句子</li><li>指令：完成应与输入中提供的上下文一致</li><li>提示公式：“以与提供的上下文一致的方式完成以下句子[插入句子]”</li></ul><h2 id="示例4：事实核查与数据验证"><a href="#示例4：事实核查与数据验证" class="headerlink" title="示例4：事实核查与数据验证"></a><strong>示例4：</strong>事实核查与数据验证</h2><ol><li><p><strong>事实核查：</strong></p><p>任务：检查给定新闻文章的一致性</p><p>输入文本：“文章中陈述该城市的人口为500万，但后来又说该城市的人口为700万。”</p><p>提示公式：“请确保以下文本是自洽的：文章中陈述该城市的人口为500万，但后来又说该城市的人口为700万。”</p></li><li><p><strong>数据验证：</strong></p><p>任务：检查给定数据集的一致性</p><p>输入文本：“数据显示7月份的平均温度为30度，但最低温度记录为20度。”</p><p>提示公式：“请确保以下文本是自洽的：数据显示7月份的平均温度为30度，但最低温度记录为20度。”</p></li></ol><h1 id="种子词提示"><a href="#种子词提示" class="headerlink" title="种子词提示"></a>种子词提示</h1><p> 种子词提示是一种通过提供特定的种子词或短语来控制ChatGPT输出的技术。种子词提示的提示公式是种子词或短语，后跟指令“请根据以下种子词生成文本”。 </p><p>示例：</p><h2 id="文本生成："><a href="#文本生成：" class="headerlink" title="文本生成："></a><strong>文本生成：</strong></h2><ul><li>任务：编写一篇有关龙的故事</li><li>种子词：“龙”</li><li>提示公式：“请根据以下种子词生成文本：龙”</li></ul><h2 id="语言翻译："><a href="#语言翻译：" class="headerlink" title="语言翻译："></a><strong>语言翻译：</strong></h2><ul><li>任务：将一句话从英语翻译成西班牙语</li><li>种子词：“你好”</li><li>提示公式：“请根据以下种子词生成文本：你好”</li></ul><h2 id="种子词提示可以与角色提示和指令提示相结合"><a href="#种子词提示可以与角色提示和指令提示相结合" class="headerlink" title="种子词提示可以与角色提示和指令提示相结合"></a>种子词提示可以与角色提示和指令提示相结合</h2><h2 id="示例1：文本生成-1"><a href="#示例1：文本生成-1" class="headerlink" title="示例1：文本生成"></a><strong>示例1：文本生成</strong></h2><ul><li>任务：编写一首诗</li><li>指令：诗应与种子词“爱”相关，并以十四行诗的形式书写。</li><li>角色：诗人</li><li>提示公式：“作为诗人，根据以下种子词生成与“爱”相关的十四行诗：”</li></ul><h2 id="示例2：文本完成"><a href="#示例2：文本完成" class="headerlink" title="示例2：文本完成"></a><strong>示例2：文本完成</strong></h2><ul><li>任务：完成一句话</li><li>指令：完成应与种子词“科学”相关，并以研究论文的形式书写。</li><li>角色：研究员</li><li>提示公式：“作为研究员，请在与种子词“科学”相关且以研究论文的形式书写的情况下完成以下句子：[插入句子]”</li></ul><h2 id="示例3：文本摘要"><a href="#示例3：文本摘要" class="headerlink" title="示例3：文本摘要"></a><strong>示例3：文本摘要</strong></h2><ul><li>任务：摘要一篇新闻文章</li><li>指令：摘要应与种子词“政治”相关，并以中立和公正的语气书写。</li><li>角色：记者</li><li>提示公式：“作为记者，请以中立和公正的语气摘要以下新闻文章，与种子词“政治”相关：[插入新闻文章]”</li></ul><h1 id="知识生成提示"><a href="#知识生成提示" class="headerlink" title="知识生成提示"></a>知识生成提示</h1><p> 知识生成提示是一种从ChatGPT中引出新的、原创的信息的技术。</p><h2 id="示例1：知识生成"><a href="#示例1：知识生成" class="headerlink" title="示例1：知识生成"></a><strong>示例1：知识生成</strong></h2><ul><li>任务：生成有关特定主题的新信息</li><li>说明：生成的信息应准确且与主题相关</li><li>提示公式：“生成有关[特定主题]的新的准确信息”</li></ul><h2 id="示例2：问答"><a href="#示例2：问答" class="headerlink" title="示例2：问答"></a><strong>示例2：问答</strong></h2><ul><li>任务：回答问题</li><li>说明：答案应准确且与问题相关</li><li>提示公式：“回答以下问题：[插入问题]”</li></ul><h2 id="示例3：知识整合"><a href="#示例3：知识整合" class="headerlink" title="示例3：知识整合"></a><strong>示例3：知识整合</strong></h2><ul><li>任务：将新信息与现有知识整合</li><li>说明：整合应准确且与主题相关</li><li>提示公式：“将以下信息与有关[特定主题]的现有知识整合：[插入新信息]”</li></ul><h2 id="示例4：数据分析"><a href="#示例4：数据分析" class="headerlink" title="示例4：数据分析"></a><strong>示例4：数据分析</strong></h2><ul><li>任务：从给定的数据集中生成有关客户行为的见解</li><li>提示公式：“请从这个数据集中生成有关客户行为的新的和原创的信息”</li></ul><h1 id="知识整合提示"><a href="#知识整合提示" class="headerlink" title="知识整合提示"></a>知识整合提示</h1><p> 利用模型的现有知识来整合新信息或连接不同的信息片段。 </p><h2 id="如何与ChatGPT一起使用："><a href="#如何与ChatGPT一起使用：" class="headerlink" title="如何与ChatGPT一起使用："></a><strong>如何与ChatGPT一起使用：</strong></h2><ul><li>模型应该提供新信息和现有知识作为输入，以及指定生成文本的任务或目标的提示。</li><li>提示应包括有关所需输出的信息，例如要生成的文本类型以及任何特定的要求或限制。</li></ul><h2 id="示例1：知识整合"><a href="#示例1：知识整合" class="headerlink" title="示例1：知识整合"></a><strong>示例1：知识整合</strong></h2><ul><li>任务：将新信息与现有知识整合</li><li>说明：整合应准确且与主题相关</li><li>提示公式：“将以下信息与关于[具体主题]的现有知识整合：[插入新信息]”</li></ul><h2 id="示例2：连接信息片段"><a href="#示例2：连接信息片段" class="headerlink" title="示例2：连接信息片段"></a><strong>示例2：连接信息片段</strong></h2><ul><li>任务：连接不同的信息片段</li><li>说明：连接应相关且逻辑清晰</li><li>提示公式：“以相关且逻辑清晰的方式连接以下信息片段：[插入信息1] [插入信息2]”</li></ul><h2 id="示例3：更新现有知识"><a href="#示例3：更新现有知识" class="headerlink" title="示例3：更新现有知识"></a><strong>示例3：更新现有知识</strong></h2><ul><li>任务：使用新信息更新现有知识</li><li>说明：更新的信息应准确且相关</li><li>提示公式：“使用以下信息更新[具体主题]的现有知识：[插入新信息]”</li></ul><h1 id="多项选择提示"><a href="#多项选择提示" class="headerlink" title="多项选择提示"></a>多项选择提示</h1><p> 技术向模型提供一个问题或任务以及一组预定义的选项作为潜在答案。</p><h2 id="示例1：问答"><a href="#示例1：问答" class="headerlink" title="示例1：问答"></a><strong>示例1：问答</strong></h2><ul><li>任务：回答一个多项选择题</li><li>说明：答案应该是预定义的选项之一</li><li>提示公式：“通过选择以下选项之一回答以下问题：[插入问题] [插入选项1] [插入选项2] [插入选项3]”</li></ul><h2 id="示例2：文本完成-1"><a href="#示例2：文本完成-1" class="headerlink" title="示例2：文本完成"></a><strong>示例2：文本完成</strong></h2><ul><li>任务：使用预定义选项之一完成句子</li><li>说明：完成应该是预定义的选项之一</li><li>提示公式：“通过选择以下选项之一完成以下句子：[插入句子] [插入选项1] [插入选项2] [插入选项3]”</li></ul><h2 id="示例3：情感分析"><a href="#示例3：情感分析" class="headerlink" title="示例3：情感分析"></a><strong>示例3：情感分析</strong></h2><ul><li>任务：将文本分类为积极、中立或消极</li><li>说明：分类应该是预定义的选项之一</li><li>提示公式：“通过选择以下选项之一，将以下文本分类为积极、中立或消极：[插入文本] [积极] [中立] [消极]”</li></ul><h1 id="可解释的软提示"><a href="#可解释的软提示" class="headerlink" title="可解释的软提示"></a>可解释的软提示</h1><p> 可解释的软提示是一种技术，可以在提供一定的灵活性的同时控制模型生成的文本。它通过提供一组受控输入和关于所需输出的附加信息来实现。这种技术可以生成更具解释性和可控性的生成文本。 </p><h2 id="示例1：文本生成-2"><a href="#示例1：文本生成-2" class="headerlink" title="示例1：文本生成"></a><strong>示例1：文本生成</strong></h2><ul><li>任务：生成一个故事</li><li>指令：故事应基于一组给定的角色和特定的主题</li><li>提示公式：“基于以下角色生成故事：[插入角色]和主题：[插入主题]”</li></ul><h2 id="示例2：文本完成-2"><a href="#示例2：文本完成-2" class="headerlink" title="示例2：文本完成"></a><strong>示例2：文本完成</strong></h2><ul><li>任务：完成一句话</li><li>指令：完成应以特定作者的风格为基础</li><li>提示公式：“以[特定作者]的风格完成以下句子：[插入句子]”</li></ul><h2 id="示例3：语言建模"><a href="#示例3：语言建模" class="headerlink" title="示例3：语言建模"></a><strong>示例3：语言建模</strong></h2><ul><li>任务：以特定风格生成文本</li><li>指令：文本应以特定时期的风格为基础</li><li>提示公式：“以[特定时期]的风格生成文本：[插入上下文]”</li></ul><h1 id="控制生成提示"><a href="#控制生成提示" class="headerlink" title="控制生成提示"></a>控制生成提示</h1><p>控制生成提示是一种技术，可让模型在生成文本时对输出进行高度控制。</p><p>这可以通过提供一组特定的输入来实现，例如模板、特定词汇或一组约束条件，这些输入可用于指导生成过程。</p><h2 id="示例1：文本生成-3"><a href="#示例1：文本生成-3" class="headerlink" title="示例1：文本生成"></a><strong>示例1：文本生成</strong></h2><ul><li>任务：生成一个故事</li><li>说明：该故事应基于特定的模板</li><li>提示公式：“根据以下模板生成故事：[插入模板]”</li></ul><h2 id="示例2：文本补全"><a href="#示例2：文本补全" class="headerlink" title="示例2：文本补全"></a><strong>示例2：文本补全</strong></h2><ul><li>任务：完成一句话</li><li>说明：完成应使用特定的词汇</li><li>提示公式：“使用以下词汇完成以下句子：[插入词汇]：[插入句子]”</li></ul><h2 id="示例3：语言建模-1"><a href="#示例3：语言建模-1" class="headerlink" title="示例3：语言建模"></a><strong>示例3：语言建模</strong></h2><ul><li>任务：以特定风格生成文本</li><li>说明：文本应遵循一组特定的语法规则</li><li>提示公式：“生成遵循以下语法规则的文本：[插入规则]：[插入上下文]”</li></ul><h1 id="问答提示"><a href="#问答提示" class="headerlink" title="问答提示"></a>问答提示</h1><p> 问答提示是一种技术，可以让模型生成回答特定问题或任务的文本。通过将问题或任务与可能与问题或任务相关的任何其他信息一起作为输入提供给模型来实现此目的。 </p><h2 id="示例1：事实问题回答"><a href="#示例1：事实问题回答" class="headerlink" title="示例1：事实问题回答"></a><strong>示例1：事实问题回答</strong></h2><ul><li>任务：回答一个事实性问题</li><li>说明：答案应准确且相关</li><li>提示公式：“回答以下事实问题：[插入问题]”</li></ul><h2 id="示例2：定义"><a href="#示例2：定义" class="headerlink" title="示例2：定义"></a><strong>示例2：定义</strong></h2><ul><li>任务：提供一个词的定义</li><li>说明：定义应准确</li><li>提示公式：“定义以下词汇：[插入单词]”</li></ul><h2 id="示例3：信息检索"><a href="#示例3：信息检索" class="headerlink" title="示例3：信息检索"></a><strong>示例3：信息检索</strong></h2><ul><li>任务：从特定来源检索信息</li><li>说明：检索到的信息应相关</li><li>提示公式：“从以下来源检索有关[特定主题]的信息：[插入来源]” 这对于问答和信息检索等任务非常有用。</li></ul><h1 id="概述提示"><a href="#概述提示" class="headerlink" title="概述提示"></a>概述提示</h1><p> 概述提示是一种技术，允许模型在保留其主要思想和信息的同时生成给定文本的较短版本。 </p><p><strong>如何在ChatGPT中使用：</strong></p><ul><li>应该向模型提供较长的文本作为输入，并要求其生成该文本的摘要。</li><li>提示还应包括有关所需输出的信息，例如摘要的所需长度和任何特定要求或限制。</li></ul><h2 id="示例1：文章概述"><a href="#示例1：文章概述" class="headerlink" title="示例1：文章概述"></a><strong>示例1：文章概述</strong></h2><ul><li>任务：概述新闻文章</li><li>说明：摘要应是文章主要观点的简要概述</li><li>提示公式：“用一句简短的话概括以下新闻文章：[插入文章]”</li></ul><h2 id="示例2：会议记录"><a href="#示例2：会议记录" class="headerlink" title="示例2：会议记录"></a><strong>示例2：会议记录</strong></h2><ul><li>任务：概括会议记录</li><li>说明：摘要应突出会议的主要决策和行动</li><li>提示公式：“通过列出主要决策和行动来总结以下会议记录：[插入记录]”</li></ul><h2 id="示例3：书籍摘要"><a href="#示例3：书籍摘要" class="headerlink" title="示例3：书籍摘要"></a><strong>示例3：书籍摘要</strong></h2><ul><li>任务：总结一本书</li><li>说明：摘要应是书的主要观点的简要概述</li><li>提示公式：“用一段简短的段落总结以下书籍：[插入书名]”</li></ul><h1 id="对话提示"><a href="#对话提示" class="headerlink" title="对话提示"></a>对话提示</h1><p> 对话提示是一种技术，允许模型生成模拟两个或更多实体之间对话的文本。通过为模型提供一个上下文和一组角色或实体，以及它们的角色和背景，并要求模型在它们之间生成对话。 </p><h2 id="示例1：对话生成"><a href="#示例1：对话生成" class="headerlink" title="示例1：对话生成"></a><strong>示例1：对话生成</strong></h2><ul><li>任务：生成两个角色之间的对话</li><li>说明：对话应自然且与给定上下文相关</li><li>提示公式：“在以下情境中生成以下角色之间的对话[插入角色]”</li></ul><h2 id="示例2：故事写作"><a href="#示例2：故事写作" class="headerlink" title="示例2：故事写作"></a><strong>示例2：故事写作</strong></h2><ul><li>任务：在故事中生成对话</li><li>说明：对话应与故事的角色和事件一致</li><li>提示公式：“在以下故事中生成以下角色之间的对话[插入故事]”</li></ul><h2 id="示例3：聊天机器人开发"><a href="#示例3：聊天机器人开发" class="headerlink" title="示例3：聊天机器人开发"></a><strong>示例3：聊天机器人开发</strong></h2><ul><li>任务：为客服聊天机器人生成对话</li><li>说明：对话应专业且提供准确的信息</li><li>提示公式：“在客户询问[插入主题]时，为客服聊天机器人生成专业和准确的对话”</li></ul><h1 id="对抗性提示"><a href="#对抗性提示" class="headerlink" title="对抗性提示"></a>对抗性提示</h1><p> 对抗性提示是一种技术，它允许模型生成抵抗某些类型的攻击或偏见的文本。这种技术可用于训练更为稳健和抵抗某些类型攻击或偏见的模型。 </p><h2 id="示例1：用于文本分类的对抗性提示"><a href="#示例1：用于文本分类的对抗性提示" class="headerlink" title="示例1：用于文本分类的对抗性提示"></a><strong>示例1：用于文本分类的对抗性提示</strong></h2><ul><li>任务：生成被分类为特定标签的文本</li><li>说明：生成的文本应难以分类为特定标签</li><li>提示公式：“生成难以分类为[插入标签]的文本”</li></ul><h2 id="示例2：用于情感分析的对抗性提示"><a href="#示例2：用于情感分析的对抗性提示" class="headerlink" title="示例2：用于情感分析的对抗性提示"></a><strong>示例2：用于情感分析的对抗性提示</strong></h2><ul><li>任务：生成难以分类为特定情感的文本</li><li>说明：生成的文本应难以分类为特定情感</li><li>提示公式：“生成难以分类为具有[插入情感]情感的文本”</li></ul><h2 id="示例3：用于语言翻译的对抗性提示"><a href="#示例3：用于语言翻译的对抗性提示" class="headerlink" title="示例3：用于语言翻译的对抗性提示"></a><strong>示例3：用于语言翻译的对抗性提示</strong></h2><ul><li>任务：生成难以翻译的文本</li><li>说明：生成的文本应难以翻译为目标语言</li><li>提示公式：“生成难以翻译为[插入目标语言]的文本”</li></ul><h1 id="聚类提示"><a href="#聚类提示" class="headerlink" title="聚类提示"></a>聚类提示</h1><p>聚类提示是一种技术，它可以让模型根据某些特征或特点将相似的数据点分组在一起。</p><p>通过提供一组数据点并要求模型根据某些特征或特点将它们分组成簇，可以实现这一目标。 这种技术在数据分析、机器学习和自然语言处理等任务中非常有用。 </p><h2 id="示例1：客户评论的聚类"><a href="#示例1：客户评论的聚类" class="headerlink" title="示例1：客户评论的聚类"></a><strong>示例1：客户评论的聚类</strong></h2><ul><li>任务：将相似的客户评论分组在一起</li><li>说明：应根据情感将评论分组</li><li>提示公式：“将以下客户评论根据情感分组成簇：[插入评论]”</li></ul><h2 id="示例2：新闻文章的聚类"><a href="#示例2：新闻文章的聚类" class="headerlink" title="示例2：新闻文章的聚类"></a><strong>示例2：新闻文章的聚类</strong></h2><ul><li>任务：将相似的新闻文章分组在一起</li><li>说明：应根据主题将文章分组</li><li>提示公式：“将以下新闻文章根据主题分组成簇：[插入文章]”</li></ul><h2 id="示例3：科学论文的聚类"><a href="#示例3：科学论文的聚类" class="headerlink" title="示例3：科学论文的聚类"></a><strong>示例3：科学论文的聚类</strong></h2><ul><li>任务：将相似的科学论文分组在一起</li><li>说明：应根据研究领域将论文分组</li><li>提示公式：“将以下科学论文根据研究领域分组成簇：[插入论文]”</li></ul><h1 id="强化学习提示"><a href="#强化学习提示" class="headerlink" title="强化学习提示"></a>强化学习提示</h1><p> 强化学习提示是一种技术，可以使模型从过去的行动中学习，并随着时间的推移提高其性能。要在ChatGPT中使用强化学习提示，需要为模型提供一组输入和奖励，并允许其根据接收到的奖励调整其行为。提示还应包括有关期望输出的信息，例如要完成的任务以及任何特定要求或限制。这种技术对于决策制定、游戏玩法和自然语言生成等任务非常有用。 </p><h2 id="示例1：用于文本生成的强化学习"><a href="#示例1：用于文本生成的强化学习" class="headerlink" title="示例1：用于文本生成的强化学习"></a><strong>示例1：用于文本生成的强化学习</strong></h2><ul><li>任务：生成与特定风格一致的文本</li><li>说明：模型应根据为生成与特定风格一致的文本而接收到的奖励来调整其行为</li><li>提示公式：“使用强化学习来生成与以下风格一致的文本[插入风格]”</li></ul><h2 id="示例2：用于语言翻译的强化学习"><a href="#示例2：用于语言翻译的强化学习" class="headerlink" title="示例2：用于语言翻译的强化学习"></a><strong>示例2：用于语言翻译的强化学习</strong></h2><ul><li>任务：将文本从一种语言翻译成另一种语言</li><li>说明：模型应根据为生成准确翻译而接收到的奖励来调整其行为</li><li>提示公式：“使用强化学习将以下文本[插入文本]从[插入语言]翻译成[插入语言]”</li></ul><h2 id="示例3：用于问答的强化学习"><a href="#示例3：用于问答的强化学习" class="headerlink" title="示例3：用于问答的强化学习"></a><strong>示例3：用于问答的强化学习</strong></h2><ul><li>任务：回答问题</li><li>说明：模型应根据为生成准确答案而接收到的奖励来调整其行为</li><li>提示公式：“使用强化学习来回答以下问题[插入问题]”</li></ul><h1 id="课程学习提示"><a href="#课程学习提示" class="headerlink" title="课程学习提示"></a>课程学习提示</h1><p>  课程学习是一种技术，允许模型通过先训练简单任务，逐渐增加难度来学习复杂任务。 此技术对自然语言处理、图像识别和机器学习等任务非常有用。 </p><h2 id="示例1：用于文本生成的课程学习"><a href="#示例1：用于文本生成的课程学习" class="headerlink" title="示例1：用于文本生成的课程学习"></a><strong>示例1：用于文本生成的课程学习</strong></h2><ul><li>任务：生成与特定风格一致的文本</li><li>说明：模型应该在移动到更复杂的风格之前先在简单的风格上进行训练。</li><li>提示公式：“使用课程学习来生成与以下风格[插入风格]一致的文本，按照以下顺序[插入顺序]。”</li></ul><h2 id="示例2：用于语言翻译的课程学习"><a href="#示例2：用于语言翻译的课程学习" class="headerlink" title="示例2：用于语言翻译的课程学习"></a><strong>示例2：用于语言翻译的课程学习</strong></h2><ul><li>任务：将文本从一种语言翻译成另一种语言</li><li>说明：模型应该在移动到更复杂的语言之前先在简单的语言上进行训练。</li><li>提示公式：“使用课程学习将以下语言[插入语言]的文本翻译成以下顺序[插入顺序]。”</li></ul><h2 id="示例3：用于问题回答的课程学习"><a href="#示例3：用于问题回答的课程学习" class="headerlink" title="示例3：用于问题回答的课程学习"></a><strong>示例3：用于问题回答的课程学习</strong></h2><ul><li>任务：回答问题</li><li>说明：模型应该在移动到更复杂的问题之前先在简单的问题上进行训练。</li><li>提示公式：“使用课程学习来回答以下问题[插入问题]，按照以下顺序[插入顺序]生成答案。”</li></ul><h1 id="情感分析提示"><a href="#情感分析提示" class="headerlink" title="情感分析提示"></a>情感分析提示</h1><p> 情感分析是一种技术，允许模型确定文本的情绪色彩或态度 ， 提示还应包括关于所需输出的信息，例如要检测的情感类型（例如积极的、消极的、中立的）和任何特定要求或约束条件。 </p><h2 id="示例1：客户评论的情感分析"><a href="#示例1：客户评论的情感分析" class="headerlink" title="示例1：客户评论的情感分析"></a><strong>示例1：客户评论的情感分析</strong></h2><ul><li>任务：确定客户评论的情感</li><li>说明：模型应该将评论分类为积极的、消极的或中立的</li><li>提示公式：“对以下客户评论进行情感分析[插入评论]，并将它们分类为积极的、消极的或中立的。”</li></ul><h2 id="示例2：推文的情感分析"><a href="#示例2：推文的情感分析" class="headerlink" title="示例2：推文的情感分析"></a><strong>示例2：推文的情感分析</strong></h2><ul><li>任务：确定推文的情感</li><li>说明：模型应该将推文分类为积极的、消极的或中立的</li><li>提示公式：“对以下推文进行情感分析[插入推文]，并将它们分类为积极的、消极的或中立的。”</li></ul><h2 id="示例3：产品评论的情感分析"><a href="#示例3：产品评论的情感分析" class="headerlink" title="示例3：产品评论的情感分析"></a><strong>示例3：产品评论的情感分析</strong></h2><ul><li>任务：确定产品评论的情感</li><li>说明：模型应该将评论分类为积极的、消极的或中立的</li><li>提示公式：“对以下产品评论进行情感分析[插入评论]，并将它们分类为积极的、消极的或中立的。”</li></ul><h1 id="命名实体识别提示"><a href="#命名实体识别提示" class="headerlink" title="命名实体识别提示"></a>命名实体识别提示</h1><p> 命名实体识别（NER）是一种技术，它可以使模型识别和分类文本中的命名实体，  提示还应包括有关所需输出的信息，例如要识别的命名实体类型（例如人名、组织机构、地点、日期）以及任何特定要求或约束条件。 </p><h2 id="示例1：新闻文章中的命名实体识别"><a href="#示例1：新闻文章中的命名实体识别" class="headerlink" title="示例1：新闻文章中的命名实体识别"></a><strong>示例1：新闻文章中的命名实体识别</strong></h2><ul><li>任务：在新闻文章中识别和分类命名实体</li><li>说明：模型应识别和分类人名、组织机构、地点和日期</li><li>提示公式：“在以下新闻文章[插入文章]上执行命名实体识别，并识别和分类人名、组织机构、地点和日期。”</li></ul><h2 id="示例2：法律文件中的命名实体识别"><a href="#示例2：法律文件中的命名实体识别" class="headerlink" title="示例2：法律文件中的命名实体识别"></a><strong>示例2：法律文件中的命名实体识别</strong></h2><ul><li>任务：在法律文件中识别和分类命名实体</li><li>说明：模型应识别和分类人名、组织机构、地点和日期</li><li>提示公式：“在以下法律文件[插入文件]上执行命名实体识别，并识别和分类人名、组织机构、地点和日期。”</li></ul><h2 id="示例3：研究论文中的命名实体识别"><a href="#示例3：研究论文中的命名实体识别" class="headerlink" title="示例3：研究论文中的命名实体识别"></a><strong>示例3：研究论文中的命名实体识别</strong></h2><ul><li>任务：在研究论文中识别和分类命名实体</li><li>说明：模型应识别和分类人名、组织机构、地点和日期</li><li>提示公式：“在以下研究论文[插入论文]上执行命名实体识别，并识别和分类人名、组织机构、地点和日期。”</li></ul><h1 id="文本分类提示"><a href="#文本分类提示" class="headerlink" title="文本分类提示"></a>文本分类提示</h1><p> 文本分类是一种技术，它可以让模型将文本分成不同的类别。这种技术对于自然语言处理、文本分析和情感分析等任务非常有用。  要在ChatGPT中使用文本分类提示，模型需要提供一段文本，并要求它根据预定义的类别或标签进行分类。提示还应包括有关所需输出的信息，例如类别或标签的数量以及任何特定的要求或约束。 </p><h2 id="示例1：对客户评论进行文本分类"><a href="#示例1：对客户评论进行文本分类" class="headerlink" title="示例1：对客户评论进行文本分类"></a><strong>示例1：对客户评论进行文本分类</strong></h2><ul><li>任务：将客户评论分类为不同的类别，例如电子产品、服装和家具</li><li>说明：模型应根据评论的内容对其进行分类</li><li>提示公式：“对以下客户评论 [插入评论] 进行文本分类，并根据其内容将其分类为不同的类别，例如电子产品、服装和家具。”</li></ul><h2 id="示例2：对新闻文章进行文本分类"><a href="#示例2：对新闻文章进行文本分类" class="headerlink" title="示例2：对新闻文章进行文本分类"></a><strong>示例2：对新闻文章进行文本分类</strong></h2><ul><li>任务：将新闻文章分类为不同的类别，例如体育、政治和娱乐</li><li>说明：模型应根据文章的内容对其进行分类</li><li>提示公式：“对以下新闻文章 [插入文章] 进行文本分类，并根据其内容将其分类为不同的类别，例如体育、政治和娱乐。”</li></ul><h2 id="示例3：对电子邮件进行文本分类"><a href="#示例3：对电子邮件进行文本分类" class="headerlink" title="示例3：对电子邮件进行文本分类"></a><strong>示例3：对电子邮件进行文本分类</strong></h2><ul><li>任务：将电子邮件分类为不同的类别，例如垃圾邮件、重要邮件或紧急邮件</li><li>说明：模型应根据电子邮件的内容和发件人对其进行分类</li><li>提示公式：“对以下电子邮件 [插入电子邮件] 进行文本分类，并根据其内容和发件人将其分类为不同的类别，例如垃圾邮件、重要邮件或紧急邮件。”</li></ul><h1 id="文本生成提示"><a href="#文本生成提示" class="headerlink" title="文本生成提示"></a>文本生成提示</h1><p> 文本生成提示与本书中提到的其他提示技术相关，例如：零、一、几次提示，受控生成提示，翻译提示，语言建模提示，句子补全提示等。这些提示都与生成文本有关，但它们在生成文本的方式和放置在生成文本上的特定要求或限制方面有所不同。文本生成提示可用于微调预训练模型或训练新模型以执行特定任务。 </p><h2 id="示例1：故事创作的文本生成"><a href="#示例1：故事创作的文本生成" class="headerlink" title="示例1：故事创作的文本生成"></a><strong>示例1：故事创作的文本生成</strong></h2><ul><li>任务：根据给定的提示生成故事</li><li>说明：故事应至少包含1000个单词，并包括一组特定的角色和情节。</li><li>提示公式：“根据以下提示[插入提示]生成一个至少包含1000个单词，包括角色[插入角色]和情节[插入情节]的故事。”</li></ul><h2 id="示例2：语言翻译的文本生成"><a href="#示例2：语言翻译的文本生成" class="headerlink" title="示例2：语言翻译的文本生成"></a><strong>示例2：语言翻译的文本生成</strong></h2><ul><li>任务：将给定的文本翻译成另一种语言</li><li>说明：翻译应准确并符合习惯用语。</li><li>提示公式：“将以下文本[插入文本]翻译成[插入目标语言]，并确保其准确且符合习惯用语。”</li></ul><h2 id="示例3：文本完成的文本生成"><a href="#示例3：文本完成的文本生成" class="headerlink" title="示例3：文本完成的文本生成"></a><strong>示例3：文本完成的文本生成</strong></h2><ul><li>任务：完成给定的文本</li><li>说明：生成的文本应与输入文本连贯一致。</li><li>提示公式：“完成以下文本[插入文本]，并确保其连贯一致且符合输入文本。”</li></ul><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>在本文中，我们探讨了充分利用prompt的力量与聊天机器人进行互动的重要性。通过选择合适的提示词、添加背景知识和约束条件，以及运用多轮对话和上下文引用等技巧，我们可以获得令人满意的回答和交流结果。不断调整和优化prompt是一个持续的过程，通过这些方法，我们能够更好地与聊天机器人互动，探索和发展人工智能技术，为未来的交流带来新的可能性。</p>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
            <tag> chatgpt </tag>
            
            <tag> 人工智能 </tag>
            
            <tag> prompt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>社会工程学</title>
      <link href="/shen-tou-she-hui-gong-cheng-xue.html"/>
      <url>/shen-tou-she-hui-gong-cheng-xue.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="何为社会工程学攻击"><a href="#何为社会工程学攻击" class="headerlink" title="何为社会工程学攻击?"></a>何为社会工程学攻击?</h1><p>社会工程学是一种通过对受害者心理弱点、本能反应、好奇心、信任、贪婪等心理陷阱进行诸如欺骗、伤害等危害手段。</p><p>社工库的形成过程：拖库（黑客入侵有价值的网站，盗取用户数据库）——洗库（清洗数据，并将有价值的用户数据变现交易）——撞库（将得到的数据在其他网站上进行登录测试）——社工库（社工库指整合多个被盗数据库，形成专门用于社工欺诈的多维度海量用户信息）</p><h1 id="多种角度讲解我们的信息是如何泄露"><a href="#多种角度讲解我们的信息是如何泄露" class="headerlink" title="多种角度讲解我们的信息是如何泄露"></a>多种角度讲解我们的信息是如何泄露</h1><h2 id="信息泄露之密码学"><a href="#信息泄露之密码学" class="headerlink" title="信息泄露之密码学"></a>信息泄露之密码学</h2><p> 密码学是信息安全领域的一个重要分支，主要研究如何通过密码算法来保护数据安全性、完整性和机密性。在信息泄露方面，密码学扮演着至关重要的角色，尤其是在密码保护和加密方面 ；</p><p>常用的md5加密：MD5 是一种哈希算法，已被证明存在碰撞攻击， 可以通过特定的攻击手段生成相同的 MD5 值，这意味着 MD5 不再是安全的加密方式。因此，对于安全性要求高的应用场景，不应该使用 MD5 作为加密算法。 </p><p> SHA-256 (Secure Hash Algorithm 256-bit) 是比 MD5 更强大和安全的哈希算法，并且目前还没有被证明存在有效的攻击方法。SHA-256 可以产生一个 256 位长度的哈希值，通常用于数字签名、消息认证、信息摘要等领域 </p><h2 id="信息泄露之whois查询"><a href="#信息泄露之whois查询" class="headerlink" title="信息泄露之whois查询"></a>信息泄露之whois查询</h2><p>whois(读作“Who is”，非缩写)是用来查询域名的IP以及所有者等信息的传输协议。简单说，whois就是一个用来查询域名是否已经被注册，以及注册域名的详细信息的数据库(如域名所有人、域名注册商)。通过whois来实现对域名信息的查询。早期的whois查询多以命令列接口存在，但是现在出现了一些网页接口简化的线上查询工具，可以一次向不同的数据库查询。网页接口的查询工具仍然依赖whois协议向服务器发送查询请求，命令列接口的工具仍然被系统管理员广泛使用。whois通常使用TCP协议43端口。每个域名/1P的whois信息由对应的管理机构保存。</p><h2 id="信息泄露之Maltego"><a href="#信息泄露之Maltego" class="headerlink" title="信息泄露之Maltego"></a>信息泄露之Maltego</h2><p> Maltego是一款功能强大的开源情报（OSINT）和数据可视化工具，用于信息收集和分析。它允许用户从各种来源（如DNS记录、社交媒体资料、公共记录和其他在线来源）收集信息，并以图形格式呈现所收集数据之间的关系。 Maltego可用于各种目的，包括威胁情报、欺诈检测、网络基础设施映射和漏洞分析。该工具被广泛用于安全专业人员、执法机构和调查记者。  </p><h2 id="信息泄露之地址-利用XSS进行定位"><a href="#信息泄露之地址-利用XSS进行定位" class="headerlink" title="信息泄露之地址(利用XSS进行定位)"></a>信息泄露之地址(利用XSS进行定位)</h2><p>  这种攻击通常使用JavaScript代码注入到网页中，该代码会向远程服务器发送请求，从而暴露了用户的位置信息。攻击者可能会将这些数据用于诈骗、跟踪或其他恶意行为；对于网络诈骗的犯罪分子，只有真的定位到了他的精确位置，报警处理追回财产的可能性才会最大。当于个人用户，在上网冲浪的过程中，随意点开别人的连接也会造成地址信息的泄露；</p><h2 id="信息泄露之身份信息泄露"><a href="#信息泄露之身份信息泄露" class="headerlink" title="信息泄露之身份信息泄露"></a>信息泄露之身份信息泄露</h2><p> 身份信息泄露是指个人的敏感身份信息被未经授权的第三方获取或公开。这些身份信息可能包括姓名、出生日期、社会安全号码、银行账户信息、信用卡号码、驾驶执照号码等，可以被用于欺诈、盗窃身份、恶意活动等。</p><p>身份信息泄露的主要原因包括以下几个方面：</p><ol><li>网络攻击：网络黑客或骇客利用漏洞攻击目标系统，获取个人身份信息。</li><li>社交工程：攻击者通过伪造身份或其他手段，获取个人身份信息。</li><li>数据泄露：企业或机构的数据库被黑客攻击或失窃，导致个人身份信息被泄露。</li><li>丢失或遗忘：重要文件或设备在日常生活中丢失或忘记带走，从而导致个人身份信息泄露</li></ol><h2 id="信息泄露之大数据"><a href="#信息泄露之大数据" class="headerlink" title="信息泄露之大数据"></a>信息泄露之大数据</h2><p>大数据分析可能导致隐私泄露：大数据包含了大量的个人信息和行为数据，因此，当这些数据被大规模地收集和分析时，可能会揭示出原本不为人知的个人隐私。例如，通过分析某人的社交媒体、购买历史、搜索记录等数据，就可以得到他的生活习惯、兴趣爱好、家庭情况等敏感信息。</p><p>大数据存储可能存在安全风险：大数据通常需要使用分布式计算技术进行存储，这意味着数据可能分散在多个地方存储，同时还存在网络传输和访问的安全风险。任何未授权的访问、黑客攻击或数据泄露都可能导致个人信息的泄露。</p><h1 id="如何防范社会工程学"><a href="#如何防范社会工程学" class="headerlink" title="如何防范社会工程学"></a>如何防范社会工程学</h1><ol><li>增强安全意识：加强个人和组织成员对于社会工程学攻击的认知，提高警惕，不要轻信陌生人或来源不明的信息。</li><li>加强身份验证：在重要场合或需要保护敏感信息时，应该采取多因素身份验证，如使用密码、指纹识别、智能卡等方式来确认身份。</li><li>不透露个人信息：避免随意透露个人敏感信息，如社会安全号码、银行账户、信用卡号等。</li><li>定期更改密码：采用强密码并定期更改，不要将相同的密码用于多个账户。</li><li>借助技术手段：采用杀毒软件、防火墙、反垃圾邮件过滤器等技术手段，以及进行安全培训和演练，提高组织成员的安全意识和防范能力。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
            <tag> 社工 </tag>
            
            <tag> Maltego </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>google_hacking</title>
      <link href="/shen-tou-google-hacking.html"/>
      <url>/shen-tou-google-hacking.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在我们日常生活中，Google已经成为了获取信息的重要工具。然而，这个强大的搜索引擎同时也可能被用来进行一些我们未曾察觉的活动，这其中就包括Google hacking，对于经常使用google的我，利用其该语法功能，更加精准便捷地搜索到很多东西，为此，做以下总结记录</p><h2 id="Google-hacking是什么？"><a href="#Google-hacking是什么？" class="headerlink" title="Google hacking是什么？"></a>Google hacking是什么？</h2><p>Google hacking，维基百科解释： 是指利用谷歌搜索引擎中的高级操作符，在搜索结果中定位特定的文本字符串 。这种技术利用的是网站配置和代码中存在的安全漏洞，通过特定的搜索语法来寻找和利用这些漏洞。</p><h2 id="Google-hacking常用的技术语法"><a href="#Google-hacking常用的技术语法" class="headerlink" title="Google hacking常用的技术语法"></a>Google hacking常用的技术语法</h2><p>列举常用的google语法，通过这些语法更好定位想要的信息；更多详细的语法，可以进数据库查看</p><ul><li><strong>site:</strong>：这个操作符可以让你只在特定网站内进行搜索。例如，”site:example.com” 就会在 example.com 网站内搜索。</li><li><strong>filetype:</strong>：这个操作符可以帮助你搜索特定类型的文件。例如，”filetype:pdf” 就会搜索PDF文件。</li><li><strong>intitle:</strong>：使用这个操作符可以搜索包含特定词语的网页标题。例如，”intitle:password” 会搜索标题中含有 “password” 的网页。</li><li><strong>inurl:</strong>：这个操作符可以搜索URL中包含特定词语的网页。例如，”inurl:admin” 会搜索URL中包含 “admin” 的网页。</li><li><strong>intext:</strong>：使用这个操作符可以搜索网页正文中包含特定词语的网页。例如，”intext:confidential” 会搜索正文中含有 “confidential” 的网页。</li><li><strong>cache:</strong>：这个操作符可以帮助你查看Google对某个网页的缓存版本。例如，”cache:example.com” 会显示Google最近一次索引 example.com 的快照。</li><li><strong>link:</strong>：这个操作符可以帮助你查找链接到特定URL的所有网页，不过这个功能在2017年被Google关闭，现在可能已经不能用了。</li><li><strong>info:</strong>：这个操作符可以帮助你获取关于特定URL的基本信息，如网页描述、相关链接等。</li><li><strong>related:</strong>：这个操作符可以帮你查找和特定网站内容相关的网站。</li><li><strong>stocks:</strong>：这个操作符可以帮助你查找特定公司的股票信息。</li></ul><blockquote><p>google hacking语法库：<a href="https://www.exploit-db.com/google-hacking-database" target="_blank" rel="noopener">https://www.exploit-db.com/google-hacking-database</a></p></blockquote><p>符号类</p><ul><li><strong>使用双引号(“ “)进行精确匹配</strong>：例如，搜索 “太阳能电池” 将只返回包含完整词组 “太阳能电池” 的结果。</li><li><strong>使用减号(-)排除特定词汇</strong>：例如，搜索 “iPhone -12” 将返回与 iPhone 相关的结果，但不包括 “iPhone 12”。</li><li><strong>使用星号(*)作为通配符</strong>：例如，搜索 “Apple 的 * 手机” 可以返回 “Apple 的 iPhone 手机”、”Apple 的 5G 手机” 等结果。</li><li><strong>使用 OR 查询多个词</strong>：例如，搜索 “华为 OR 小米” 将返回与 “华为” 或 “小米” 相关的结果</li></ul><h2 id="如何利用-防范Google-hacking？"><a href="#如何利用-防范Google-hacking？" class="headerlink" title="如何利用/防范Google hacking？"></a>如何利用/防范Google hacking？</h2><p>利用: 利用好google hacking 可以更准确找到自己需要的信息，做到真正的高效搜索</p><p>防范：Google hacking的首要步骤是对自己的网络环境有深入的了解，包括服务器配置、代码安全等。其次，定期进行安全审计和漏洞扫描也非常重要，这可以帮助我们及时发现并修复潜在的安全问题。最后，我们还可以通过robots.txt文件来限制搜索引擎对敏感信息的索引，从而避免信息被黑客搜索到。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>google hacking 是一种对个人搜索有利的语法知识，加以利用是我们在日常使用中的好利刃；虽然Google hacking可能会带来安全威胁，但只要我们有充足的了解和正确的防范措施，就完全可以保护我们的信息安全。通过持续学习和保持警惕，我们能够在享受互联网带来的便利的同时，也保护好自己的网络安全。</p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术分享 </tag>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日60s读懂世界</title>
      <link href="/sui-bi-mei-ri-60s.html"/>
      <url>/sui-bi-mei-ri-60s.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img src="https://api.03c3.cn/zb/" alt="每日60s读懂世界">]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>chatgpt接入微信</title>
      <link href="/ai-chatgpt-jie-ru-wei-xin.html"/>
      <url>/ai-chatgpt-jie-ru-wei-xin.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="做好前期准备"><a href="#做好前期准备" class="headerlink" title="做好前期准备"></a>做好前期准备</h1><ul><li>一台云服务器</li><li>一个chatgpt账号，带有apikey，用于使用api接口</li><li>github账号 ，用于获取项目</li><li>还有就是一颗愿意折腾，好奇的心，打造属于自己私人小助手和小群体的群聊助手伙伴</li></ul><h1 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h1><img src="https://cdn.jsdelivr.net/gh/Bevis23/blog-pic/bot%E6%95%88%E6%9E%9C%E5%9B%BE.png" style="zoom:20%;"><h2 id="服务器选择"><a href="#服务器选择" class="headerlink" title="服务器选择"></a>服务器选择</h2><p>由于api接口后期也被墙了，使用境外服务器的话就不需要配置代理，相对方便；</p><p>我个人是弄了一台腾讯云，轻量级， CentOS7.6的操作系统 ；新人首次112一年，够用；</p><h2 id="chatgpt账号注册"><a href="#chatgpt账号注册" class="headerlink" title="chatgpt账号注册"></a>chatgpt账号注册</h2><p>注册的话，用邮箱，用sms接码验证便可注册，这里不具体阐述，会自带5$的api额度</p><h2 id="github账号"><a href="#github账号" class="headerlink" title="github账号"></a>github账号</h2><p>直接账号注册，做好相关配置，获取机器人项目</p><p>项目地址：<a href="https://github.com/zhayujie/chatgpt-on-wechat" target="_blank" rel="noopener">https://github.com/zhayujie/chatgpt-on-wechat</a></p><p>项目克隆步骤:</p><p>1配置ssh key</p><p>到服务器输入命令： </p><pre class=" language-linux"><code class="language-linux">ssh-keygen -t rsa -C "xxxx@test.com"  #然后一直回车即可</code></pre><p> 2 输入以下命令，查看，复制生成的key ：</p><pre><code>cat ~/.ssh/id_rsa.pub</code></pre><p>3将复制的内容放置于github上ssh keys上，保存即可</p><h1 id="部署操作步骤"><a href="#部署操作步骤" class="headerlink" title="部署操作步骤"></a>部署操作步骤</h1><h2 id="安装相关工具和环境部署"><a href="#安装相关工具和环境部署" class="headerlink" title="安装相关工具和环境部署"></a>安装相关工具和环境部署</h2><p>环境要求为python3.9+版本</p><p> 查看一下服务器是否有下载python和git：</p><pre><code>[root@miyi_server ~]# python3 -VPython 3.9.2[root@miyi_server ~]# git --versiongit version 1.8.3.1</code></pre><p>我已经安装，假设你的服务器还没安装的话，则做如下操作，代码和注释已经很清晰，照着来就可以</p><pre><code>yum update #更新下yum源yum install -y git #安装gitcd /home #切换到/home目录下git clone git@github.com:zhayujie/chatgpt-on-wechat.git #去github仓库克隆项目yum install -y wget #安装wget，用于从Web服务器上下载python3文件wget https://www.python.org/ftp/python/3.9.2/Python-3.9.2.tgz #下载文件tar -xzvf Python-3.9.2.tgz #对文件进行解压yum install -y gcc # 从这里开始安装相关依赖yum install -y zlib-develyum install openssl-develyum install libffi-devel</code></pre><h2 id="配置python环境"><a href="#配置python环境" class="headerlink" title="配置python环境"></a>配置python环境</h2><p>对python进行相关操作</p><pre><code>cd /home/Python-3.9.2 #进入目录##编译python./configuremake altinstallln -s /usr/local/bin/python3.9 /usr/bin/python3 #加入软链接，指向该目录yum install -y python3-pip  #安装pip3##安装相关依赖包pip3 install itchat-uos==1.5.0.dev0 #安装微信机器人的包pip3 install --upgrade openai  #对openai 的包进行更新##假如更新过后python的版本发生了改变，则需要重新设置一下rm /usr/bin/python3 #删除python3软连接 ln -s /usr/local/bin/python3.9 /usr/bin/python3 #重新加入软连接pip3 install --upgrade openai #对openai 的包进行更新</code></pre><h2 id="项目配置文件操作"><a href="#项目配置文件操作" class="headerlink" title="项目配置文件操作"></a>项目配置文件操作</h2><p>python相关配置完成之后，对项目目录进行设置，配置相关参数</p><pre><code>cd ../chatgpt-on-wechat/ #进入项目目录cp config-template.json config.json #负制一份配置文件## 使用vim工具进行编辑，假设你服务器没有，只需要yum install -y vimvim config.json #打开配置文件</code></pre><p>以下配置文件的内容参数解析，根据我的注释做个人设置即可</p><pre><code>{  &quot;open_ai_api_key&quot;: &quot;此处输入你自己的apikey&quot;,  &quot;model&quot;: &quot;gpt-3.5-turbo&quot;,  &quot;proxy&quot;: &quot;http://127.0.0.1:7890&quot;, #这便是需要配置代理的情况，假设你是境外服务器，则没有这个  &quot;single_chat_prefix&quot;: [    &quot;dan&quot; #此处为私人聊天的触发词选项，我设置为dan，私人聊天便会按照这个触发词来决定是否由bot回答  ],  &quot;single_chat_reply_prefix&quot;: &quot;&quot;,  &quot;group_chat_prefix&quot;: [    &quot;@dan&quot;  #群聊触发 为@dan  ],  &quot;group_name_white_list&quot;: [    &quot;ALL_GROUP&quot;  #设置所有群都开启bot功能  ],  &quot;group_chat_in_one_session&quot;: [    &quot;ChatGPT测试群&quot;   ],  &quot;image_create_prefix&quot;: [    &quot;画&quot;,    &quot;看&quot;,    &quot;找&quot; #此为图片触发词  ],  &quot;speech_recognition&quot;: true,  #是否打开语音识别，针对私聊  &quot;group_speech_recognition&quot;: false,  #是否打开语音识别，针对群聊  &quot;voice_reply_voice&quot;: false, #是否开启语音回复  &quot;conversation_max_tokens&quot;: 10000, #回复token的限制长度  &quot;expires_in_seconds&quot;: 3600, #响应时间  &quot;character_desc&quot;: &quot;你是ChatGPT, 一个由OpenAI训练的大型语言模型, 你旨在回答并解决人们的任何问题，并且可以使用多种语言与人交流。&quot;,  &quot;subscribe_msg&quot;: &quot;感谢您的关注！\n这里是ChatGPT，可以自由对话。\n支持语音对话。\n支持图片输入。\n支持图片输出，画字开头的消息将按要求创作图片。\n支持tool、角色扮演和文字冒险等丰富的插件。\n输入{trigger_prefix}#help 查看详细指令。&quot;}</code></pre><p>配置完成 按ESC 输入  :wq 便可以保存退出</p><p>安装运行相关的python3库</p><pre><code>pip3 install chatgpt_tool_hubpip3 install qrcodepip3 install pyqrcodepython3 app.py #运行app.py，便会出现二维码，扫码登录即可使用机器人</code></pre><h2 id="让bot永不间断地回复"><a href="#让bot永不间断地回复" class="headerlink" title="让bot永不间断地回复"></a>让bot永不间断地回复</h2><p>服务是用终端进行连接的，终端进程会随着终端的关闭同时关闭，这时候即使服务器24小时开着，bot也会随着终端的关闭而停止，这时候需要想个法子让它在后台一直运行</p><p>面对这个问题，采用linux下的 nohup工具便可解决</p><pre><code>touch nohup.out #先创建一个nohup.outnohup python3 app.py &amp; tail -f nohup.out #让应用程序以后台方式运行，并将输出日志重定向到nohup.out文件中，同时使用tail -f命令来实时监控nohup.out文件的内容变化;# 当需要关闭后台时候ps -ef | grep app.py #查看进程kill -9 进程号</code></pre><p>到此，整个操作就完成了，可以实现微信机器人的功能了</p><h1 id="服务器代理设置"><a href="#服务器代理设置" class="headerlink" title="服务器代理设置"></a>服务器代理设置</h1><p>上面提到，用国内服务器的，需要配置相关的代理服务，在这篇里不做阐述； 大体的实现是在服务器上配置代理，方式有很多种，个人使用的是clash for linux，同样需要配置后台运行，这时候使用的则是配置systemd服务了，相对方便；配置代理文件等</p><p>综上，直接使用不需要配置代理的服务器会方便很多，只需按我上面提到的操作即可。</p>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
            <tag> chatgpt </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>共享无价：资源分享合集</title>
      <link href="/zi-yuan-fen-xiang-gong-xiang-wu-jie-zi-yuan-fen-xiang-he-ji.html"/>
      <url>/zi-yuan-fen-xiang-gong-xiang-wu-jie-zi-yuan-fen-xiang-he-ji.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="共享无价：资源分享合集"><a href="#共享无价：资源分享合集" class="headerlink" title="共享无价：资源分享合集"></a>共享无价：资源分享合集</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>遇到某些问题，需要啥资源了，就来看此帖，主张一个   “你刚好需要，而我，刚好出现O(∩_∩)O”</p><p>当我们需要某些资源时，通常会选择购买或寻找其他来源来满足我们的需求。购买资源可能是一种常见的方式，但有时我们可能会遇到价格过高或难以获得的困境。这时，我们开始寻找替代方案，以满足我们的需求。互联网的急速发展，信息爆炸，寻找资源，找到好用免费的资源，有时候不是那么容易。为此我打算在平台和社区分享我的知识、技能、工具、内容和创意。</p><p>为什么做资源分享？</p><p>我个人认为：分享者获得满足感和建立社交网络，受益者获得免费和有价值的资源。</p><p>资源合集：<a href="https://flowus.cn/bevis23/416a6010-b2d6-4201-8937-b7a83099a65d#48c77cfa-d699-4cb7-b213-f51e4a253cb8" target="_blank" rel="noopener">Bevis_Geek</a></p><p>网站导航：<a href="https://miyi23.github.io/" target="_blank" rel="noopener">宓翊导航</a></p><blockquote><p>详见“极客导航”栏</p></blockquote><p>我会将各种资源放在flowus社区，就是以上链接；此博客由hexo搭建，托管于github，对于零碎的资源分享链接放置于社区更加方便，博客则用于分享其中一些资源的使用方法与心得</p><h2 id="免费资源的种类"><a href="#免费资源的种类" class="headerlink" title="免费资源的种类"></a>免费资源的种类</h2><ul><li>网站资源 </li><li>AI合集</li><li>软件与app</li><li>浏览器增强-插件</li><li>实用工具</li><li>github汇总</li><li>阅读分享</li><li>问题收集</li><li>数据分析</li><li>安全见闻</li><li>编程</li></ul><h2 id="资源分享的好处"><a href="#资源分享的好处" class="headerlink" title="资源分享的好处"></a>资源分享的好处</h2><p>成功的资源分享者往往能够获得丰富的回报。他们与其他专业人士建立了有价值的合作关系，扩大了自己的网络和人脉。同时，他们也获得了更多的学习机会和个人成长的空间。通过分享资源，您将在知识交流、专业发展和个人成就方面获得无限的机遇和成就感。</p><p>所以，不要犹豫，成为资源分享者，积极贡献您的知识和资源。共享文化的重要性不可低估，而您的参与将为您和他人带来巨大的收益和影响力。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>赠人玫瑰，手留余香；我受益于互联网，同时也成为互联网的分享者，和万千分享者一样，不忘初心。</p><p>最后，还是这句：永远保持好奇心，去探索，去直面自己的感受，面对万物渐变，宓而待之，追翊于廖廓，终有所感，终有所得……</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=857896&auto=1&height=66"></iframe>]]></content>
      
      
      <categories>
          
          <category> 资源分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 资源分享 </tag>
            
            <tag> geek </tag>
            
            <tag> hugo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dream</title>
      <link href="/yue-du-fen-xiang-dream.html"/>
      <url>/yue-du-fen-xiang-dream.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>不是每个人都应该像我这样去建造一座水晶大教堂，但是每个人都应该拥有自己的梦想，设计自己的梦想，追求自己的梦想，实现自己的梦想。梦想是生命的灵魂，是心灵的灯塔，是引导人走向成功的信仰。有了崇高的梦想，只要矢志不渝地追求，梦想就会成为现实，奋斗就会变成壮举，生命就会创造奇迹。——罗伯·舒乐 </p><div align="middle">    <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=2048584480&auto=1&height=66"></iframe></div>]]></content>
      
      
      <categories>
          
          <category> 阅读分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活记录 </tag>
            
            <tag> 阅读 </tag>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客的新开始</title>
      <link href="/sui-bi-bo-ke-de-xin-kai-shi.html"/>
      <url>/sui-bi-bo-ke-de-xin-kai-shi.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="欢迎来到我的博客"><a href="#欢迎来到我的博客" class="headerlink" title="欢迎来到我的博客"></a>欢迎来到我的博客</h1><p>欢迎大家来到我的博客！我很高兴你们能在这个虚拟空间中找到我。</p><h2 id="博客的目标"><a href="#博客的目标" class="headerlink" title="博客的目标"></a>博客的目标</h2><p>这个博客的主要目标是分享和记录。我将在这里分享我的一些知识与资源、经验和想法，同时也将这个空间作为记录我个人成长和探索的地方。</p><p>我相信，学习是一个永无止境的过程，而分享和记录则是这个过程的重要组成部分。分享可以帮助我们更深入地理解我们所学的东西，同时也可以帮助其他人。记录则可以帮助我们反思，看看我们从哪里来，以及我们正在走向何方。</p><p>秉承极客文化，极客文化强调开源共享、创客精神和持续学习的重要性， 保持无尽好奇心和不断追求知识，记录于此。</p><h2 id="预期的内容"><a href="#预期的内容" class="headerlink" title="预期的内容"></a>预期的内容</h2><p>在接下来的日子里，我将在这个博客中发布各种各样的文章。可能是关于技术的，比如编程、人工智能或者是资源分享。可能是关于艺术的，比如阅读、绘画或音乐。也可能是关于生活的思考，比如健康、旅行或者是个人成长。</p><p>我也希望能够听到你们的声音。如果你有任何的问题、建议或者是想要分享的话题，欢迎在评论区留言。我会很高兴能和你们进行交流。</p><h2 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h2><p>在这个瞬息万变的世界里，有一件事是永恒的，那就是变化。我期待在这个变化中找到我自己，也期待和你们一起探索这个美好的世界。<br>最后的最后，永远保持好奇心，去探索，去直面自己的感受，面对万物渐变，宓而待之，追翊于廖廓，终有所感，终有所得……</p><p>感谢你的阅读，我们下次见！</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
